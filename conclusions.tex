\section{Conclusions}
\label{sec:conclusions}

This paper presents a global type inference algorithm applicable to
Featherweight Generic Java (FGJ). To this end, we define a language
\FGJGT that characterizes FGJ programs amenable to type inference: its
methods carry no type annotations and it does not permit polymorphic recursion.
This language corresponds to a strict subset of FGJ.

The inference algorithm is constraint based and is able to infer
generalized method types with bounded generic types. 
We show this in the example in figure \ref{fig:intro-example-generic-fj}.
Here the \texttt{setfst} method is assigned a new generic type variable \texttt{Z}.
This is achieved by first structuring the input classes into strongly connected parts as shown in chapter \ref{chapter:syntax}
and afterwards processing each part respectively each class separately.
%By structuring the input classes into strongly connected parts
%our type inference algorithm is able to infer generalized method types
%as shown in figure \ref{fig:intro-example-generic-fj}.
%%Our algorithm deducts those types out of the input in \ref{fig:intro-example-generic-jtx}.
%This can only be achieved when processing each class by itself.

We clarify this via a counterexample.
Lets assume in the example in figure \ref{fig:intro-example-generic-jtx} there would be an additional methodcall to the method \texttt{setfst} inside the class \texttt{Pair} like so:
\texttt{setfst(new Integer())}.
This would cause the method \texttt{setfst} to get the type \texttt{Pair<Integer, Y> setfst(Integer fst)}.
This is due to the type rule \texttt{GT-CLASS} in figure \ref{fig:expression-typing}.
Inside the same class methods cannot be used in a polymorphic way.
We have to make this restriction to combat polymorphic recursion, which would render type inference undecidable.


\if0
We presented in this paper a global type infrerence algorithm for Featherweight
Generic Java (FGJ). FGJ is a formal calculus of Java which reduces the method
declaring block to a single expression. In
\cite{DBLP:journals/toplas/IgarashiPW01} syntax, including typing rules, and semantics of FGJ is
declared. FGJ type system corresponds with the type system of Generic Java, which is a Java with generics but without wildcards. We extended FGJ to TFGJ by adding typing rules for
programs with method without any type declaration. The principle idea of the
new typing rules is: Any type correct FGJ program, erasing the type
annotations is a correct type TFGJ program. There is one
restriction. Polymorphic recusive programs are excluded as for these programs
type inference is only semi-decidable. This means that any correct typeless TFGJ program
has an equivalent FGJ program. Therefore we leave the semantics of FGJ unchanged.

%type unification
We reduced the global type inference algorithm to a type unification algorithm
which resolves the generated constraints. The type unification algorithm is not
unitary but finitary. This means that the algorithm terminates but in general
there is more than one solution. The multiplicity of solutions are induced
either by overloading, expressed by so-called \textbf{OrConstraint}, and on the over hand by constraints of the form $a
\lessdot ty$ and $ty \lessdot a$ where $a$ is a type variable und $ty$ is a non
type variable type. In this paper we improved the type unification algorithm
such that constraints of the form $a \lessdot ty$ are not longer resolved but
transferred to bounded type parameters \texttt{a extends ty}. This reduced the
number of solutions enormously, without restricting the generality of the typing
of the TFGJ programs. Unfortunately constraints of the form $ty \lessdot a$ have
to be resolved as Java allows no lower bounds of type parameters. If we would
transfer our type inference algorithm to Scala then the solution of these
constraints could be disclaimed as Scala allows lower bounds of type
parameters. This would speed up our type inference algorithm.
\fi

In future work, we plan to extend \FGJGT to a calculus with wildcards
inspired by Wild~FJ \cite{TEP05}. 
We also plan to extend the formal calculus with lambda expressions
(cf.\ \cite{BBDGV18}), but using true function types in place of
interface types.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "TIforGFJ"
%%% End:
