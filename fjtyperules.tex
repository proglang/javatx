As \TFGJ omits some type annotations with respect to FGJ, we cannot use
FGJ's typing rules directly. Hence, we give new typing rules which are
close to FGJ's original rules, but adapted to cater for omitted types.

% The input for our type inference algorithm is based on Featherweight Generic Java (FGJ).
% FGJ is defined by syntax and typing rules.
% We already changed the syntax to allow typeless FGJ programs as input for our algorithm.
% Additionally we alter the typing rules slightly, which is presented in this chapter.

%Our type inference algorithm takes typeless FGJ classes as input.
%The generated output is correct FGJ, although we have to alter some rules.
%This chapter defines the typing rules for our version of FGJ,
%which our type inference algorithm is able to process.

Most rules stay the same as in FGJ, but we note the following changes:
\todo[inline]{PT: Why and how is overloading supported? \\
  GT-NEW should use \texttt{C} in place of \texttt{N}: see suggested GT-NEW'. \\
  The font for types and expressions changes between math and typewriter. \\
  $\triangle$ should be $\triangle$ (changed)
}
\begin{itemize}
\item The \texttt{GT-METHOD} rule is changed:
In FGJ, \textit{mtype} is a global function which returns the type for every method in every class.
In our system, \textit{mtype} is also a global function but it is differed between
methods declared in the local class and methods from other classes.
%\item Overriding of methods is removed for our typeless FGJ version. Therefore also the rule \texttt{MT-SUPER} is removed.
\item The \texttt{GT-INVK} rule is changed:
We add a new type rule \texttt{GT-L-INVK}, which handles method calls inside the same class.
Additionally we allow a method to have an intersection type.
\item We omit the rules for valid downcasts.
\todo[inline]{Andi: Is this correct? We need another constraint to be correct:
$N \lessdot_{downcast} a$ for a cast of the form: \texttt{(N)a}.
This is a different constraint then the normal subtype relationship (see FJ paper)
}
%The downcast problem:

%This is wrong:
%m(List<SortedList> p, Object o){
%  p.add((SortedList) o);
%}

%This is correct:
%m(List<SortedList> p, List<Object> o){
%  p.add((SortedList) o);
%}
%Currently we do not generate constraints for casts
\end{itemize}

In FGJ, \textit{mtype} is a global function which returns the type for every method in every class.
In our system, \textit{mtype} is also a global function but it is differed between
methods declared in the local class and methods from other classes.

The main difference between the type system of FGJ and our type system is that
in the \texttt{MT-CLASS} rule the correspondig class has to be proved as \texttt{OK}
by the \texttt{GT-CLASS} rule.
For all methods in the local class a type is assumed by the declaration of the \texttt{mtype} function.
These assumptions have to be proved as correct. Then the assumed type is
\texttt{OK} in the correspondig class. Additionally, the containing type
variables are generalized (marked by $\exptype{}{\ol{Y}}$). The type variables
$\ol{\mathtt{Y}}$ are not generalized during the prove. The reason is the
undecidablity of polymorphic recursion (cp. Sec. \ref{sec:polym-recurs}).

\fbox{
\begin{minipage}{\textwidth}
  \begin{small}
  \textbf{Subtyping:}\\[1em]
  \begin{tabularx}{\textwidth}{X c X r}
& $\mathtt{
\triangle \vdash T <: T
}
$
&   & S-REFL \\

& \\
& $\mathtt{\ddfrac{
    \triangle \vdash S <: T \quad \quad \triangle \vdash T <: U
}{
    \triangle \vdash S <: U
}}$ & & S-TRANS \\

& \\

& $\mathtt{
\triangle \vdash X <: \triangle(X)
}$ & & S-VAR \\
& \\
& $\mathtt{\ddfrac{
  \texttt{class}\ \exptype{C}{\ol{X} \triangleleft \ol{N}}
  \triangleleft \mv N \set{ \ldots }
}{
  \triangle \vdash \exptype{C}{\ol{T}} <: [\ol{T}/\ol{X}]\mv N
}}$ & & S-CLASS \\
& & & \\
\hline
\multicolumn{1}{l}{\textbf{Well-formed types:}}\\
& & & \\
& $\mathtt{
\triangle \vdash \texttt{Object}\ \text{ok}
}$ & & WF-OBJECT\\
& \\
& $\mathtt{\ddfrac{
    X \in \textit{dom}(\triangle)
}{
    \triangle \vdash X \ \text{ok}
}
}
$ & & WF-VAR \\
& \\
& $\mathtt{\ddfrac{\begin{array}{c}
\texttt{class}\ \exptype{C}{\ol{X} \triangleleft \ol{N}} \triangleleft N \{ \ldots \} \\
\triangle \vdash \ol{T} \ \text{ok} \quad \quad \triangle \vdash \ol{T} <: [\ol{T}/\ol{X}]\ol{N}
\end{array}
}{
\triangle \vdash \exptype{C}{\ol{T}} \ \text{ok}
}
}
$ & & WF-CLASS
\end{tabularx}
\end{small}
\end{minipage}
}

\newcommand{\environmentvdash}{\Pi;\triangle;\Gamma \vdash}

\fbox{
\begin{minipage}{\textwidth}
\begin{small}
\textbf{Expression Typing:}\\
\begin{tabularx}{\textwidth}{c X r}
%\begin{tabular}{l@{\quad}l}
  $\mathtt{
\environmentvdash x : \Gamma(x)
}$ & & GT-VAR \\
& \\

$\mathtt{\ddfrac{\Gamma \vdash e_0:T_0 \quad \quad \mathit{fields}(\mathit{bound}_\triangle(T_0)) = \overline{T} \ \overline{f}}
{\Gamma \vdash e_0.\mathtt{f}_i : T_i}
}
$ & & GT-FIELD \\
& \\
$\mathtt{ \ddfrac{\triangle \vdash {\mv N} \ \texttt{ok} \quad 
  \mv N = \exptype{C}{\ol{X}} \quad
  \textit{fields}(\mv N) = \ol{T}\ \ol{f} \quad 
  \environmentvdash \ol{e} : \ol{S} \quad \triangle \vdash \ol{S} <: \ol{T}
}{
  \environmentvdash \texttt{new C}(\ol{e}): \mv N
}
}$ & & GT-NEW \\

& \\

$\mathtt{\ddfrac{\begin{array}{c}
  \mathtt{\exptype{}{\ol{Y} \triangleleft \ol{P}} \ol{U} \to U \in \mathit{mtype}(m, \mathit{bound}_\triangle (T_0))} \\
  \mathtt{\environmentvdash e_0 : T_0 } \quad \quad
  \mathtt{\triangle \vdash \ol{V} \ \texttt{OK} } \quad \quad
  \mathtt{\triangle \vdash \ol{V} <: [\ol{V}/\ol{Y}]\ol{P} } \\ %\quad \quad
  \mathtt{\environmentvdash \ol{e} : \ol{S} } \quad \quad
  \mathtt{\triangle \vdash \ol{S} <: [\ol{V}/\ol{Y}]\ol{U}}
\end{array}}
{\environmentvdash \mathtt{e_0.\mv{m}(\overline{e}) : [\ol{V}/\ol{Y}]U }}
}$ & & GT-INVK\\

& \\

$\mathtt{\ddfrac{\begin{array}{c}
  \mathtt{\Pi(\exptype{C}{\ol{X}}.m) = \ol{U} \to U } \quad \quad 
  \mathtt{\environmentvdash e_0 : T_0 } \quad \quad 
  \mathtt{\textit{bound}(T_0) = \exptype{C}{\ol{Y}}} \\
  \mathtt{\environmentvdash \ol{e} : \ol{S} } \quad \quad
  \mathtt{\triangle \vdash \ol{S} <: [\ol{Y}/\ol{X}]\ol{U}}
\end{array}}
{\environmentvdash \mathtt{e_0.\mv{m}(\overline{e}) : [\ol{Y}/\ol{X}]U }}
}$ & & GT-L-INVK\\

& \\

$\ddfrac{\mathtt{\environmentvdash e_0 : T_0 \quad \quad \triangle \vdash \textit{bound}_\triangle(T_0) <: N}}
{\mathtt{\environmentvdash (N) e_0 : N}}
$ & & GT-UCAST \\

& \\

$ \ddfrac{\begin{array}{c}
  \mathtt{\environmentvdash e_0 : T_0 \quad \quad \triangle \vdash N\ \texttt{ok} \quad \quad \triangle \vdash N <: \textit{bound}_\triangle(T_0) } \\
  \mathtt{N = \exptype{C}{\ol{T}} \quad \quad \textit{bound}_\triangle(T_0) = \exptype{D}{\ol{U}}  \quad \quad \textit{dcast}(C,D)}
\end{array}
}{\mathtt{\environmentvdash (N) e_0 : N}}$ & & GT-DCAST \\

& \\

$\ddfrac{\begin{array}{c}
  \mathtt{\environmentvdash e_0 : T_0 \quad \quad \triangle \vdash N\ \texttt{ok} \quad \quad N = \exptype{C}{\ol{T}}  } \\
  \mathtt{\textit{bound}_\triangle(T_0) = \exptype{D}{\ol{U}} \quad \quad C \ntrianglelefteq D \quad \quad D \ntrianglelefteq C \quad \quad \textit{stupid warning}}
\end{array}}
{\mathtt{\environmentvdash (N) e_0 : N}}
$ & & GT-SCAST 
\end{tabularx}
\end{small}
\end{minipage}
}

\smallskip

Here we add the local method type environment $\mathtt{\Pi}$ to the \texttt{GT-METHOD} rule.
This ensures that all recursive method calls inside the same class use a non polymorphic method type.
%Type inference for polymorphic recursion is undecidable and therefore ruled out by this reformed type system for our \TFGJ language.
This change is needed to render our type inference algorithm decidable.

\smallskip

\fbox{
\begin{minipage}{\textwidth}
\begin{small}
\textbf{Method Typing:}\\[1em]
\begin{tabularx}{\textwidth}{X c X r}
  & $\mathtt{\ddfrac{\begin{array}{c}
    \mathtt{\texttt{class}\ \exptype{C}{\ol{X} \triangleleft \ol{N}} \triangleleft N \{ \ldots\ \ol{M}\ \ldots\}
    \quad \quad \triangle = \ol{X} <: \ol{N}, \ol{Y} <: \ol{P} }\\
  \mathtt{\triangle \vdash \ol{T}, T, \ol{P} \ \texttt{ok} \quad \quad
  \textit{override}(m, N, \exptype{}{\ol{Y} \triangleleft \ol{P}}\ol{T} \to T) } \\
  \mathtt{\Pi(\exptype{C}{\ol{X}}.m) = \exptype{}{\ol{Y} \triangleleft \ol{P}}\ \ol{T} \to T }\\
  \mathtt{\Pi; \triangle ; \ol{x}:\ol{T},\ this : \exptype{C}{\ol{X}} \vdash e_0 : S \quad \quad
  \triangle \vdash S <: T } \\
  \end{array}} {
  %{\exptype{}{\ol{Y} \triangleleft \ol{P}}\ T \ m(\ol{T}\ \ol{x}) \{
  %\texttt{return} \ e_0; \} \ \texttt{OK IN}\ \exptype{C}{\ol{X} \triangleleft
  %\ol{N}}}
   \mathtt{\Pi \vdash \exptype{}{\ol{Y} \triangleleft \ol{P}}\ T\ \texttt{meth}(\ol{T}\ \ol{\mathtt{x}}) \{\texttt{return}\ \mathtt{e}_0;\}
  \texttt{ OK in }\exptype{C}{\ol{X} \triangleleft \ol{N}} }
  }}$ & & GT-METHOD\\
\end{tabularx}\\[1em]
\textbf{Class Typing:}\\[1em]
  \begin{tabularx}{\textwidth}{X c X r}
  %GT-CLASS: - This rule is modified by us
  & $\ddfrac{
    \begin{array}{c}
      \mathtt{\Pi = \set{\exptype{C}{\ol{X}}.m : \ol{T_m} \to T_m \, |\, m \in \ol{M}} } \\
      \mathtt{\ol{X} <: \ol{N} \vdash \ol{N}, N, \ol{T}\ \texttt{ok}
      \quad\quad fields(\mathtt{N}) = \ol{\mathtt{U}} \ \ol{\mathtt{g}}} \quad \quad
      \mathtt{\Pi \vdash \ol{M} \ \texttt{OK IN}\ \exptype{C}{\ol{X} \triangleleft \ol{N}}}\\
      \mathtt{K = C(\overline{U} \ \overline{g}, \overline{T} \ \overline{f}) \{ \texttt{super}(\overline{g}); \ \texttt{this}.\overline{f}=\overline{f}; \} }\\
    %\quad \quad \overline{M} \ \texttt{OK IN C} \\
  \end{array}
    }
  {\mathtt{ \texttt{class}\ \exptype{C}{\ol{X} \triangleleft \ol{N}} \triangleleft N\ \{ \overline{T} \ \overline{f}; \ K \ \overline{M} \} \ \texttt{OK}}}
  $ & & GT-CLASS
\end{tabularx}
\end{small}
\end{minipage}
}

\smallskip

The \texttt{GT-METHOD} rule adds generic type variables to a method thus generalizing it.
After the whole class is deemed \texttt{ok} the generalized method can furthermore be used by other classes.

\smallskip

\fbox{
\begin{minipage}{\textwidth}
  \begin{small}
  \textbf{Method type lookup:} \\[1em]
\begin{tabularx}{\textwidth}{cXr}
  $\ddfrac{
\begin{array}{c}
  \mathtt{\texttt{class}\ \exptype{C}{\ol{X} \triangleleft \ol{N}}\ \texttt{extends N}\{ \overline{C} \ \overline{f}; \ K \ \overline{M} \} \ \texttt{OK}} \quad \quad \mathtt{m \in \ol{M}} \\
  \mathtt{
  \exptype{}{\ol{Y} \triangleleft \ol{P}}\ T\ \texttt{m}(\ol{T}\ \ol{\mathtt{x}}) \{\texttt{return}\ \mathtt{e}_0;\}
  }
\end{array}
   } {\mathtt{
     \textit{mtype}(m, \exptype{C}{\ol{T}}) = [\ol{T}/\ol{X}]\exptype{}{\ol{Y} \triangleleft \ol{P}}\ol{U} \to U
    }}$ & & MT-CLASS\\
 & & \\
  $\ddfrac{\mathtt{\texttt{class}\ \exptype{C}{\ol{X} \triangleleft \ol{N}}\triangleleft
  N\{ \overline{C} \ \overline{f}; \ K \ \overline{M} \} \ \mathtt{OK}
  \quad \quad m \notin \ol{M}} }{
    %{\exptype{}{\ol{Y} \triangleleft \ol{P}}\ T \ m(\ol{T}\ \ol{x}) \{ \texttt{return} \ e_0; \} \ \texttt{OK IN}\ \exptype{C}{\ol{X} \triangleleft \ol{N}}}
    \textit{mtype}(m, \exptype{C}{\ol{T}}) = \textit{mtype}(m, [\ol{T}/\ol{X}]N)
    }$ & & MT-SUPER \\
\end{tabularx}\\[1em]
\textbf{Valid method overriding:}\\[1em]
\begin{tabularx}{\textwidth}{c}
  $\ddfrac{
    \textit{mtype}(m, N) = \exptype{}{\ol{Y} \triangleleft \ol{Q}} \ol{U} \to U \ 
    \text{implies}\ \ol{P}, \ol{T} = [\ol{Y}/\ol{Z}](\ol{Q},\ol{U}) \ 
   \text{and}\ \ol{Y} <: \ol{P} \vdash T_0 <: [\ol{Y}/\ol{Z}]U_0 
  } {
  %{\exptype{}{\ol{Y} \triangleleft \ol{P}}\ T \ m(\ol{T}\ \ol{x}) \{ \texttt{return} \ e_0; \} \ \texttt{OK IN}\ \exptype{C}{\ol{X} \triangleleft \ol{N}}}
  \textit{override}(m, N, \exptype{}{\ol{Y} \triangleleft \ol{P}} \ol{T} \to T_0)
  }$ 
\end{tabularx}\\[1em]
  \textbf{Method body lookup:} \\[1em]
\begin{tabularx}{\textwidth}{cXr}
  $\ddfrac{\begin{array}{c}
  \texttt{class}\ \exptype{C}{\ol{X} \triangleleft \ol{N}}\triangleleft
             N\{ \overline{S} \ \overline{f}; \ K \ \overline{M} \} \\
  \mathtt{\exptype{}{\ol{Y} \triangleleft \ol{P}}\ T\ \texttt{m}(\ol{T}\ \ol{\mathtt{x}}) \{\texttt{return}\ \mathtt{e}_0;\}}
  \in \ol{M}
  \end{array}} {
  %{\exptype{}{\ol{Y} \triangleleft \ol{P}}\ T \ m(\ol{T}\ \ol{x}) \{ \texttt{return} \ e_0; \} \ \texttt{OK IN}\ \exptype{C}{\ol{X} \triangleleft \ol{N}}}
  \textit{mbody}(m, \exptype{C}{\ol{Z}}) = [\ol{Z} / \ol{X}](\exptype{}{\ol{Y}} \ol{T} \to T)
  }$ & & MB-CLASS \\
  & & \\
  $\ddfrac{
  \mathtt{\texttt{class}\ \exptype{C}{\ol{X} \triangleleft \ol{N}}\triangleleft
             \ol{N}\ \{ \overline{S} \ \overline{f}; \ K \ \overline{M} \} \quad \quad m \notin \ol{M}}
  } {
  %{\exptype{}{\ol{Y} \triangleleft \ol{P}}\ T \ m(\ol{T}\ \ol{x}) \{ \texttt{return} \ e_0; \} \ \texttt{OK IN}\ \exptype{C}{\ol{X} \triangleleft \ol{N}}}
  \mathtt{\textit{mbody}(m, \exptype{C}{\ol{T}}) = \textit{mbody}(m, [\ol{T}/\ol{X}]N)}
  }$ & & MB-SUPER \\
\end{tabularx}
\end{small}
\end{minipage}
}

\medskip




%MT-CLASS: - This rule is not used by us
%\begin{align*}
%\ddfrac{\begin{array}{c}
%\texttt{class} \ \exptype{C}{\ol{X} \triangleleft \ol{N}} \ \{ \ol{S} \ \ol{f}; \ K \ol{M} \}\\
%\exptype{}{\ol{Y} \triangleleft \ol{P}} U \ m(\ol{U} \ \ol{x})\{  \texttt{return} \ e; \} \in \ol{M}
%\end{array}}
%{\mathit{mtype}(m, \exptype{C}{\ol{Z}}) = [\ol{T}/\ol{X}](\exptype{}{\ol{Y} \triangleleft \ol{P}} \ol{U} \to U)}
%\end{align*}

%GT-METHOD:
%\begin{align*}
%\ddfrac{\begin{array}{c}
%\triangle \vdash \ol{X} <: \ol{N}, \ol{Y} <: \ol{P} \quad \quad 
%\triangle \vdash \ol{T}, T, \ol{P} \ \texttt{ok} \\
%\triangle ; \ol{x}:\ol{T}, this : \exptype{C}{\ol{X}} \vdash e_0 : S \quad \quad
%\triangle \vdash S <: T \\
%\texttt{class}\ \exptype{C}{\ol{X} \triangleleft \ol{N}} \triangleleft N \{ \ldots \} \quad \quad
%\textit{override}(m, N, \exptype{}{\ol{Y} \triangleleft \ol{P}} \ol{T} \to T)
%\end{array}}
%{\exptype{}{\ol{Y} \triangleleft \ol{P}}\ T \ m(\ol{T}\ \ol{x}) \{ \texttt{return} \ e_0; \} \ \texttt{OK IN}\ \exptype{C}{\ol{X} \triangleleft \ol{N}}}
%\end{align*}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "TIforGFJ"
%%% End:

%we have to show completeness and Soundness for the new type rules
%we only have to show this for the changed rules (for preservation), because they use induction on the derivations
% what is the consequence on method overloading 
% the Proof of Theorem 3.4.1 works also with the mtype overload rule

%\begin{theoremAndi}
%Subject reduction: if $\environmentvdash e : T$ and $e \to e'$,
%then $\environmentvdash e':T'$ for some $T'$ such that $\triangle \vdash T' <: T$.
%\end{theoremAndi}
