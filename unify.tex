\label{sec:unify}
This chapter describes the \textbf{GenericUnify} algorithm
which is used to find type solutions for the constraints generated by \textbf{FGJType}.

\begin{description}
\item[input] A set of type constraints $Cons_{in}$ %and a set of subtype relationships $S_\leq$
\item[output] A set of type unifiers $Uni$
or fail $Uni = \emptyset$.
%The unifiers have the form of $Uni = \{ \sigma_1, \ldots , \sigma_n \}$.
\end{description}

\textit{Hints:}
\begin{itemize}
\item The $\lessdot^*$ used in this chapter means,
that $a \lessdot^* b$ can either be a single constraint $a \lessdot b$ or a transitive series of constraints
$a \lessdot c, \ldots, m \lessdot n, n \lessdot b$.
\item $[a/b]T$ means replacing all type variables $b$ with $a$ in the type $T$.
\item The function $\textbf{fresh}(i)$ returns an array of $i$ fresh type variables.
\end{itemize}
\begin{definition}[Isolated type variable] \label{def:isolated-type-variable}
    \textrm
  An isolated type variable does only occur in constraints together with another isolated type variable.
  \end{definition}
  
  \begin{definition}[Solved form]\label{def:solved-form}
    \textrm
    A set of constraints $Eq$ has reached solved form if it contains only the following kind of constraints:
    \begin{enumerate}
      \item $a \lessdot b$, with $a$ and $b$ both isolated type variables
      \item $a \lessdot \exptype{C}{\ol{X}}$, with $a \notin \ol{X}$ %, with $a$ not appearing in any other constraints of type 2 or 3.
      \item $a \doteq \exptype{C}{\ol{X}}$, with $a \notin \ol{X}$
    \end{enumerate}
  \end{definition}  

The unify algorithm first has to build the cartesian product of all the \textbf{OrConstraint}s and the remaining normal constraints:
\begin{align*}
\Omega &= \text{All }\mathbf{OrConstraints} \text{ in } {Cons}_{in}\\
C &= {Cons}_{in} \setminus \Omega \\
Eq_{set} &= \Omega_1 \times \ldots \times \Omega_n \times C \quad \text{for all }\Omega_i \in \Omega
\end{align*}

%The algorithm starts by setting $Eq_{set} = \set{ Cons_{in} }$.
Afterwards the following steps are repeatedly executed on $Eq_{set}$ until the algorithm terminates:
%For every $Eq \in Eq_{set}$ the following steps are applied.
%The resulting unifiers $\sigma$ from each $Eq$ merged together form the result of the \textbf{Unify} algorithm.

%$\textbf{SubUnify} :: [Constraint] \to [Unifier]$
\begin{enumerate}
\item Repeated application of the rules depicted in figure \ref{fig:fgjreduce-rules} and \ref{fig:fgjerase-rules},
starting with the \texttt{equals} rule.
The end configuration of $Eq$ is reached if for each element no rule is applicable.
\item
\begin{align*}
Eq_1 =& \text{Subset of pairs where both type terms are type variables}\\
Eq_2 =& Eq / Eq_1 \\
Eq_{set}
    = 
    & \times\, 
    (\displaystyle{\bigotimes_{(\exptype{C}{\overline{T}} \lessdot a) \in Eq_2}}\!\!
    \set{a \doteq [\ol{T}/\ol{X}]N \ | \ \exptype{C}{\overline{X}} <: N })\\
    & (\displaystyle{\bigotimes_{\set{a \lessdot \exptype{C}{\overline{T}}} \in Eq_2, \set{ a \lessdot^* b} \in Eq_1}}\!\!
    \set{ b \lessdot \exptype{C}{\ol{T}}} \cup \set{b \doteq [\ol{T}/\ol{X}]N \ | \ \exptype{C}{\overline{X}} <: N })\\
    & \times\, \set{[a \doteq N \ | \  (a \doteq N) \in Eq_2]} \\
    & \times\, \set{[a \lessdot N \ | \  (a \lessdot N) \in Eq_2]} \times Eq_1 \\
    & \times\, \set{[N \doteq a \ | \  (N \doteq a) \in Eq_2]} \times Eq_1 \\
    & \times\, \set{[N \doteq N \ | \  (N \doteq N \in Eq_2]} \\
    & \times\, \set{[N \lessdot N \ | \  (N \lessdot N) \in Eq_2]} \times Eq_1 \\
\end{align*}
\item \label{subst-step}  Application of the following \emph{subst} rule for every $Eq'' \in Eq_{set}$
    %\begin{enumerate}
    %\item Apply the following subst\_eq rule
    
      $$\begin{array}[c]{lll}
        (\mathrm{subst}) &
        \begin{array}[c]{l}
          Eq'' \cup \set{a \doteq N}\\
          \hline
          Eq''[a \mapsto N] \cup \set{a \doteq N}
        \end{array}
        & a \textrm{ occurs in } Eq'' \textrm{ but not in } N
      \end{array}$$
      
      for each $a \doteq N$ in each element of $Eq' \in Eq'_{set}$.

\item 
    \begin{enumerate}
    \item Foreach $Eq \in Eq_{set}$ which has changed in the last step
      start again with the first step.
    \item Build the union $Eq_{set}$ of all results of (a) and all $Eq' \in
      Eq'_{set}$ which has not changed in the last step.
    \end{enumerate}
\item
\begin{enumerate}
  \item Filter all constraint sets which are in solved
  form:\\
$Eq_{solved} = \set{ Eq \ | \ Eq \in Eq_{set}, Eq \ \text{is in solved form}}$
\item We apply the following rule to every constraint set in $Eq_{solved}$:
\begin{align*}
\ddfrac{
  Eq \cup \set{ a \lessdot b } %There are only Type variables left at this point
}{
  [a/b]Eq \cup \set{ a \doteq b }
}
\end{align*}
\item Finally we generate the unifiers:
\begin{align*}
    \emph{Uni} = &
   \set{\sigma \ | \ Eq \in Eq_{solved},\ \sigma = \set{a \mapsto T \ | \ (a \doteq \texttt{T}) \in Eq} } \ \cup \\
   & \set{\sigma \ | \ Eq \in Eq_{solved},\ \sigma = \set{a \mapsto (X \triangleleft T) \ | \ (a \lessdot \texttt{T}) \in Eq} }
\end{align*}
\end{enumerate}
\end{enumerate}

\begin{figure}
\begin{center}
    \leavevmode
    \fbox{
    \begin{tabular}[t]{ll}
      (match)
      & $
      \begin{array}[c]{ll}
      \begin{array}[c]{l}
         Eq \cup \, \set{a \lessdot
         \exptype{C}{\ol{X}},
         a \lessdot
          \exptype{D}{\ol{Y}}} \\ 
        \hline
        \vspace*{-0.4cm}\\
        Eq \cup \set{a \lessdot \exptype{C}{\ol{X}}
        , \exptype{C}{\ol{X}} \lessdot \exptype{D}{\ol{Y}}}
      %Eq \cup \set{\theta_1 \doteq \lambda'_1 \ldo \theta_n \doteq \lambda'_n}
      \end{array}
      & \exptype{C}{\ol{Z}} <: \exptype{D}{\ol{N}} 
      \end{array}
      $
    \\\\
    (adopt)
    & $
    \begin{array}[c]{ll}
    \begin{array}[c]{l}
       Eq \cup \, \set{a \lessdot
       \exptype{C}{\ol{X}},
       b \lessdot^* a, b \lessdot \exptype{D}{\ol{Y}}} \\ 
      \hline
      \vspace*{-0.4cm}\\
      Eq \cup \set{
        a \lessdot
       \exptype{C}{\ol{X}},
       b \lessdot^* a
      , b \lessdot  \exptype{D}{\ol{Y}}
      , b \lessdot \exptype{C}{\ol{X}}
       }
    %Eq \cup \set{\theta_1 \doteq \lambda'_1 \ldo \theta_n \doteq \lambda'_n}
    \end{array}
    \end{array}
    $
  \\\\
      (adapt)
      & $
      \begin{array}[c]{ll}
      \begin{array}[c]{l}
         Eq \cup \, \set{\exptype{C}{\ol{A}} \lessdot
          \exptype{D}{\ol{B}}} \\ 
        \hline
        \vspace*{-0.4cm}\\
        Eq \cup \set{\exptype{D}{[ \ol{A} / \ol{X} ]\ol{Y}}
        \doteq \exptype{D}{\ol{B}}}
      %Eq \cup \set{\theta_1 \doteq \lambda'_1 \ldo \theta_n \doteq \lambda'_n}
      \end{array}
      & \exptype{C}{\ol{X}} <:\ \exptype{D}{\ol{Y}}
      \end{array}
      $
    \\\\
(reduce) & $
\begin{array}[c]{l}
  Eq \cup \set{\exptype{D}{\ol{A}} \doteq
    \exptype{D}{\ol{B}}}\\
  \hline
  Eq \cup \set{\ol{A} \doteq \ol{B}}
\end{array}
      $ \\\\
(equals) & $
\begin{array}[c]{l}
  Eq \cup \set{a \lessdot
    b, b \lessdot c, \ldots, m \lessdot n, n \lessdot a}\\
  \hline
  Eq \cup \set{a \doteq b, a \doteq c, \ldots}
\end{array}
      $ \\\\
    \end{tabular}}
  \end{center}
\caption{Reduce and adapt rules}\label{fig:fgjreduce-rules}
\end{figure}


\begin{figure}
\begin{align*}
&\begin{tabular}[t]{ll}
      (erase1)  & $ 
      \begin{array}[c]{ll}
        \begin{array}[c]{l}
          Eq \cup \set{C \lessdot D}\\
          \hline
          Eq
        \end{array}
        & C <: D
      \end{array}$\\
          \end{tabular}\\
&\begin{tabular}[t]{ll}
      (erase2)  & $ 
      \begin{array}[c]{ll}
        \begin{array}[c]{l}
          Eq \cup \set{a \doteq a}\\
          \hline
          Eq
        \end{array}
      \end{array}$\\
          \end{tabular}\\
    &      \begin{tabular}[t]{ll}
       (swap) & $
            \begin{array}[c]{ll}
              \begin{array}[c]{l}
                Eq \cup \set{C \doteq a}\\
                \hline
                Eq \cup \set{a \doteq C}
              \end{array}
            \end{array}$
          \end{tabular}
\end{align*}
\caption{Erase and swap rules}\label{fig:fgjerase-rules}
\end{figure}