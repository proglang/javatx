%\clearpage
\section{Constraint Solving}
\label{sec:unify}

This section describes the \unify{} algorithm
which is used to find solutions for the constraints generated by \fjtype{}.

It first attempts to transforms a constraint set into solved form and
reads off a solution in the form of a substitution.

\begin{definition}[Solved form]\label{def:solved-form}
  A set $C$ of constraints is in solved form if it only contains
  constraints of  the following form:
  \begin{enumerate}
  \item $\tv{a} \lessdot \tv{b}$ %, with $a$ and $b$ both isolated type variables
  \item $\tv{a} \doteq \tv{b}$,
  \item\label{item:1} $\tv{a} \lessdot \exptype{C}{\ol{\itype{T}}}$, 
  \item\label{item:2} $\tv{a} \doteq \exptype{C}{\ol{\itype{T}}}$, with $\tv{a} \notin \ol{\itype{T}}$.
  \end{enumerate}
  In case~\ref{item:1} and~\ref{item:2} the type variable $\tv{a}$ does not appear on the left of another constraint of the
  form~\ref{item:1} or~\ref{item:2}.
\end{definition}  

For brevity, we write $\tv{a}_0 \lessdot^* \tv{a}_n$ for a non-empty chain of subtyping constraints between type variables $\tv{a}_0 \lessdot
\tv{a}_1, \tv{a}_1 \lessdot \tv{a}_2, \dots, \tv{a}_{n-1} \lessdot \tv{a}_n$ where $n>0$.

\subsection{{Algorithm $\unify{} (C, \Delta)$}}

%\begin{description}
%  \item[Input] A set of constraints $\consSet_{in}$ and a type environment $\Delta$.
%  \item[Output] %TODO
%\end{description}

The input of the algorithm is a set of constraints $\consSet$ and a
type environment $\Delta$. The type environment binds the generic type
variables $\ol{X}$ to their upper bounds. It is used in invocations of
the subtyping judgment.

The treatment of the generic class variables $\ol{X} \extends \ol{N}$
deserves some explanation. The algorithm must not substitute
for these variables. Instead it treats them like parameterless
abstract classes $\exptype{X_i}{}$ which are subtypes of their
respective $\mv{N}_i$ (where the variable name $\mv{X}_i$ is now
treated like a class name). Example~\ref{item:3} illustrates this
approach.  

The first step of the algorithm eliminates or-constraints from constraint set $\consSet$. To do so,
we consider all combinations of selecting simple constraints from
or-constraints in $\consSet$. In general, we have that $\consSet =
\set{\overline{\simpleCons}, \orCons_1, \dots, \orCons_n}$ and we
execute the remaining steps for all $\consSet' = \set{\overline{\simpleCons}}
\cup \set{\overline{\simpleCons}_1} \cup \dots \cup
\set{\overline{\simpleCons}_n}$ where $\overline{\simpleCons}_i \in
\orCons_i$. 



\textbf{Step 1.} We apply the rules in Figures~\ref{fig:fgjreduce-rules}
and~\ref{fig:fgjerase-rules} exhaustively to $C'$.

\textbf{Step 2.} At this point, all
constraints $ \simpleCons \in C'$ are either in solved form or one of the following
cases applies:
\begin{enumerate}
\item $\set{\exptype{C}{\il{T}} \lessdot \exptype{D}{\il{U}}}
  \subseteq C'$ where $\forall\ol{X},\ol{N}\colon \Delta \not\vdash \exptype{C}{\ol{X}} <:
  \exptype{D}{\ol{N}}$ (roughly, $\mv C$ cannot be a subtype of $\mv D$) --- in this case $C'$ has no solution;
\item $\set{\tv{a} \lessdot \exptype{C}{\il{T}}, \tv{a} \lessdot
    \exptype{D}{\il{V}}} \subseteq C'$ where
  $\forall\ol{X},\ol{N}\colon \Delta \not\vdash \exptype{C}{\ol{X}} <:
  \exptype{D}{\ol{N}} $ and $\forall\ol{X},\ol{N}\colon \Delta \not\vdash \exptype{D}{\ol{X}} <:
  \exptype{C}{\ol{N}}$ (roughly, $\mv C$ and $\mv D$ are not
  subtype-related) --- in this case $C'$ has no solution; or
\item $\set{\exptype{C}{\il{T}} \lessdot \tv{b}} \subseteq C'$.
\end{enumerate}
The last case is a lower bound constraint which is embraced by Scala,
but which is not legal in FGJ (nor in Java). As we insist on inferring
a type, we have to find a concrete instance for
$\exptype{C}{\il{T}}$. To do so, we generate an or-constraint from
each lower bound constraint and its corresponding upper bound constraint (using upper bound \mv{Object} if no such constraint exists) as follows:
\begin{align*}
  \expandLB (\exptype{C}{\il{T}} \lessdot \tv{b}, \tv{b} \lessdot \exptype{D}{\il{U}})
  & = \set{ \set{ \tv{b} \doteq [\overline{\itype{T}}/\ol{X}]\type{N} } \mid
    \Delta \vdash \exptype{C}{\overline{\type{X}}} <: \type{N},
    \Delta \vdash \type{N} <:  \exptype{D}{\overline{P}}}
  \\ \text{where }&\ol{P}\text{ is determined by }\Delta \vdash \exptype{C}{\overline{\type{X}}} <: \exptype{D}{\ol{P}} \text{ and
  } [\overline{\itype{T}}/\ol{X}]\ol{P} = \il{U}
\end{align*}
This constraint replaces the lower and upper bound constraint from which it was generated.

A lower bound may also be implied by a constraint set with constraints of the form
$C_{ab} = \tv{a} \lessdot \exptype{C}{\il{T}}, \tv{a} \lessdot^* \tv{b}$.
%In this case, $\exptype{C}{\il{T}} $ can serve as a lower bound for $\tv{b}$.
In this case $\exptype{C}{\il{T}}$ must either be a upper or lower bound for $\tv{b}$.
We implement it by $\expandLB$, which adds a lower bound constraint for $\tv{b}$
and also adding a upper bound to $\tv{b}$. While $C_{ab}$ remains in the constraint
set:
$\expandLB (\exptype{C}{\il{T}} \lessdot \tv{b}, \tv{b} \lessdot \exptype{D}{\il{U}})\ \cup \ 
\set{b \lessdot \exptype{C}{\il{T}}}$

Now we are in a similar situation as before. Our current constraint set $C'$ is a mix of simple constraints and or-constraints and, again, we
consider all (simple) constraint sets $C''$ that arise as combinations of selecting simple constraints from $C'$.

\textbf{Step 3.} We apply the rule (subst) exhaustively to $C''$:
\begin{gather*}
  \begin{array}[c]{lll}
    \text{(subst)} &
                     \begin{array}[c]{l}
                       C \cup \set{\tv{a} \doteq \itype{T}}\\
                       \hline
                       [\itype{T}/\tv{a}]C \cup \set{\tv{a} \doteq \itype{T}}
                     \end{array}
                   & \tv{a} \text{ occurs in } C \text{ but not in } \itype{T}
  \end{array}
\end{gather*}
We fail if we find any $\tv{a} \doteq \itype{T}$ such that $\tv{a}$ occurs in $\itype{T}$.

\textbf{Step 4.} If $C''$ has changed from applying (subst), we continue with $C''$ from step~1.

\textbf{Step 5.} Otherwise, $C''$ is in solved form and it remains to eliminate subtyping constraints between variables by exhaustive application of rule
(sub-elim) and (erase) (see Figure~\ref{fig:fgjerase-rules}). Applying this rule does not affect the solve form property.
\begin{gather*}
  \begin{array}[c]{lll}
    \text{(sub-elim)} &
                     \begin{array}[c]{l}
                       C \cup \set{\tv{a} \lessdot \tv{b}}\\
                       \hline
                       [\tv{a}/\tv{b}]C \cup \set{\tv{b} \doteq \tv{a}}
                     \end{array}
  \end{array}
\end{gather*}
\textbf{Step 6.} We finish by generating a solving substitution from the remaining $\doteq$-constraints
and generic variable declarations from the remaining $\lessdot$-constraints. Let $C'' = C_{\doteq} \cup C_{\lessdot}$ such that $C_{\doteq}$
contains only $\doteq$-constraints and $C_{\lessdot}$ contains only $\lessdot$-constraints. Now $C_{\lessdot} = \set{ \il{\tv{a}} \lessdot
  \il{N}}$ and choose some fresh generic variables $\ol{Y}$ of the same length as $\il{\tv{a}}$. We can read off the substitution $\sigma$
from $C_{\doteq}$ where we need to substitute the generic variables for the type variables. We obtain the generic variable declarations
directly from $C_{\lessdot}$ using the same generic variable substitution. We need not apply $\sigma$ here because
we applied (subst) exhaustively in Step~3.
\begin{align*}
  \sigma &=
           \set{\tv{b} \mapsto [\ol{Y}/\ol{\tv{a}}]\itype{T} \mid
           (\tv{b} \doteq \itype{T}) \in C_{\doteq}}
           \cup 
           \set{\il{\tv{a}} \mapsto \ol{Y}}
           \cup 
           \set{{\tv{b}} \mapsto \mv{X} \mid (\tv{b} \lessdot \mv{X}) \in C_{\lessdot}}, \\
  \unifyGenerics{} & =
                     \set{\type{Y} \triangleleft [\ol{Y}/\ol{\tv{a}}]\itype{N} \mid (\tv{a} \lessdot \itype{N}) \in C_{\lessdot}}
\end{align*}
We return the pair $(\sigma, \gamma)$.

\if0
\todo[inline]{PT: checkpoint}

\begin{enumerate}
\item Repeated application of the rules depicted in figure \ref{fig:fgjreduce-rules} and \ref{fig:fgjerase-rules},
starting with the \texttt{equals} rule.
The end configuration of $Eq$ is reached if for each element no rule is applicable.
\item
\begin{align*}
Eq_1 =& \text{Subset of pairs where both type terms are type variables}\\
Eq_2 =& Eq / Eq_1 \\
Eq_{set}
    = 
    & \times\, 
    (\displaystyle{\bigotimes_{(\exptype{C}{\overline{\itype{T}}} \lessdot   \tv{a}) \in Eq_2}}\!\!
    \set{\tv{a} \doteq [\overline{\itype{T}}/\ol{X}]\type{N} \ | \ \exptype{C}{\overline{\type{X}}} <: \type{N} })\\
    & (\displaystyle{\bigotimes_{\set{a \lessdot \exptype{C}{\overline{\itype{T}}}} \in Eq_2, \set{ \tv{a} \lessdot^* \tv{b}} \in Eq_1}}\!\!
    \set{ b \lessdot \exptype{C}{\ol{\itype{T}}}} \cup \set{b \doteq [\ol{\itype{T}}/\ol{X}]\type{N} \ | \ \exptype{C}{\overline{X}} <: \type{N} })\\
    & \times\, \set{[\tv{a} \doteq \type{N} \ | \  (\tv{a} \doteq \type{N}) \in Eq_2]} \\
    & \times\, \set{[\tv{a} \lessdot \type{N} \ | \  (\tv{a} \lessdot \type{N}) \in Eq_2]}  \\
    & \times\, \set{[\type{N} \doteq \tv{a} \ | \  (\type{N} \doteq \tv{a}) \in Eq_2]}  \\
    & \times\, \set{[\type{N} \doteq \type{N} \ | \  (\type{N} \doteq \type{N} \in Eq_2]} \\
    & \times\, \set{[\type{N} \lessdot \type{N} \ | \  (\type{N} \lessdot \type{N}) \in Eq_2]} \times Eq_1 \\
\end{align*}
\item \label{subst-step}  Application of the following \emph{subst} rule for every $Eq'' \in Eq_{set}$
    %\begin{enumerate}
    %\item Apply the following subst\_eq rule
      $$\begin{array}[c]{lll}
        (\mathrm{subst}) &
        \begin{array}[c]{l}
          Eq'' \cup \set{\tv{a} \doteq \itype{T}}\\
          \hline
          [\itype{T}/\tv{a}]Eq'' \cup \set{a \doteq \itype{T}}
        \end{array}
        & \tv{a} \textrm{ occurs in } Eq'' \textrm{ but not in } \itype{T}
      \end{array}$$
      
      for each $\tv{a} \doteq \itype{T}$, where $\tv{a}$ has not been substituted in a previous round.

\item 
    \begin{enumerate}
    \item Foreach $Eq \in Eq_{set}$ which has changed in the last step
      start again with the first step.
    \item Build the union $Eq_{set}$ of all results of (a) and all $Eq' \in
      Eq'_{set}$ which has not changed in the last step.
    \end{enumerate}
\item
\begin{enumerate}
  \item Filter all constraint sets which are in solved
  form:\\
$Eq_{solved} = \set{ Eq \ | \ Eq \in Eq_{set}, Eq \ \text{is in solved form}}$
\item We apply the following rule to every constraint set in $Eq_{solved}$:
\begin{align*}
\ddfrac{
  Eq \cup \set{ \tv{a} \lessdot \tv{b} } %There are only Type variables left at this point
}{
  [\tv{a}/\tv{b}]Eq \cup \set{ \tv{a} \doteq \tv{a}, \tv{b} \doteq \tv{a} }
}
\end{align*}
%TODO: Do not return unifiers. return the simplified constraint set:
\item Finally we generate the unifiers and generic variable declarations:
\begin{align*}
  \set{ 
    (\sigma = &
    \set{\tv{a} \mapsto \type{N} \ | \ (\tv{a} \doteq \type{N}) \in Eq} \ \cup \  \set{\tv{b} \mapsto \type{A} \ | \ (\tv{b} \doteq \tv{a}) \in Eq} \ \cup \ 
    \set{\tv{a} \mapsto \type{A} \ | \ (\tv{a} \lessdot \type{N}) \in Eq }, \\
   \unifyGenerics{} = &
  \set{\type{A} \triangleleft \type{N} \ | \ (\tv{a} \lessdot \type{N}) \in Eq}) 
   \ | \ Eq \in Eq_{set}  }
\end{align*}
The \unify{} algorithm returns all possible solutions.
Each solution consists out of a pair of unifiers $\sigma$ and generic bounds \unifyGenerics{}.
\end{enumerate}
\end{enumerate}
\fi

\begin{figure}
\begin{center}
    \leavevmode
    \fbox{
    \begin{tabular}[t]{l@{~}l}
      (match)
      & $
      \begin{array}[c]{@{}ll}
      \begin{array}[c]{l}
         C \cup \, \set{\tv{a} \lessdot
         \exptype{C}{\il{T}},
         \tv{a} \lessdot
          \exptype{D}{\il{V}}} \\ 
        \hline
        \vspace*{-0.4cm}\\
        C \cup \set{\tv{a} \lessdot \exptype{C}{\il{T}}
        , \exptype{C}{\il{T}} \lessdot \exptype{D}{\il{V}}}
      %C \cup \set{\theta_1 \doteq \lambda'_1 \ldo \theta_n \doteq \lambda'_n}
      \end{array}
      & %\exists\ol{X},\ol{N}.\ 
        \Delta \vdash \exptype{C}{\ol{X}} <: \exptype{D}{\ol{N}} 
      \end{array}
      $
    \\\\
    (adopt)
    & $
    \begin{array}[c]{@{}ll}
    \begin{array}[c]{l}
       C \cup \, \set{\tv{a} \lessdot
       \exptype{C}{\il{T}},
       \tv{b} \lessdot^* \tv{a}, \tv{b} \lessdot \exptype{D}{\il{U}}} \\ 
      \hline
      \vspace*{-0.4cm}\\
      C \cup \set{
        \tv{a} \lessdot
       \exptype{C}{\il{T}},
       \tv{b} \lessdot^* \tv{a}
      , \tv{b} \lessdot  \exptype{D}{\il{U}}
      , \tv{b} \lessdot \exptype{C}{\il{T}}
       }
    %C \cup \set{\theta_1 \doteq \lambda'_1 \ldo \theta_n \doteq \lambda'_n}
    \end{array}
    \end{array}
    $
  \\\\
      (adapt)
      & $
      \begin{array}[c]{@{}ll}
      \begin{array}[c]{l}
         C \cup \, \set{\exptype{C}{\il{T}} \lessdot
          \exptype{D}{\il{U}}} \\ 
        \hline
        \vspace*{-0.4cm}\\
        C \cup \set{\exptype{D}{[ \il{T} / \ol{X} ]\ol{N}}
        \doteq \exptype{D}{\il{U}}}
      %C \cup \set{\theta_1 \doteq \lambda'_1 \ldo \theta_n \doteq \lambda'_n}
      \end{array}
        & %\exists\ol{X},\ol{N}.\
          \Delta \vdash \exptype{C}{\ol{X}} <: \exptype{D}{\ol{N}} 
        % \exptype{C}{\ol{X}} <:\ \exptype{D}{\ol{Y}}
      \end{array}
      $
    \\\\
(reduce) & $
\begin{array}[c]{l}
  C \cup \set{\exptype{D}{\il{T}} \doteq
    \exptype{D}{\il{U}}}\\
  \hline
  C \cup \set{\il{T} \doteq \il{U}}
\end{array}
      $ \\\\
(equals) & $
\begin{array}[c]{l}
  C \cup \set{\tv{a}_1 \lessdot
  \tv{a}_2, \tv{a}_2 \lessdot \tv{a}_3, \dots, \tv{a}_n \lessdot \tv{a}_1}\\
  \hline
  C \cup \set{\tv{a}_1 \doteq \tv{a}_2, \tv{a}_2 \doteq \tv{a}_3, \dots}
\end{array} \quad n>0
      $ \\\\
    \end{tabular}}
  \end{center}
\caption{Reduce and adapt rules}\label{fig:fgjreduce-rules}
\end{figure}


\begin{figure}
\begin{center}
\fbox{\begin{tabular}[t]{ll}
  %     (erase1)  & $ 
  %     \begin{array}[c]{@{}ll}
  %       \begin{array}[c]{l}
  %         C \cup \set{\exptype{C}{\il{T}} \lessdot \exptype{D}{\il{U}}}\\
  %         \hline
  %         C
  %       \end{array}
  %       & \exptype{C}{\il{T}} <: \exptype{D}{\il{U}}
  %     \end{array}$
  % \\
      (erase)  & $ 
      \begin{array}[c]{@{}ll}
        \begin{array}[c]{l}
          C \cup \set{\tv{a} \doteq \tv{a}}\\
          \hline
          C
        \end{array}
      \end{array}$
  \\
       (swap) & $
            \begin{array}[c]{@{}ll}
              \begin{array}[c]{l}
                C \cup \set{\itype{N} \doteq \tv{a}}\\
                \hline
                C \cup \set{\tv{a} \doteq \itype{N}}
              \end{array}
            \end{array}$
          \end{tabular}}
        \end{center}
\caption{Erase and swap rules}\label{fig:fgjerase-rules}
\end{figure}

\begin{example}\label{item:3}
  To illustrate our treatment of generic variables, we consider a
  typical case involving the (adapt) rule from
  Figure~\ref{fig:fgjreduce-rules}.

  Consider $C = \set{ \mv{X} \lessdot \exptype{D}{\il{U}} }$ and let $
  \mv{X} \sub \exptype{C}{\ol{T}} \in \Delta$ be the bound for
  $\mv{X}$.

  The side condition of the rule (adapt) asks for some $\ol{N}$ such
  that
  $\Delta \vdash \mv{X} \sub \exptype{D}{\ol{N}}$, i.e., ``is there a
  way that $\mv{X}$ can be a subtype of $\mv{D}$?''

  By inversion of subtyping and transitivity, this judgment holds if
  $\Delta \vdash \exptype{C}{\ol{T}} \sub \exptype{D}{\ol{N}}$ holds.

  Hence, applying (adapt) to $C$ yields $\set{ \exptype{D}{\ol{N}} \doteq
    \exptype{D}{\il{U}} }$. The substitution in the rule is empty
  because $\mv{X}$ is considered a parameterless type.

  The remaining rules work similarly. In particular, different
  variables $\mv{X} \ne \mv{Y}$ give rise to different (abstract)
  classes. For example, the (reduce) rule removes the constraint $\mv{X} \doteq
  \mv{X}$, but it does \emph{not} apply to
  $\mv{X} \doteq \mv{Y}$. Rather, an equation like this renders the
  constraint set unsolvable.
\end{example}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "TIforGFJ"
%%% End:
