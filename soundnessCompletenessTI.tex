\section{Soundness and completeness of type inference}
\label{sec:soundn-compl-type}

After showing that type unification is sound and complete, we
can now show that type inference \textbf{FJTypeInference} also is
sound and complete.
\begin{theorem}[Soundness] For all $\mv{\Pi}$, $\mv L$, $\mv{\Pi'}$, 
  $\fjtypeinference(\mv{\Pi},\texttt{L}) = \mv{\Pi}'$ implies $\mv{\Pi} \vdash \texttt{L} : \mv{\Pi}'$.
\end{theorem}
\begin{theorem}[Completeness]  For all $\mv{\Pi}$, $\mv L$, $\mv{\Pi'}$,
  $\mv{\Pi} \vdash \texttt{L} : \mv{\Pi}'$ implies $\fjtypeinference(\mv{\Pi},\texttt{L}) = \mv{\Pi}''$ with $\mv{\Pi} \vdash \texttt{L} : \mv{\Pi}''$.
\end{theorem}
\textbf{Proof:}
Every type variable $\tv{a}$ in $\mv{\Pi}$ is replaced by $\sigma(\tv{a})$.
We show soundness and completeness by a case analysis over the type rules given by \TFGJ{}.
We can show that the constraints generated by \fjtype{} mirror the \TFGJ{} type rules.
The \unify{} algorithm is sound and complete (see theorem \ref{theo:unifySoundness} and \ref{theo:unifyCompleteness})
and therefore the $\fjtypeinference$ algorithm is sound and complete.

Now we show that the constraints generated by {\fjtype{}}
represent the type rules given in chapter \ref{chapter:type-rules}.
%For most of the expression typing rules this is trivial.
%Such as \texttt{GT-VAR}, \texttt{GT-FIELD} and \texttt{GT-NEW}.

%The \unify{} algorithm is complete, so every correct type is included in the solution set.
%We only have to choose the right type out of those solutions.
%When compiling multiple classes the problem arises,
%that only one of the type solutions calculated by \unify{} is correct
%in respective to the other classes that will be compiled afterwards.

%All types that are possible under the FGJ typing rules, plus our additional assumptions,
%also comply with the generated constraints.

We match every generated constraint with the respective type rule to show soundness and completeness of our \textbf{FJTYPE} algorithm.
%This shows that none of the generated constraints remove a type which otherwise would be possible under the \TFGJ typing rules.
%The constraints are generated on expression statements.

The constraint generation starts with generating the method assumptions for the current class $\overline{\methodAssumption}$.
The constraints in $\consSet_o$ ensure valid overriding.
The constraints in $\consSet_m$ ensure well-formedness of the return and parameter types of the method.

%\if0
To ensure well-formedness of types we have to ensure that every type variable generated by \fjtype{} has a bound assigned.
%The biggest part of the type rules can be expressed with the constraints generated by the \fjtype{} function.
The \texttt{WF-CLASS} rule checks types for well-formedness in a recursive fashion.
The types $\ol{T}$ used to instantiate the class $exptype{C}{\ol{X}}$ need to follow the bounds given by the class declaration $\ol{T} <: [\ol{T}/\ol{X}]\ol{N}$, but also have to be well-formed themselfes $\ol{N}\ \texttt{ok}$.
\begin{lemma}[Well-formedness]\label{lemma:well-formedness}
  Given method assumptions $\Pi$ and a class \normalfont{$\texttt{class}\ \exptype{C}{\ol{X} \triangleleft \ol{N}}$} with
  \normalfont{$\fjtypeinference(\mv{\Pi}, \texttt{class}\ \exptype{C}{\ol{X} \triangleleft \ol{N}}) = \mv{\Pi}'$},
  then the following statements holds:\\
  \normalfont $\forall (\exptype{C}{\ol{X} \triangleleft \ol{N}}.\texttt{m} : \exptype{}{\ol{Y} \triangleleft \ol{P}}\ \ol{\type{T}} \to \itype{T}) \in \mv{\Pi}': \quad \ol{X} <: \ol{N}, \ol{Y} <: \ol{P} \vdash \type{T}, \ol{T}, \ol{P}, \ol{N}\ \texttt{ok}$
\end{lemma}
\textbf{Well-formedness Proof:}
Well-formedness of types already declared in the input class can be easily checked before the start of the \fjtype{} algorithm.
We therefore assume all types and type variables given in the input to be well-formed and are not checking this during the type inference step.
%This applies to the bounds $\ol{N}$ of class definitions $\texttt{class}\ \exptype{C}{\ol{X} \triangleleft \ol{N}}$
%as well as field types and types given in cast expressions.
%This also means every generic variable used in the input to be correctly declared according to the \texttt{WF-VAR} rule.
So assuming $\ol{X} <: \ol{N}, \ol{Y} <: \ol{P} \vdash \ol{N}, \ol{P}\ \texttt{ok}$, we only have to show that every type inserted by our type inference algorithm is well-formed.

Using theorem \ref{theo:unifySoundness} we can show that $\ol{X} <: \ol{N}, \ol{Y} <: \ol{P} \vdash \type{T}, \ol{T}, \ol{P}, \ol{N}\ \texttt{ok}$.
There is only two ways our type inference algorithm is able to produce a type, which is not well-formed.
Either by violating a generic bound (see \texttt{WF-CLASS} rule)
or by using a generic variable, which is not in scope (see \texttt{WF-VAR} rule).
Every type variable generated by \fjtype{} is used in atleast one constraint ensuring compliance with the \texttt{WF-CLASS} rule.
The \texttt{WF-VAR} rule is satisfied, because the \unify{} function returns a type environment $\gamma$ under which the types are correct.
This type environment is used as generic type parameters in every method (see \fjtypeinference{}). 

%The \texttt{WF-CLASS} rule is always satisfied, because the \fjtype function generates $\lessdot$ constraints for every type used as a generic instantiation.
%%The exception to this is the type variable $\tv{a}$ generated by \typeExpr{} for method calls.
%%Here a $\doteq$-constraint is generated with $\tv{a}$ on the left side.
%%The \unify{} function will assign a well-formed type to $\tv{a}$, because all other types used are well-formed and the 
%Due to lemma \ref{lemma:unify-exhaustive} we can be sure that each type variable either gets a type assigned or a generic variable, which is correctly added to the method type by $\fjtypeInsert$.
%\fi

We compare the constraints generated by the \typeExpr{} function with the appropriate type rule from \TFGJ:
\begin{description}
  \item [Local var]
  No constraints are generated.
  \item[Method invocation]
By direct comparison we show that each of the generated constraints applies the same restrictions than the \texttt{GT-INVK} rule.
The \texttt{GT-INVK} rule states the condition $\textit{mtype}(m, \textit{bound}_\triangle(T_0), \mtypeEnvironment) = \exptype{}{\ol{Y} \triangleleft \ol{P}}\ \ol{U} \to U$.
The constraint $\type{R} \lessdot \exptype{C}{\ol{\tv{a}}}$ assures that the type of the expression $e_0$ contains the method \texttt{m}.
The type variables $\ol{\tv{b}}$ represent instances of $\ol{Y}$.
When calling a local method the generic variables $\ol{Y} \triangleleft \ol{P}$ are not present and $\ol{\tv{b}}$ is empty.
This is correct, because the \TFGJ type rules prevent local method calls to be polymorphic.

We generate constraints according to the \texttt{GT-INVK} rule:\\
\begin{small}
\begin{tabularx}{\linewidth}{lX|Xl}
  \textbf{\TFGJ{} Type rule} &&& \textbf{Constraints} \\
  $\mathtt{\environmentvdash e_0 : T_0 }$ &&&
    $({R}, \consSet_R) = \typeExpr(({\mtypeEnvironment} ;\overline{\localVarAssumption}), \texttt{e})$\\ 
  $\mathtt{\mathit{bound}_\Delta (T_0)}$ &&& $\type{R} \lessdot \exptype{C}{\ol{\tv{a}}}$ \\
  $\mathtt{\mathit{mtype}(m, \mathit{bound}_\Delta (T_0), \Pi)}$ &&& Lookup in the assumptions \\
 %$\textit{mtype}(m, \textit{bound}_\triangle(T_0)) = \ol{U} \to U$ & $\type{R} \doteq cl$\\
 $\environmentvdash \ol{e} : \ol{S}$ &&& $\forall \texttt{e}_i \in \ol{e} : (R_i, \consSet_i) = \typeExpr(({\mtypeEnvironment} ;
 \overline{\localVarAssumption}), \texttt{e}_i)$\\
 $\Delta \vdash \ol{S} \subeq  [\ol{V}/\ol{Y}]\ol{U}$ &&& $ \overline{R} \lessdot [\ol{\tv{b}}/\ol{Y}][\ol{\tv{a}}/\ol{X}]\overline{T}$\\
 $\environmentvdash \mathtt{e_0.m(\overline{e}) : [\ol{V}/\ol{Y}]U }$ &&& $ \tv{a} \doteq [\ol{\tv{b}}/\ol{Y}][\ol{\tv{a}}/\ol{X}]{T}$ \\
 $\Delta \vdash \ol{V} \subeq  [\ol{V}/\ol{Y}]\ol{P}$ &&& $\ol{\tv{b}} \lessdot [\ol{\tv{b}}/\ol{Y}][\ol{\tv{a}}/\ol{X}]\ol{P}$ \\
\end{tabularx}
\end{small}

No constraint is needed to ensure $\ol{V}\ \texttt{ok}$.
If we call a method, which comes with generic parameters $\ol{Y} \triangleleft \ol{P}$,
the $\ol{\tv{b}} \lessdot [\ol{\tv{b}}/\ol{Y}][\ol{\tv{a}}/\ol{X}]\ol{P}$ ensure well-formedness, knowing that $\ol{P}\ \texttt{ok}$.
When the method call is to a local method, $\ol{\tv{b}}$ stays empty.
It is possible for the local method to get equipped with generic parameters after the \unify{} step.
If this is the case, every local method will get the same generic types $\gamma$ given by the \unify{} function.
Under this type environment every type is well-formed (see lemma \ref{lemma:well-formedness}).
The $\ol{\tv{a}} \lessdot [\overline{\tv{a}}/\ol{X}]\ol{N}$ constraints guarantee the well-formedness of the fresh type variables $\ol{\tv{a}}$.

\item[Field access]
The constraint generation behaves mostly the same as method invocation.
We also generate Or-Constraints in the case of multiple classes containing a field with the same name.
The field types are already given in the input and need not to be inferred.
We assume they are well-formed and set the type of the field access to the same type as the field $\tv{a} \doteq
[\overline{\tv{a}}/\ol{X}]\type{T}$

\if0
 \begin{tabular}{l|l}
   \textbf{FGJ Type rule} & \textbf{Constraints} \\
   $\Gamma \vdash e_0:T_0$ & $(\type{R}, ConS) = \typeExpr(Ass, e_r)$\\ 
   $\quad \mathit{fields}(\mathit{bound}_\triangle(T_0)) = \overline{T} \ \overline{f}$ & $\type{R} \doteq \exptype{C}{\textbf{fresh}(\ol{X})}$ \\
  %$\textit{mtype}(m, \textit{bound}_\triangle(T_0)) = \ol{U} \to U$ & $\type{R} \doteq cl$\\
  $\triangle; \Gamma \vdash \ol{e} : \ol{S}$ & $\forall e_i \in \overline{e} : (pt_i, ConS_i) = \typeExpr(Ass, e_i)$\\
  $\triangle \vdash \ol{S} <: \ol{U}$ & $ \bigcup_{T_i \in \overline{T}} (pt_i \lessdot \textbf{fresh}(T_i))$\\
  $\triangle; \Gamma \vdash \mathtt{e_0.m(\overline{e}) : U }$ & $a \doteq \textbf{fresh}(T)$ \\
 \end{tabular}
 \fi
 \item[Constructor] We generate constraints according to the \texttt{GT-NEW} rule:\\
 \begin{tabularx}{\linewidth}{lX|Xl}
  \textbf{\TFGJ{} Type rule} &&& \textbf{Constraints} \\
  $\environmentvdash \ol{e} : \ol{S}$ &&& $\forall \texttt{e}_i \in \overline{\texttt{e}} : (R_i, \consSet_i) = \typeExpr(({\mtypeEnvironment} ;
  \overline{\localVarAssumption}), \texttt{e}_i)$\\
  $\environmentvdash \ol{S} <: \ol{T}$ &&& $\overline{R} \lessdot \overline{T}$\\
  $\type{N}\ \texttt{ok}$ &&& $\overline{\tv{a}} \lessdot
  [\overline{\tv{a}}/\ol{X}]\ol{N}$\\
  $\mathtt{\mathit{bound}_\Delta (T_0)}$ &&& ${R} \lessdot \exptype{C}{\ol{\tv{a}}}$ \\
  $\mathtt{\mathit{fields}(\mathit{bound}_\Delta (T_0))}$ &&& $\tv{a} \doteq [\overline{\tv{a}}/\ol{X}]\type{T}$
\end{tabularx}

\item[Cast]
A cast can either be an upcast or a downcast or a so called stupid cast.
See respective type rules \texttt{GT-UCAST}, \texttt{GT-DCAST}, \texttt{GT-SCAST} in chapter \ref{chapter:type-rules}.
%Every type of cast is allowed in \TFGJ, therefore no restrictions in form of constraints are needed.
%The check if the cast type $\mathtt{N}$ is well formed ($\mathtt{N}\ \text{ok}$) is done in advance to the \textbf{FJTYPE} algorithm.
We assume that each given type in our input set is well-formed.
Therefore the cast type $\mathtt{N}$ is well formed too.
So every possible type of cast is allowed in \TFGJ, therefore no restrictions in form of constraints are needed.

\end{description}

\hfill $\square$

