
formal models for Java, why based on FGJ

\begin{itemize}
\item Welterweight Java
  %\url{https://link.springer.com/chapter/10.1007/978-3-642-13953-6_6}
\item Igarashi, A., Pierce, B.C., Wadler, P.: Featherweight Java: a
  minimal core calculus for Java and GJ. ACM TOPLAS 23(3), 396–450
  (2001)
\item Flatt, M., Krishnamurthi, S., Felleisen, M.: A programmer’s
  reduction semantics for classes and mixins. In: Alves-Foss, J. (ed.)
  Formal Syntax and Semantics of Java. LNCS, vol. 1523,
  p. 241. Springer, Heidelberg (1999)
\item Bierman, G.M., Parkinson, M.J., Pitts, A.M.: MJ: An imperative
  core calculus for Java and Java with effects. Technical report,
  University of Cambridge (2003) 
\item 	Elias Castegren, Tobias Wrigstad:
OOlong: an extensible concurrent object calculus. SAC 2018: 1022-1029
\end{itemize}

\subsubsection*{Type inference}

In some object-oriented languages like Scala, C\#, and Java type inference
is included. But it is only local type inference \cite{PT98,OZZ01}. Local type
inference means that missing type annotations are recovered using only
information from adjacent nodes in the syntax tree without long distance
constraints such as unifying variables. E.g. the types of variables which
a non-functional expression is assigned to or a return type of a method can bei
inferred. But the argument types of arbitrary especially recursive methods
cannot be inferred by local type inference.

The base of many global type inference algorithms is the algorithm $\mathcal{W}$
which was presented by Damas and Milner \cite{DM82}. The fundamental idea
of the algorithm is to determine types by many-sorted type term
unification \cite{Rob65,MM82} where the unification is called for any
application in the functional program. This is an efficient way to infer the types
as many-sorted unification is unitary which means that there is at most one
most general result.  In \cite{Plue07_3} the Milner's approach is adopted
directly to Java. This means that at any method application in the Java program
the finitary unification is called which means that the result sets are multiplied in
many cases. In \cite{plue15_2} Pl\"umicke changes the approach. There 
type constraints are collected by parsing the abstract syntax tree. After that the
constraints are unified. The used Java-calculus in \cite{plue15_2} has
indeed lambda expressions but there are no methods. Functions are realized by
lambda expressions assigned to class fields. This means that there is no
overloading, as fields in Java cannot be overloaded. In \cite{plue17_2} the
language is extended by scala-like function types and the type inference
algorithm is adapted.



\subsubsection*{Unification}
The type inference problem is reduced to a constraint solving type unification
problem. 
The type unification problem which is addressed in Section \ref{sec:unify} is
well-known from polymorphic order-sorted unification which is used in logic
programming languages with polymorphically order-sorted types
\cite{GS89,MH91,HiTo92,CB95}.

In \cite{GS89} the type unification problem
is mentioned as an open problem. For the logical language \textsf{TEL} in
\cite{GS89} an incomplete type inference algorithm is given. The incompleteness
is caused by the fact, that subtype relationships
of polymorphic types which have different arities  (e.g. $\texttt{List(a)} \sub
\texttt{myLi(a,b)}$) are allowed. This leads to the property that there are
infinite chains in the type term ordering. In \textsf{TEL} for \texttt{List(a)}
$\,\leq\,$ \texttt{myLi(a,b)} holds: 

\smallskip
{\centering $\texttt{List(a)} \,\leq\, \texttt{myLi(a,List(a))} \,\leq\,
\texttt{myLi(a,myLi(a,List(a)))}  \leq \ldots$\\}

Caused by the invariance of Java--Types this problem arises only if wildcards
are allowed. This means in FGJ this problem is not present.

Nevertheless, this type unification algorithm
fails in some cases without infinite chains, although there is a unifier. Let
for example $\texttt{nat} 
\sub \texttt{int}$, and the set of inequations $\set{\mathtt{nat} \lessdot \mathtt{a}, \mathtt{int}
  \lessdot \mathtt{a}}$ be given, then $\set{\mathtt{a} \mapsto \mathtt{nat}}$
is determined, such that 
$\set{\mathtt{int} \lessdot \mathtt{nat}}$ fails, although $\set{\mathtt{a}\mapsto \mathtt{int}}$ is
a unifier. For $\set{\mathtt{int} \lessdot \mathtt{a}, \mathtt{nat} \lessdot
  \mathtt{a}}$ the algorithm determines the correct unifier
$\set{\mathtt{a}\mapsto \mathtt{int}}$.

In the typed logic programs of \cite{HiTo92} subtype
relationships of polymorphic types are allowed only between type
constructors of the same arity which means that there are no infinite chains.
In this approach a \emph{most general type unifier (mgtu)} is
defined as an upper bound of different principal type unifiers. In general
there are no upper bounds of two given type terms in the type term ordering,
which means that there is in general no mgtu in the sense of \cite{HiTo92}.
For example for  $\texttt{nat} \sub \texttt{int}$, $\texttt{neg} 
\sub \texttt{int}$, and the set of inequations $\set{\mathtt{nat} \lessdot
  \mathtt{a}$, $\mathtt{neg} \lessdot \mathtt{a}}$ the mgtu $\set{\mathtt{a} \mapsto \texttt{int}}$ is
determined. If the type term ordering is extended by $\mathtt{int} \sub
\mathtt{index}$ and $\mathtt{int} \sub \mathtt{expr}$, then there are three
unifiers $\set{\mathtt{a} \mapsto \texttt{int}}$, $\set{\mathtt{a} \mapsto
  \mathtt{index}}$, and $\set{\mathtt{a} \mapsto 
\mathtt{expr}}$, but none of them is a mgtu in the sense of \cite{HiTo92}.

The type system of \textsf{PROTOS-L} \cite{CB95} was
derived from \textsf{TEL} by disallowing any explicit subtype relationships
between polymorphic type constructors. 

In \cite{CB95}
a complete type unification algorithm is given, which can be extended to the
type system of \cite{HiTo92}. They solved the type unification problem for type
term orderings following the restrictions of \textsf{PROTOS-L} respectively the
restrictions of \cite{HiTo92}. Additionally, the result of this paper is, that
the type unification problem is not unitary, but finitary. This means in
general that there is more than one general type unifier. 

For the above example the algorithm determines, where $\texttt{nat} \sub
\texttt{int}$, $\texttt{neg} \sub \texttt{int}$, $\mathtt{int} \sub
\mathtt{index}$, and $\mathtt{int} \sub \mathtt{expr}$ and the set of
inequations $\set{\mathtt{nat} \lessdot
  \mathtt{a}$, $\mathtt{neg} \lessdot \mathtt{a}}$ is given, the three general
unifiers $\set{\mathtt{a} \mapsto \texttt{int}}$, $\set{\mathtt{a} \mapsto
  \mathtt{index}}$, and $\set{\mathtt{a} \mapsto \mathtt{expr}}$. 

In \cite{plue09_1} the type systems of \textsf{Tel} was transfered to Java. In
contrast to \textsf{Tel}, where infinite chains have a lower bound, 
in Java finite chain have an upper bound. E.g. for $\exptypett{myLi}{b,a} \olsub \exptypett{List}{a}$ holds:

\smallskip
\noindent
$\ldots \olsub
\exptypett{myLi}{\exptypett{?\,extends\,myLi}{\exptypett{\textrm{{\tt ?}}\,extends\,List}{a},a},a}
\ \olsub \exptypett{myLi}{\exptypett{?\,extends\,List}{a},a}$\\
\mbox{ } \hfill $\olsub
\exptypett{List}{a}$\\

In \cite{plue09_1} the open problem of infinite chains from \cite{GS89} was solved.
It is showed that in any infinite chain there is a finite number of elements such that
all other elements of the chain are instances of them which means that these
elements are more general than the other elements of the chain. This type
unification algorithm is used for the type inference algorithm of Java--5 with
wildcards in \cite{Plue07_3}. As FGJ allows no wildcards we used
the type unification algorithm of \cite{Plue04_1}  as the basis.
We improved the type unification algorithm such that constraints
of the form $a \lessdot ty$, where $a$ is type variable and $ty$ is is a
non-type variable type,
are not resolved rather converted to bounded type parameters \texttt{a extends
  ty}. This implicates an enormous reduction of solutions of the type
unification algorithm without restricting the generality of typings of
FGJ-programs. Unfortunately, constraints of the form $ty \lessdot a$ have
to be resolved as Java allows no lower bounds of type parameters. If we would
transfer our type inference algorithm to Scala then the solution of these
constraints could be disclaimed as Scala allows lower bounds of type
parameters. This would speed up our type inference algorithm again.






%%% Local Variables:
%%% mode: latex
%%% TeX-master: "TIforGFJ"
%%% End:
