\documentclass[a4paper,USenglish,cleveref, autoref, thm-restate]{lipics-v2021}
%This is a template for producing LIPIcs articles. 
%See lipics-v2021-authors-guidelines.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling autoref support, use "autoref"
%for anonymousing the authors (e.g. for double-blind review), add "anonymous"
%for enabling thm-restate support, use "thm-restate"
%for enabling a two-column layout for the author/affilation part (only applicable for > 6 authors), use "authorcolumns"
%for producing a PDF according the PDF/A standard, add "pdfa"

\pdfoutput=1 %uncomment to ensure pdflatex processing (mandatatory e.g. to submit to arXiv)
%\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the mandatory bibstyle

\title{Global Type Inference for Featherweight Generic Java} %TODO Please add

% \titlerunning{Global Type Inference for Featherweight Generic Java} %TODO optional, please use if title is longer than one line

\author{Andreas Stadelmeier}{DHBW Stuttgart, Campus Horb, Germany}{a.stadelmeier@hb.dhbw-stuttgart.de}{}{}%TODO mandatory, please use full name; only 1 author per \author macro; first two parameters are mandatory, other parameters can be empty. Please provide at least the name of the affiliation and the country. The full address is optional. Use additional curly braces to indicate the correct name splitting when the last name consists of multiple name parts.

\author{Martin Plümicke}{DHBW Stuttgart, Campus Horb, Germany}{pl@dhbw.de}{}{}

\author{Peter Thiemann}{Universität Freiburg, Institut für Informatik, Germany}{thiemann@informatik.uni-freiburg.de}{}{}

\authorrunning{A. Stadelmeier and M. Plümicke and P. Thiemann} %TODO mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

\Copyright{Andreas Stadelmeier and Martin Plümicke and Peter Thiemann} %TODO mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

   
\ccsdesc[500]{Software and its engineering~Language features}
%\ccsdesc[300]{Software and its engineering~Syntax}

\keywords{type inference, Java, compiler} %TODO mandatory; please add comma-separated list of keywords

\category{} %optional, e.g. invited paper

\relatedversion{} %optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversiondetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93]{Classification (e.g. Full Version, Extended Version, Previous Version}{URL to related version} %linktext and cite are optional

%\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...
%\supplementdetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93, subcategory={Description, Subcategory}, swhid={Software Heritage Identifier}]{General Classification (e.g. Software, Dataset, Model, ...)}{URL to related version} %linktext, cite, and subcategory are optional

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

\acknowledgements{}%optional

%\nolinenumbers %uncomment to disable line numbering



%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{todonotes} % [disable]
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{subcaption}
\usepackage{prftree}
\usepackage{tabularx}
\usepackage{multicol}
\input{prolog}


\begin{document}

\maketitle

\begin{abstract}
  Type Inference for Featherweight Generic Java
\end{abstract}



\input{introduction}

\input{motivation}

\input{preliminaries}

\section{Type inference algorithm}
\label{sec:type-infer-algor}
This section presents our type inference algorithm.
The algorithm is split into several parts, which are executed on a single class at a time:

\begin{enumerate}
\item Create assumptions and subtype relation
\item Constraint generation % with \textbf{FJTYPE}
\item Constraint solving % Unification of those constraints
\item Substitute principal type solution
\end{enumerate}

The solver returns a set of all possible type solutions.
This set inherits the principal type solution.
The last step simplifies the calculated solutions and only inserts the principal typing.
%The last step chooses the principal type out of those possibilities.

\subsection{Type inference for a program}
\label{sec:proc-mult-class}

Type inference processes a program one class at a time.
To do so, it must be possible to order the classes such that early
classes never call methods in later classes.
As an example, Figure~\ref{fig:invalidinput} shows a program that is
acceptable in FGJ, but rejected by \TFGJ because the methods \mv{m1}
and \mv{m2} are mutually recursive across class boundaries. There is
no order in which classes \mv{C1} and \mv{C2} can be processed.

Figure~\ref{fig:correctinput} contains a program
acceptable to both \TFGJ and FGJ because the mutual recursion of
methods \mv{m1} and \mv{m2} is taking place inside class \mv{D2}. As
\mv{D2} invokes method \mv{m} of \mv{D1}, type inference must process
\mv{D1} before \mv{D2}, which corresponds to the constraints imposed
by the typing of \TFGJ in Section~\ref{chapter:type-rules}.

% Only the first step creating the type assumptions is able to consider other classes as well.


\begin{figure}[tp]
    \centering
    \begin{minipage}{.48\textwidth}
\begin{lstlisting}[style=tfgj]
class C1 extends Object {
  m1(){ return new C2().m2(); }
}
class C2 extends Object{
  m2(){ return new C1().m1(); }
}
\end{lstlisting}
      \caption{Invalid \TFGJ program}
      \label{fig:invalidinput}
    \end{minipage}%
  ~$\left|~
    \begin{minipage}{.48\textwidth}
\begin{lstlisting}[style=tfgj]
class D1 extends Object {
  m(){ return ...; }
}
class D2 extends Object{
  m1(x){ return new D2().m2(); }
  m2( ){ return new D2().m1(
                new D1().m()); }
}
\end{lstlisting}
      \caption{Valid \TFGJ program}
      \label{fig:correctinput}
    \end{minipage}\right.$
\end{figure}

We obtain a viable order for processing the class declarations by
computing an approximate call graph based solely on method names. That
is, if method \mv{m} is used in \mv{C3} and defined both in \mv{C1}
and \mv{C2}, then \mv{C1} and \mv{C2} must both be processed before
\mv{C3}. In such a case, the use of \mv{m} might be ambiguous so that
type inference for class \mv{C3} proposes more than one solution. Global
type inference attempts to extend each partial solution to a solution for the
whole program and backtracks if that fails.

\subsection{Constraint generation}
\label{sec:fjtype}
\begin{figure}[tp]
  \begin{align*}
    % Type
    \itype{T} &::= \tv{a} \mid \mv{T} && \text{type variable or type}\\
    % Constraints
    \simpleCons &::= \itype{T} \lessdot \itype{T} \mid \itype{T} \doteq
        \itype{T} && \text{simple constraint: subtype or equality}\\
    % \consSet = \set{C_1, \ldots, C_2} \\
    \orCons{} &::= \set{\overline{\simpleCons_1}, \ldots, \overline{\simpleCons_n}} && \text{or-constraint}\\
    \constraint &::= \simpleCons\ |\ \orCons \\
    % Method assumptions:
    \methodAssumption &::= \exptype{C}{\ol X}.\texttt{m} : \exptype{}{\ol{Y}
                        \triangleleft \ol{P}}\ \ol{\itype{T}} \to \itype{T}  &&
                                                                \text{method
                                                                type assumption}\\
    \fieldAssumption &::= \exptype{C}{\ol X}.\texttt{f} : \type{T} && \text{field type assumption}\\
    \localVarAssumption &::= \texttt{x} : \itype{T} && \text{parameter
                                                       assumption}\\
    \mtypeEnvironment & ::= \mv\Pi \cup \overline{\methodAssumption} &
                & \text{method type environment} \\
    \typeAssumptionsSymbol &::= ({\mtypeEnvironment} ; \overline{\fieldAssumption}; \overline{\localVarAssumption}) 
  \end{align*}
  \caption{Syntax of constraints and type assumptions}
  \label{fig:syntax-constraints}
\end{figure}

Figure~\ref{fig:syntax-constraints} defines the syntax of
constraints. We extend types with \emph{type variables} ranged over by
$\tv{a}$. A constraint is either a simple constraint $\simpleCons$ or
an or-constraint $\orCons$, which is a set of sets of simple
constraints. An or-constraint represents different alternatives,
similar to an intersection type, and
cannot be nested. The output of constraint generation is a set of
constraints $\consSet$, which can hold simple constraints as well as or-constraints.
% \begin{description}
%   \item[Constraint] A constraint (\constraint) consists of two types or type variables and an operator.
%   The operator can either be a $\doteq$ (same type) or $\lessdot$ (subtype).
%   Example: $(a \lessdot \mathtt{Object})$, means that the type variable $a$ should be a subtype of \texttt{Object}.
%   \item[Or-Constraint] An Or-Constraint (\orCons{}) consists out of multiple sets of constraints ($c$).
%   It is not possible to have \orCons{} nested inside another \orCons{}.\\
%   For example $\orCons{}(\{ \ \{ (a \lessdot b), (a \leq \mathtt{Object}) \} \ , \ \{ (a \lessdot b)\} \ \})$
%   is an Or-Constraint consisting of two sets of constraints.
%   \item[Constraint-Set] The \fjtype algorithm returns a Constraint-Set (\consSet).
%   It is able to hold a mix of normal Constraints and Or-Constraints.
%   \end{description}


\todo[inline]{PJT 20220215: I think that the input to \fjtype is
  actually a method environment $\mv\Pi$. This makes it easier to
  detect the overriding: just use \textit{mtype} to check if the
  method was checked before. See suggested change.}

%The \fjtype{} algorithm produces two kinds of constraints.
% Before the algorithm starts we equip every untyped method with type variables.
% Every method parameter gets a unique type variable as a type aswell as every method gets a unique type variable as a return type.
% After our algorithm found a correct typisation we replace the type variables with the inferred types and generate a GFJ program.


Figure~\ref{fig:constraints-for-classes} contains the algorithm
{\fjtype} to generate constraints for classes. Its input
consists of the method type environment $\mv\Pi$ of the previously
checked classes and their field type assumptions
$\ol{\fieldAssumption{}}$. It distinguishes between overriding and
non-overriding method definitions. The former are recognized by
successful lookup of their type using \textit{mtype}. We set up the
method type assumptions accordingly and generate a constraint between
the inferred return type $\tv{a}_{\mv m}$ and the one of the
overridden method to allow for covariant overriding.
Constraints for the latter methods are generated with all fresh
variables for the argument and result types.

\begin{figure}[tp]
  \begin{gather*}
    % \fjtype : \typeAssumptionsSymbol \times \texttt{L} \rightarrow \ol{\constraint}\\
    \begin{array}{@{}l@{}l}
      \fjtype & ({(\mv{\Pi} ; \overline{\fieldAssumption})}, \mathtt{class } \ \exptype{C}{\ol{X} \triangleleft \ol{N}} \ \mathtt{ extends } \ \mathtt{N \{ \overline{T} \ \overline{f}; \, K \, \overline{M} \}}) =\\
              & \begin{array}{l@{}l@{}l}
                  \textbf{let} &\ \overline{\tv{a}}_{\mv m} \text{ be fresh type variables
                                 for each }\mv{m}\in\ol{M} \\
                               &\ \ol{\methodAssumption}_o = \set{\exptype{C}{\ol{X}}.\mv{m} :
                                 \exptype{}{\ol{Y} \triangleleft \ol{P}}\ \ol{T} \to \tv{a}_{\mv m} \mid \mv{m} \in \ol{M},
                                 \textit{mtype}(\mv{m}, \type{N}, \mv\Pi) = \exptype{}{\ol{Y} \triangleleft \ol{P}} \ol{\type{T}} \to \type{T}}\\
                               &\ \constraints_o = \set{\tv{a}_{\mv m} \lessdot \type{T} \ |\ \texttt{m} \in \ol{M}, 
                                 \textit{mtype}(\mv{m}, \mv{N}, \mv\Pi) = \exptype{}{\ol{Y} \triangleleft \ol{P}} \ol{\type{T}} \to \type{T}}\\
                               % \textbf{let} &\ m_{cons},
                               % m_{override}
                               % =
                               % \set{\overridesFunc(\typeAssumptions,
                               % \exptype{C}{\ol{X}}.\mathtt{m}) \ |\
                               % m
                               % \in \ol{M}} \\
                               &\ \ol{\methodAssumption}' = 
                                 \set{ (\exptype{C}{\ol{X}}.\mv{m} : \ol{\tv{a}} \to \tv{a}_{\mv
                                 m}) \mid \mv{m} \in \ol{M},
                                 \textit{mtype} (\mv m, \mv N,
                                 \mv\Pi) \text{ not defined}, \ol{\tv{a}}\ \text{fresh} } \\
                               % \cup \\
                               % \typeAssumptions \cup m_{override}
                  \textbf{in} \\
                               &\ \displaystyle{ \left(
                                 \bigcup_{\texttt{m} \in \ol{M}}
                                 \typeMethod( (\mv{\Pi} \cup
                                 \ol{\methodAssumption}' \cup
                                 \ol{\methodAssumption}_o ;
                                 \ol{\fieldAssumption}), \exptype{C}{\ol{X}},  \mathtt{m}) \right)
                                 \cup \constraints_o } \\ 
                \end{array}
    \end{array}
  \end{gather*}
  \caption{Constraint generation for classes}
  \label{fig:constraints-for-classes}
\end{figure}

% We use intersection types during the constraint generation.
% In the end we select one possible solution after all classes got infered.
%TODO: add this to syntax (intersection types in method assumptions)

\if0
The \fjtype function gets called for every class in the input.
This function accumulates all the constraints generated from calling the
typeMethod function for each method declared in the given class.
It also generares constraints for overriden methods.
If a method \texttt{m} in \texttt{C} overrides a method in its superclass,
then we make sure that the return type of \texttt{m} in \texttt{C} is
a subtype of the overriden method.
\fi

Constraint generation alternates with constraint solving: After
generating constraints with {\fjtype}, we solve them to obtain one or
more candidate extensions for the method type environment
$\mv\Pi$. Next, we pick a candidate and continue with the next class
until all classes are checked and we have an overall method type
environment.  Otherwise, we backtrack to check the next candidate. 

\begin{gather*}
%%%%%   \typeMethod: \typeAssumptionsSymbol \times \texttt{M} \rightarrow \ol{\constraint}\\
\begin{array}{@{}l@{}l@{}l}
  \typeMethod & (\ensuremath{(\mv{\Pi} ; \overline{\fieldAssumption})}, \exptype{C}{\ol{X}},\ &\  \mathtt{m}(\ol{x})\{ \mathtt{ return }\ \texttt{e}; \}) =\\
              & \textbf{let} & \exptype{}{\ol{Y} \triangleleft \ol{P}}\ \overline{T} \to T  = \mv{\Pi} (\exptype{C}{\ol{X}}.\mv{m})
  \\
              & %\textbf{let}
                                                                                              & ({R}, \constraints) =
                                                                                                \typeExpr((\mv\Pi ;
                                                                                                \overline{\fieldAssumption}; \set{\mv{this} :
                                                                                                \exptype{C}{\ol{X}} } \cup \set{ \ol{x} : \overline{{T}} }), \texttt{e})\\
              & \mathbf{in}
                                                                                              & \constraints \cup \set{{R} \lessdot {T}}\\
\end{array}
\end{gather*}

The \typeMethod{} function for methods just calls the \typeExpr{} function with the
return expression. It is significant to note that it adds the assumptions for the method parameters to the global assumptions before passing them to \typeExpr.
%and the global assumptions plus the assumptions for the method parameters.

\smallskip

In the following we define the \typeExpr{} function for every possible expression:

\smallskip

\noindent
$\typeExpr: \typeAssumptionsSymbol \times
\texttt{Expression} \rightarrow \type{T} \times \constraints
$
\begin{gather*}
  \typeExpr (({\mtypeEnvironment} ; \overline{\fieldAssumption};
  \overline{\localVarAssumption}), \mathtt{x}) =
  (\overline{\localVarAssumption} (\mv x) , \emptyset)
\end{gather*}


\smallskip
\todo[inline]{PJT 20220215: I think there is an issue in the
  constraint generation for fields. If I understand correctly,
  accessing fields may trigger the creation of an or-constraint. Not
  sure how this rule enacts it. See my alternative suggestion below.}


\begin{gather*}
  \begin{array}{@{}l@{}l}
    \typeExpr{} &(({\mtypeEnvironment} ; \overline{\fieldAssumption};
                  \overline{\localVarAssumption}), \texttt{e}.\texttt{f}) = \\
                & \begin{array}{ll}
                    \textbf{let} 
                    & ({R}, \consSet_e) = \typeExpr(({\mtypeEnvironment} ; \overline{\fieldAssumption};
                      \overline{\localVarAssumption}), \texttt{e})\\
                    & \tv{a} \text{ fresh} \\
                    & \consSet = \orCons\set{
                      \set{
                      {R} \lessdot \exptype{C}{\ol{\tv{a}}} , \tv{a} \doteq
                      [\overline{\tv{a}}/\ol{X}]\type{T}
                      \mid \overline{\tv{a}} \text{ fresh}
                      }
                      \mid \exptype{C}{\ol{X}}.\mv{f} : \mv{T} \in \ol{\fieldAssumption}
                      }\\
                      % & \constraints = \orCons(\constraints_{m})\\
                    {\mathbf{in}} & {
                    (\tv{a}, (\consSet_e \cup \constraints))}
                  \end{array} 
  \end{array}
\end{gather*}

\todo[inline]{Original version follows}
\noindent
$\begin{array}{@{}l@{}l}
\typeExpr{} &(\typeAssumptions, \texttt{e}.\texttt{f}) = \\
& \begin{array}{ll}
\textbf{let} 
& ({R}, \consSet_e) = \typeExpr(\typeAssumptions, \texttt{e}),\\
& \consSet_f = \orCons{}(\set{[\textbf{fresh}(\ol{X})/\ol{X}]\set{\type{R} \lessdot \exptype{C}{\ol{X}},\ \tv{a} \doteq \type{T}} \ |\ \exptype{C}{\ol{X}}.\texttt{f} : \type{T} \in \ol{\fieldAssumption}})\\
\multicolumn{2}{l}{\mathbf{in}
(\tv{a}, (\consSet_e \cup \consSet_f))}\\
& \text{where\ } \tv{a} \text{\ is\ a\ fresh\
  type\ variable}\\ 
\end{array} \\
\end{array}
$

\smallskip
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\todo[inline]{20220216: alternative suggestion for method calls}
\noindent
$\begin{array}{@{}l@{}l}
\typeExpr{} & (({\mtypeEnvironment} ; \overline{\fieldAssumption};
  \overline{\localVarAssumption}), \texttt{e}.\mathtt{m}(\overline{\texttt{e}}) ) = \\
& \begin{array}{ll}
\textbf{let}& % \\
% &
({R}, \constraints_R) = \typeExpr(({\mtypeEnvironment} ; \overline{\fieldAssumption};
  \overline{\localVarAssumption}), \texttt{e})\\
& \forall \texttt{e}_i \in \ol{e} : (R_i, \constraints_i) = \typeExpr(({\mtypeEnvironment} ; \overline{\fieldAssumption};
  \overline{\localVarAssumption}), \texttt{e}_i)  \\
                    & \tv{a} \text{ fresh} \\
& \begin{array}{@{}l@{}l}
  \constraints = \orCons\set{ & \set{{R} \lessdot \exptype{C}{\ol{\tv{a}}}, \tv{a} \doteq {T}, \overline{R} \lessdot \overline{T} , \ol{Y} \lessdot [\ol{\tv{a}}/\ol{X}]\ol{P} \mid \overline{\tv{a}} \text{ fresh}}\\
  & \ |\ (\exptype{C}{\ol{X}}.\texttt{m} : \exptype{}{\ol{Y} \triangleleft \ol{P}} \ \overline{T} \to {T}) \in {\mtypeEnvironment} }
\end{array}\\
\multicolumn{2}{l}{\mathbf{in} (\tv{a},(\constraints_R \cup \bigcup_i \constraints_i \cup \constraints))}
\end{array}
\end{array}
$

\todo[inline]{Original version follows}
\noindent
$\begin{array}{@{}l@{}l}
\typeExpr{} & (\typeAssumptions, \texttt{e}.\mathtt{m}(\overline{\texttt{e}}) ) = \\
& \begin{array}{ll}
\textbf{let}& % \\
% &
(\type{R}, \constraints_R) = \typeExpr(\typeAssumptions, \texttt{e}),\\
& \forall \texttt{e}_i \in \overline{e} : (\type{pt}_i, \constraints_i) = \typeExpr(\texttt{e}_i)  ,\\
& \begin{array}{@{}l@{}l}
  \constraints_{m} = \set{ & [\textbf{fresh}(\ol{Y})/\ol{Y}]\set{\type{R} \lessdot \exptype{C}{\ol{X}}, \tv{a} \doteq \type{T}, \bigcup_{\type{T}_i \in \overline{T}} (\type{pt}_i \lessdot \type{T}_i) , \ol{Y} \lessdot \ol{P}}\\
  & \ |\ (\exptype{C}{\ol{X}}.\texttt{m} : \exptype{}{\ol{Y} \triangleleft \ol{P}} \ \ol{T} \to \type{T}) \in \overline{\methodAssumption} }
\end{array}\\
& \constraints = \orCons(\constraints_{m})\\
\multicolumn{2}{l}{\mathbf{in} (\tv{a}, [\textbf{fresh}(\ol{X})/\ol{X}](\constraints_R \cup \bigcup_i \constraints_i \cup \constraints))}\\
& \text{where\ } \tv{a} \text{\ is\ a\ fresh\
  type\ variable}\\ 
\end{array}
\end{array}
$

%\{\ & \set{ \type{R} \lessdot \exptype{C}{\ol{X}}, \tv{a} \doteq \type{T}, \overline{\type{pt}} \lessdot \overline{\type{T}} }
%        , \ol{Y} \lessdot \ol{P} } }} \ |\ \exptype{}{\ol{Y} \triangleleft \ol{P}} T\ \texttt{m}(\ol{T}\  \ol{p}) \}

\smallskip

The \texttt{new}-statement comes without the generic variables
(\texttt{new Classname(...)} instead of \texttt{new Classname<Class>(...)}).
The correct type will be inferred by our type inference algorithm.
We generate new type variables for the generic variables of the class \texttt{C},
so the \unify{} algorithm can later set in the correct types for these variables.
He has to comply to the bounds given by $\ol{N}$, which is why we add $\ol{X} \lessdot \ol{N}$ to the constraints.
It is important to change every occurence of $\ol{X}$ with the fresh type variables $\textbf{fresh}(\ol{X})$ in the generated constraints.
$\ol{X}$ can occur in the bound $\ol{N}$ aswell as in the types of the constructor parameters $\ol{T}$.


\begin{gather*}
  \begin{array}{@{}l@{}l}
    \typeExpr &(({\mtypeEnvironment} ; \overline{\fieldAssumption};
                \overline{\localVarAssumption}), \mathtt{new }\ \texttt{C}(\ol{e}) ) = \\
              &\begin{array}{ll}
                 \textbf{let} % \\
                 & \forall \texttt{e}_i \in \overline{\texttt{e}} : (R_i, \constraints_i) = \typeExpr(({\mtypeEnvironment} ; \overline{\fieldAssumption};
                   \overline{\localVarAssumption}), \texttt{e}_i)  \\
                 & \overline{\tv{a}} \text{ fresh} \\
                 & \textit{fields} (\exptype{C}{\overline{\tv{a}}}) = \overline{T}\ \ol{f} \\
                 & \constraints = \overline{R} \lessdot \overline{T} , \overline{\tv{a}} \lessdot [\overline{\tv{a}}/\ol{X}]\ol{N} \\
                 \multicolumn{2}{l}{\mathbf{in}\ (\exptype{C}{\ol{\tv{a}}}, \constraints \cup \bigcup_i \constraints_i) }\\
                 & \text{where}\ \texttt{class}\ \exptype{C}{\ol{X} \triangleleft \ol{N}} \set{\ldots} \\
               \end{array}
  \end{array}
\end{gather*}


\todo[inline]{Original version follows}
%TODO: Hier noch Konstruktor Assumptions einführen und den TypeAssumptions hinzufügen
\noindent
$\begin{array}{@{}l@{}l}
\typeExpr &(\typeAssumptions, \mathtt{new }\ \texttt{C}(\overline{\texttt{e}}) ) = \\
&\begin{array}{ll}
\textbf{let} % \\
& \forall \texttt{e}_i \in \overline{\texttt{e}} : (\type{P}_i, \constraints_i) = \typeExpr(\typeAssumptions, \texttt{e}_i)  ,\\
%& \constraints = \{ \bigcup_{T_i \in \overline{T}} (pt_i \lessdot \type{T}_i) \ | \ \mathtt{class }\ \exptype{C}{\ol{X} \triangleleft \ol{N}}\{ \ldots, \texttt{C}(\overline{T} \overline{x}), \ldots \} \}\\
& \constraints = \{ \type{P}_i \lessdot \type{T}_i \ | \ \exptype{C}{\ol{X}}.\texttt{f}_i : \type{T}_i \in \ol{\fieldAssumption} \}\\
\multicolumn{2}{l}{\mathbf{in}\ [\textbf{fresh}(\ol{X})/\ol{X}](\exptype{C}{\ol{X}}, \constraints \cup \bigcup_i \constraints_i \cup \set{\ol{X} \lessdot \ol{N}}) }\\
& \text{taken } \ol{\type{N}}\ \text{from the class definition}\ \texttt{class}\ \exptype{C}{\ol{X} \triangleleft \ol{N}} \set{\ldots} \\
\end{array}
\end{array}
$

We do not generate constraints for casts.
\todo[inline]{PJT 20220216: more precisely, we ignore the return type and pass on the constraints}
\begin{gather*}
  \begin{array}{@{}l@{}l}
    \typeExpr &(({\mtypeEnvironment} ; \overline{\fieldAssumption};
                \overline{\localVarAssumption}), (\texttt{N})\mv{e} ) = \\
              &\begin{array}{ll}
                 \textbf{let} % \\
                 & (R, \constraints) = \typeExpr(({\mtypeEnvironment} ; \overline{\fieldAssumption};
                   \overline{\localVarAssumption}), \texttt{e})  \\
                 \multicolumn{2}{l}{\mathbf{in}\ (\mv{N}, \constraints) }
               \end{array}
  \end{array}
\end{gather*}


\subsubsection{Completeness of the type inference algorithm}
\todo[inline]{The following theorem talks about soundness of type inference and it lacks a formal
  statement! Before it can be stated, we need to say what is a solution of a constraint. Moreover,
  the constraint generation for classes has to return the newly generated method type assumptions:
  when we apply the solution to those, we obtain an updated method environment, which we can relate
  to the output of the \TFGJ class typing.}
\begin{theoremAndi}
  A type assignment which satisfies the constraints generated by \FGJType also satisfies the type rules of our \TFGJ language.
\end{theoremAndi}
\textbf{Proof:}
We show that the constraints generated by \textbf{GFJTYPE}
represent the type rules given in chapter \ref{chapter:type-rules}.
For most of the expression typing rules this is trivial.
Such as \texttt{GT-VAR}, \texttt{GT-FIELD} and \texttt{GT-NEW}.
The \texttt{GT-INVK} and \texttt{GT-L-INVK} rules are covered by the same constraints.
They just differ in the assumptions used to create those constraints.
For local method calls the method assumption comes without generic type variables ($\mathtt{\ol{Y}}$).
This has the effect that the type variables of this assumption will not be freshly instantiated
via $\mathtt{[\textbf{fresh}(\ol{Y})/\ol{Y}]}$, because $\mathtt{\ol{Y}}$ is empty.
This prevents polymorphic recursion for local method calls.

\begin{theoremAndi}

\end{theoremAndi}
%Theorem: The Unify algorithm is complete
%Theorem: \textbf{FJTYPE} generates the principal type
\textbf{Proof:} The \unify{} algorithm is complete, so every correct type is included in the solution set.
We only have to choose the right type out of those solutions.
When compiling multiple classes the problem arises,
that only one of the type solutions calculated by \unify{} is correct
in respective to the other classes that will be compiled afterwards.

All types that are possible under the FGJ typing rules, plus our additional assumptions,
also comply with the generated constraints.

We match every generated constraint with the respective type rule to show completeness of our \textbf{FJTYPE} algorithm.
This shows that none of the generated constraints remove a type which otherwise would be possible under the \TFGJ typing rules.
The constraints are generated on expression statements.
We now compare the constraints for each expression with the appropriate type rule from \TFGJ:
\begin{description}
  \item [this]
  has always the type of the surrounding class and generates no constraints.
  \item [Local var]
  No constraints are generated.
  \item[Method invocation (\texttt{GT-INVK})]
The \texttt{GT-INVK} rule is for method calls, which already have a type assignment.
By direct comparison we show that each of the generated constraints applies the same restrictions than the \texttt{GT-INVK} rule.
The \texttt{GT-INVK} rule states the condition $\textit{mtype}(m, \textit{bound}_\triangle(T_0)) = \exptype{}{\ol{Y}}\ \ol{U} \to U$.
%In our version of typeless FGJ every method name is unique
%and there is only one class with that particular method.
The constraint $\type{R} \lessdot \exptype{C}{\ol{X}}$ assures that the type of the expression $e_0$ contains the method \texttt{m}.

\begin{small}
\begin{tabularx}{\linewidth}{lX|Xl}
  \textbf{FGJ Type rule} &&& \textbf{Constraints} \\
  $\triangle; \Gamma \vdash e_o : T_0$ &&& $(\type{R}, ConS) = \typeExpr(Ass, e_r)$\\ 
  $\mathtt{\textit{bound}(T_0)}$ &&& $\type{R} \lessdot \exptype{C}{\ol{X}}$ \\
  $\mathtt{\exptype{}{\ol{Y} \triangleleft \ol{P}}\ \ol{U} \to U} \in \textit{mtype}(m, N)$ &&& Lookup in the assumptions \\
 %$\textit{mtype}(m, \textit{bound}_\triangle(T_0)) = \ol{U} \to U$ & $\type{R} \doteq cl$\\
 $\triangle; \Gamma \vdash \ol{e} : \ol{S}$ &&& $\forall e_i \in \overline{e} : (pt_i, ConS_i) = \typeExpr(Ass, e_i)$\\
 $\triangle \vdash \ol{S} <: \ol{U}$ &&& $ \bigcup_{T_i \in \overline{T}} (pt_i \lessdot T_i)$\\
 $\triangle; \Gamma \vdash \mathtt{e_0.m(\overline{e}) : U }$ &&& $a \doteq T$ \\
\end{tabularx}
\end{small}

\textit{Note}: The \typeExpr function only generates constraints which apply to our assumption.
\item[Method invocation (\texttt{GT-L-INVK})]
The \texttt{GT-INVK} rule is for local method calls.
The called method does not have a type yet and comes with type variables for the return and parameter types.
The difference for a normal method call is that we do not generate fresh type variables.
This results in the local method call not being polymorphic.
%TODO: Rewrite GT-INVK proof
%      Rewrite the FGJType algorithm for local method calls


 \item[Field access]
Mostly the same as method invocation.
Fieldnames by default are unique in the FGJ language.

 \begin{tabular}{l|l}
   \textbf{FGJ Type rule} & \textbf{Constraints} \\
   $\Gamma \vdash e_0:T_0$ & $(\type{R}, ConS) = \typeExpr(Ass, e_r)$\\ 
   $\quad \mathit{fields}(\mathit{bound}_\triangle(T_0)) = \overline{T} \ \overline{f}$ & $\type{R} \doteq \exptype{C}{\textbf{fresh}(\ol{X})}$ \\
  %$\textit{mtype}(m, \textit{bound}_\triangle(T_0)) = \ol{U} \to U$ & $\type{R} \doteq cl$\\
  $\triangle; \Gamma \vdash \ol{e} : \ol{S}$ & $\forall e_i \in \overline{e} : (pt_i, ConS_i) = \typeExpr(Ass, e_i)$\\
  $\triangle \vdash \ol{S} <: \ol{U}$ & $ \bigcup_{T_i \in \overline{T}} (pt_i \lessdot \textbf{fresh}(T_i))$\\
  $\triangle; \Gamma \vdash \mathtt{e_0.m(\overline{e}) : U }$ & $a \doteq \textbf{fresh}(T)$ \\
 \end{tabular}
 \item[Constructor]

\begin{tabular}{l|l}
  $\triangle; \Gamma \vdash \ol{e} : \ol{S}$ & $\forall e_i \in \overline{e} : (pt_i, ConS_i) = \typeExpr(Ass, e_i)$\\
  $\triangle \vdash \ol{S} <: \ol{T}$ & $\bigcup_{T_i \in \overline{T}} (pt_i \lessdot T_i)$
\end{tabular}

\item[Cast]
A cast can either be an upcast or a downcast or a so called stupid cast.
See respective type rules \texttt{GT-UCAST}, \texttt{GT-DCAST}, \texttt{GT-SCAST} in chapter \ref{chapter:type-rules}.
%Every type of cast is allowed in \TFGJ, therefore no restrictions in form of constraints are needed.
%The check if the cast type $\mathtt{N}$ is well formed ($\mathtt{N}\ \text{ok}$) is done in advance to the \textbf{FJTYPE} algorithm.
We assume that each given type in our input set is well-formed.
Therefore the cast type $\mathtt{N}$ is well formed ($\mathtt{N}\ \text{ok}$) too.
So every possible type of cast is allowed in \TFGJ, therefore no restrictions in form of constraints are needed.

\end{description}

\section{Unify}
\label{sec:unify-1}
\input{Unify}

\input{unifyProof}

\section{Insert intersection type}
\label{sec:insert-inters-type}
Flatten the constraints returned from \unify{}:
\begin{align*}
  \ddfrac{
    Uni \cup \set{ a \lessdot b}
  }{
    [b/a]Uni
  }
  \quad \texttt{flatten}
\end{align*}
We remove $a \lessdot b$ constraints. They cannot be used in method types.

Determine generics for method:\\
$\begin{array}{l}
  \textbf{genericinsert}(Uni , \ol{\tv{a}}) = 
  \set{ \type{A} \triangleleft \type{Object}\ |\ (\tv{a} \lessdot N) \notin Uni', (\tv{a} \doteq N) \notin Uni',\ \tv{a} \in \ol{\tv{a}}}  \cup \\
  \set{ \set{A \triangleleft \exptype{C}{\ol{X}}} \cup \textbf{genericinsert}(Uni, \set{\tv{x} \ |\ \tv{x} \in \ol{X}, \tv{x}\ \text{is type variable}}) \ |\ (a \lessdot \exptype{C}{\ol{X}}) \in Uni',\ a \in \ol{\tv{a}}}\\
  \end{array}$

Generate unifiers: \\
  $\begin{array}{l}
    \textbf{TypeSubstitutions}(Uni , \ol{\tv{a}}) = \\
    \set{ \sigma(\tv{a}) = \type{A}\ |\ (\tv{x} \doteq N) \notin Uni,\ \tv{a} \in \ol{\tv{a}}}
    \cup \set{ \sigma(\tv{a}) = N \ |\ (\tv{x} \doteq N) \in Uni,\ \tv{x} \in \ol{\tv{a}}}
 \end{array}$

Equip method assumption with types: \\
$\begin{array}{l}
  \textbf{typeInsert}(\type{N}.\texttt{m} : \ol{\tv{a}} \to \tv{a}, \sigma) = \\
  \textbf{let}\ \sigma = \textbf{TypeSubstitutions}(Uni, \set{\tv{a}} \cup \ol{\tv{a}})\\
  \quad \ol{X} = \textbf{genericinsert}(Uni, \set{\tv{a}} \cup \ol{\tv{a}})\\
  \textbf{in}\ \type{N}.\texttt{m} : \exptype{}{\ol{X}}\ \sigma(\ol{\type{T}}) \to \sigma(\type{T})
\end{array}$

$\begin{array}{l}
  \textbf{typeInsert} : \ol{\methodAssumption} \times Uni \to \ol{\methodAssumption}\\
  \textbf{typeInsert} (\ol{\methodAssumption}, Uni) = \set{ \textbf{typeInsert}(\methodAssumption, Uni) \ |\ \methodAssumption \in \ol{\methodAssumption}}
\end{array}$

The outcome of the \unify{} algorithm is a set of type solutions $Uni_{set}$.
The following function sets in all type solutions by generating overloaded methods:

\begin{description}
\item[Input] is a class with methods of the form%$\texttt{class}\ \exptype{C}{\ol{X} \triangleleft \ol{N}} \triangleleft N \{ \ol{M}\}$
$\mathtt{A\ m(\ol{A}\ \ol{p})\ldots}$, where $\mathtt{A}$ and $\mathtt{\ol{A}}$ are type variables.
And the set of possible type unifiers $Uni_{set}$.
\item[Output] is a type FJ class, where each method has the form
$\mathtt{\exptype{}{\ol{X} \triangleleft \ol{N}}\ T\ m(\ol{T}\ \ol{p})\ldots}$
\end{description}


For every $Uni \in Uni_{set}$ and every method \texttt{m} in the input class we apply the following steps:

\begin{enumerate}
\item In the first step we apply the \texttt{flatten} rule to remove all $a \lessdot b$ constraints. by setting them to $a \doteq b$ and substituting $[a/b]Uni$.
\begin{align*}
  \ddfrac{
    Uni \cup \set{ a \lessdot b}
  }{
    [b/a]Uni \cup \set{ a \doteq b }
  }
  \quad \texttt{flatten}
\end{align*}
\item 
Afterwards we determine which constraints belong to each method.
At this point, the method is still untyped and has type variables as return and parameter types.
After the type-insert step every type variable should either be replaced by a generic type variable or a regular type.

First we look for constraints of the form $a \lessdot N$, where $a \in T$ or $a \in \ol{T}$.
These constraints will be converted to the generic type variables of the method.
The whole set of generic type variable declarations $G_{tvs}$ consists out of:
\begin{itemize}
\item All the type variables, which are used by the method type, but do not have a bound given by the result set $Uni$,
will be assigned \texttt{Object} as bound:\\
$\set{A \triangleleft \texttt{Object} \ |\ (a \lessdot N) \notin Uni', (a \doteq N) \notin Uni',\ a \in T \cup \ol{T}}$
\item All type variables, which get another type variable assigned have to be declared also:
$\set{B \triangleleft \texttt{Object} \ |\ (a \doteq b) \in Uni', a \in T \cup \ol{T}}$
\item Additionally all type variables of the method, which are given a direct bound by a constraint in $Uni$: \\
$\set{A \triangleleft \exptype{C}{\ol{X}} \ |\ (a \lessdot \exptype{C}{\ol{x}}) \in Uni',\ a \in T \cup \ol{T}}$
\item At last we have to add a bound of every type variable added in the last two steps:\\
$G_{tvs} = \set{A \triangleleft \texttt{Object} \ |\ a \in G_{tvs},\ (a \lessdot N) \notin Uni'}$ and \\
$G_{tvs} = \set{A \triangleleft \exptype{C}{\ol{X}}  \ |\ a \in G_{tvs},\ (a \lessdot \exptype{C}{\ol{x}} ) \in Uni'}$
\end{itemize}
\item With the resulting $G_{tvs}$ we can finally create the typed method:
\begin{align*}
\mathtt{\exptype{}{G_{tvs}}\ \sigma(T)\ m(\sigma(\ol{T})\ \ol{p}))\{ \ldots \}}
\end{align*}
\textbf{Hint:}
$\sigma$ is given as:
\begin{align*}
\sigma(a) &= 
\begin{cases}
  \texttt{N}       & \quad \text{if } (a \doteq \texttt{N}) \in Uni \\
  \texttt{B}       & \quad \text{if } (a \doteq b) \in Uni \\
  \texttt{A}       & \quad \text{else}
\end{cases}
\end{align*}
\end{enumerate}

\subsection{Filter principal type}
We want to filter out the most principal type out of all the type solutions for a method.
If there exist two method typings:
$\exptype{}{\triangle_1}\ T_1\ m(\ol{T_1}\ p)\{ \ldots \} \in M$\\
$\exptype{}{\triangle_2}\ T_2\ m(\ol{T_2}\ p)\{ \ldots \} \in M$

with $\triangle \vdash \triangle_1(T_1) <: \triangle_2(T_2)$
and $\triangle \vdash \triangle_2(\ol{T_2}) <: \triangle_1(\ol{T_1})$
then remove the typing 
$\exptype{}{\triangle_2}\ T_2\ m(\ol{T_2}\ p)\{ \ldots \}$

We introduce a subtyping rule for overloaded methods:
\begin{align*}
\ddfrac{
  \begin{array}{c}\mathtt{
  \triangle_1 = \triangle, \ol{X} \triangleleft \ol{N}, \ol{Y} \triangleleft \ol{M} \quad \quad
  \triangle_2 = \triangle, \ol{X} \triangleleft \ol{N}, \ol{Z} \triangleleft \ol{P}
  }\\
  \mathtt{
  \triangle \vdash \triangle_1(T_1) <: \triangle_2(T_2) \quad \quad
  \triangle \vdash \triangle_2(\ol{T_2}) <: \triangle_1(\ol{T_1})
  }\\
  %\mathtt{\ol{\triangle}(T_1) \leq \ol{\triangle}(T_2) \quad \quad \ol{\triangle}(\ol{T_1}) \leq \ol{\triangle}(\ol{T_2})}
  \mathtt{T_1 \trianglelefteq T_2 \quad \quad \ol{T_1} \trianglelefteq \ol{T_2}}
  \end{array}
  }{
    \mathtt{
  \exptype{}{\ol{Y} \triangleleft \ol{P}}\ T_1\ m(\ol{T_1}\ p)\{ \texttt{return}\ e; \} <: \exptype{}{\ol{Y} \triangleleft \ol{Q}}\ T_2\ m(\ol{T_2}\ p)\{ \texttt{return}\ e; \}
  \ \texttt{IN}\ \exptype{C}{\ol{X} \triangleleft \ol{N}}
  }
}
\end{align*}
%Notes: Parameter type is always the super type. Generic variables don't matter


We have to define our own typing rules for generic type variables:
\begin{align*}
\ddfrac{\mathtt{
  T \triangleleft N \in \triangle \quad \quad U \triangleleft M \in \triangle \quad \quad 
  N <: M
  }
}{\mathtt{\triangle \vdash T \trianglelefteq U}}
\end{align*}
\begin{align*}
\ddfrac{\mathtt{
  \triangle \vdash Z <: U
  }
}{\mathtt{\triangle \vdash T \trianglelefteq U}}
\end{align*}

\emph{A type-scheme for a declaration is a \emph{principal type-scheme}, if any
    other type-scheme for the 
declaration is a generic instance of it.}\cite{DM82}

When setting in the type solution generated by the \unify{} algorithm,
overloaded method can arise.
Overloaded methods always have the same method body and only differ in their typing.
In the last step of the type inference algorithm we want to filter out obsolete method typings.
We want to keep the method with the most principal type.

In the following example we only keep the method
\texttt{Overload m(Object a)}.
It has the most specific return type and the most general parameter type.
\begin{lstlisting}
class Overload extends Object {
 Object m(Overload a){
   return ...;
 }
 Overload m(Object a){
  return ...;
 }
 Object m(Object a){
  return ...;
 }
}
\end{lstlisting}

Type rules for parameter types:
\begin{align*}
  \ddfrac{\mathtt{    
    \texttt{class}\ \exptype{C}{\ol{A}}\ \texttt{extends}\ \exptype{D}{\ol{N}}
    }
  }{\mathtt{\triangle \vdash \exptype{C}{\ol{X}} \trianglelefteq \exptype{D}{\ol{Y}}}}
\end{align*}

%Frage an Martin: Ist das hier in FJ möglich?
% class C<A extends Object> {
%   m(C<Object> x){ return this.m(this);} 
%}

%TODO:
% Man muss noch dinge wie
% <A extends Object> A m(A o)
% Object m(Object o)
% filtern. Hier kann man sagen, wenn es eine generische Instanz ist, dann kann es weg


\subsection{Simplification}
\emph{As another example, the type of a function which uses its argument as an int but never terminates,
$\texttt{int} \to \alpha$, can be simplified to $\texttt{int} \to \bot$}
\cite{10.1145/3409006}
\textbf{Example:}
\begin{lstlisting}
<B extends Object, C extends Object> B a1(C x) {
  return this.a2(x);
}
<C extends Object, B extends Object> B a2(C y) {
  return this.a1(y);
}
\end{lstlisting}

\subsection{Example}

\begin{lstlisting}
class OverloadedMethods extends Object {
  <A extends Object> A m1(Object b)... 
  <B extends Object> Object m1(B b)...

  <A extends String> Object m(A a)... //<- obsolete
                     Object m(Object a)... //<- principal type


  <B extends List<Object>> Object m3(B b)...
  <A, B extends List<A>>   Object m3(B b)...

  //List<A> !<: List<Object>
  <A extends String> List<A> m4()
                List<Object> m4() 

  //List<A> !<: List<Object>
  <A extends Object> List<A> m4()
                List<Object> m4() // this should be deleted 
  // if the return type is a subtype or a generic instantiation -> it is obsolete

  <A extends String> _ m5(List<A> a)
                     _ m5(List<Object> b)

  // ArrayList<A> <: List<A>
  <A extends String> _ m5(List<A> a)
  <A extends String> _ m5(ArrayList<A> b) // this is obsolete

  <A, B extends List<A>> _ m5(B a)
  <A extends String> _ m5(ArrayList<A> b) // this is obsolete

  <A, B extends List<A>> _ m5(Map<A,B> a) // this is obsolete
  <A extends Object> _ m5(Map<A,A> b) 
                                      
  // here it doesn't matter which method to keep
  <A extends Object> _ m5(A a)
                     _ m5(Object b)

  //List<A> <: ArrayList<A>
  <A extends Object> List<A> m2(ArrayList<A> b)...
  <A extends Object> ArrayList<A> m2(List<Object> b)...

  <A extends Object> A mImpossible() ...
}
\end{lstlisting}




\subsection{Proof}
\begin{theoremAndi}
  If a \TFGJ program is correct under its typing rules,
  then the same program is also correct under Featherweight Generic Java's typing rules.
  %If there is a valid type annotation for a \TFGJ program
\end{theoremAndi}
\textbf{Proof:}
We show this by comparing every \TFGJ type rule with the corresponding type rule from FGJ.
Most of the type rules stay the same.
The differnce lies in the \texttt{GT-METHOD}, \texttt{GT-CLASS}
and the \texttt{GT-INVK} rules.

\TFGJ allows the same method to have multiple types.
This is not real overloading, because the method body always stays the same.

When having two types for a method \texttt{m} this method would not be type correct under FGJ typing rules.
\begin{align*}
  \mathtt{
  \exptype{}{\ol{Y} \triangleleft \ol{P}} \ T\ \texttt{m}(\ol{T}\ \ol{x})\set{\ldots} } \\
  \mathtt{
    \exptype{}{\ol{Z} \triangleleft \ol{Q}} \ U\ \texttt{m}(\ol{U}\ \ol{x})\set{\ldots}
  }
\end{align*}
It is still possible to transform this program into a valid FGJ program.

At first we split every overloaded method into multiple methods with only one type.

\begin{small}
\begin{tabularx}{\textwidth}{cXcXc}
  $\begin{array}{rl}
    \textit{mtype}(m, N) = \set{ & \exptype{}{\ol{X_1}\triangleleft \ol{P_1}} \ol{T_1} \to T_1  \\
    & , \ldots , \\
    & \exptype{}{\ol{X_n}\triangleleft \ol{P_n}} \ol{T_n} \to T_n}
  \end{array}
  $ & & $\implies$ & & $\begin{array}{l}
    \textit{mtype}(m1, N) = \set{  \exptype{}{\ol{X_1}\triangleleft \ol{P_1}} \ol{T_1} \to T_1}\\
    \ldots \\
    \textit{mtype}(mN, N) = \set{  \exptype{}{\ol{X_n}\triangleleft \ol{P_n}} \ol{T_n} \to T_n}\\
  \end{array}$
\end{tabularx}
\end{small}

Every type solution computed by \unify{} is a correct solution.
%TODO Link to the Lemma proofing this
We can generate a new set of methods from every type solution and then merge those together.
This will result in a correct FGJ program.

FGJ \texttt{GT-METHOD}
\begin{align*}
\ddfrac{
  \begin{array}{c}
    \mathtt{\triangle = \ol{X} <: \ol{N}, \ol{Y} <: \ol{P} \quad \quad \triangle \vdash \ol{T}, T, \ol{P}\ \texttt{ok}}\\
    \mathtt{\triangle; \ol{x}:\ol{T}, \texttt{this}: \exptype{C}{\ol{X}} \vdash e_0 : S \quad \quad \triangle \vdash S <: T} \\
    \mathtt{\texttt{class}\ \exptype{C}{\ol{X} \triangleleft \ol{N}} \triangleleft N \set{\ldots} \quad \quad \textit{override}(m, N, \exptype{}{\ol{Y} \triangleleft \ol{P}} \ol{T} \to T)}
  \end{array}
}{
  \mathtt{\exptype{}{\ol{Y} \triangleleft \ol{P}}\ T\ \texttt{m}(\ol{T}\ \ol{x})\set{\ \texttt{return}\ e_0;\ } \ \texttt{OK IN}\ \exptype{C}{\ol{X} \triangleleft \ol{N}}}
}
\end{align*}

%Proof that we insert the principle type:
Only constraints of the form $a \lessdot \texttt{N}$ can be inserted as generic variables infront of a method.
After the \unify{} algorithm the following constraints remain.
\begin{itemize}
  \item $a \lessdot b$, this is removed by replacing every $b$ with $a$ in the result set
  \item $a \lessdot N$, this is used as generic type variables
  \item $a \doteq N$
  \item $a \doteq b$
\end{itemize}

At first remove the $a \lessdot b$ constraints with the \texttt{flatten} rule.
\begin{align*}
  \ddfrac{
    Eq \cup \set{ a \lessdot b}
  }{
    [b/a]Eq \cup \set{ a \doteq b }
  }
  \quad \text{flatten}
\end{align*}


The \unify{} algorithm returns a set of unifiers ${Uni}$.
Each element of that set is a correct solution.
The unifiers $\sigma$ map type placeholders to types.
When generating the intersection types for the methods we have to make sure that the
type placeholders for the return type as well as for the parameter types get replaced by the same unifier $\sigma$.
It can happen that two unifiers $\sigma_1$ and $\sigma_2$ lead to the same method type ($\sigma_1(A) = \sigma_2(A), \sigma_1(\ol A) = \sigma_2(\ol A)$).
The set of all the distinct combinations then builds the intersection type for the method.

\textbf{Example:}
\begin{lstlisting}
class Global{
  method1(a){
    a.add(this);
    return a.get();
  }
}
class List<A> {
  add(A item){...}
  A get() ...
}
\end{lstlisting}

The method \texttt{method1} would get the type $\set{ \exptype{List}{Object} \to \texttt{Object}
\ || \ \exptype{List}{Global} \to \texttt{Global}}$.
If FGJ would support overloaded methods this could be written as:
\begin{lstlisting}
class Global{
  Object method1(List<Object> a){
    a.add(this);
    return a.get();
  }
  String method1(List<Global> a){
    a.add(this);
    return a.get();
  }
}
class List<A> {
  add(A item){...}
  A get() ...
}
\end{lstlisting}

\section{Complexity}
\label{sec:complexity}

\input{complexity}

\section{Examples}
\label{sec:examples}

\input{examples}

\textbf{Example 1}\\
The algorithm is able to infer the types of multiple classes under specific circumstances.
The individual classes must be given to him after one another.
This comes with the restriction, that the first class is correct on its own and does not use any other class.
The second class that gets compiled can use the first class and so on.

The following example shows how the algorithm infers and compiles multiple classes iteratively.
The class \texttt{Class1} is infered first.
It has only one method which is the identity function,
to which our algorithm allocates the type $\exptype{}{A}\ A \to A$.
The next class \texttt{Class2} is now able to use this generic method.
The blue colored types are inferred in the next iteration of our algorithm.

\begin{table}
\caption{Two classes as input. \texttt{Class1} is infered first (shown in {\color{red}red})}
\begin{tabular}{cc}
\begin{lstlisting}
class Class1 extends Object {
  Class1() { super(); }
  id(a){
    return a;
  }
}
class Class2 extends Class1 {
  Class2() { 
    super(); 
  }
  example(){
    return new Class1().id(this);
  }
}
\end{lstlisting}
&
\begin{lstlisting}
class Class1 extends Object {
  Class1() { super(); }
  (*@ \textcolor{red}{<A> A} @*) id((*@ \textcolor{red}{A} @*) a){
    return a;
  }
}
class Class2 extends Class1 {
  Class2() { 
    super(); 
  }
  (*@ \textcolor{blue}{Class1}@*) example(){
    return this.(*@\textcolor{blue}{<Class1>}@*)id(this);
  }
}
\end{lstlisting}
\end{tabular}
\end{table}

\textbf{Example 2}\\
When compiling a class like the following
we have to first split this class into two classes.
The \texttt{TwoMethods} class can be first split into the classes \texttt{Class1}
and \texttt{Class2} and after being processed by the type inference algorithm it can be assembled back together again.
This leads to a principal typing.
When using our type inference algorithm on the class \texttt{TwoMethods} alone
it would give the method \texttt{id} the type $\texttt{TwoMethods} \to \texttt{TwoMethods}$,
which is not the desired principal type.
\begin{lstlisting}
class TwoMethods extends Object {
  TwoMethods() { super(); }
  id(a){
    return a;
  }
  example(){
    return this.id(this);
  }
}
\end{lstlisting}

\textbf{Example 3}\\
%TODO: Ein Beispiel für die Unify-adapt Regel
FGJ allows subtype relations like the following:
\begin{lstlisting}
class Map<A,B> extends Object {
  Map<A,B>() { super(); }
}
class SpecialMap<A,B,C> extends Map<A,C> {
  SpecialMap<A,B,C>() { super(); }
}
\end{lstlisting}

If for example we have a method \texttt{method} like this:
\begin{lstlisting}
<X> void method(Map<X, String> map){
  ...
}
\end{lstlisting}
and call it:
\begin{lstlisting}
method(new SpecialMap<Object,Integer,String>());
\end{lstlisting}

Then the constraint $\exptype{SpecialMap}{Object,Integer,String} \lessdot \exptype{Map}{X,String}$
is generated by the \textbf{FJTYPE} algorithm.
This constraint will be processed by the \texttt{adapt} rule of the \unify{} algorithm.
Remember that $(\exptype{SpecialMap}{A,B,C} \olsub \exptype{Map}{A,C}) \in S_\leq$.
\begin{align*}
  Eq& \cup \exptype{SpecialMap}{Object,Integer,String} \lessdot \exptype{Map}{X,String} \\
  \cline{1-2} 
  Eq& \cup \set{\exptype{Map}{[ Object / A ][ Integer / B ][ String / C ](A,C)}
  \doteq \exptype{Map}{X,Integer}} \\
  \cline{1-2} 
  Eq& \cup \set{\exptype{Map}{Object,String}
  \doteq \exptype{C}{X, Integer}}
%Eq \cup \set{\theta_1 \doteq \lambda'_1 \ldo \theta_n \doteq \lambda'_n}
\end{align*}

After the \texttt{adapt} rule got applied we can already see that a correct unificator for this constraint would be
$\sigma(X) = \texttt{Object}$.

\textbf{Example 4 (Multiple type solutions):}
\begin{lstlisting}
class List<A> extends Object {
  List<A> add(A p){...}
}
class C1 extends Object {
  m1(ls){
    return ls.add(this);
  }
}
class C2 extends Object {
  m2(){
    return new C1().m1(new List<C1>());
  }
}
\end{lstlisting}
When compiling the class \texttt{C1} there are two possible method typings for \texttt{m1}.
One of it would 
\begin{lstlisting}
class List<A> extends Object {
  List<A> add(A p){...}
}
class C1 extends Object {
  List<Object> m1((*@\color{red}List<Object>@*) ls){
    return ls.add(this);
  }
}
class C2 extends Object {
  m2(){
    return new C1().m1((*@\color{red}new List<C1>()@*));
  }
}
\end{lstlisting}
\texttt{List<Object>} would be a correct type for the parameter \texttt{ls}.
The call \texttt{ls.add(this)} still works because the type of \texttt{this} is a subtype of \texttt{Object}.
But then the method \texttt{m2} will be incorrect when compiling the class \texttt{C2}.
Our algorithm has to backtrack to the class \texttt{C1} and use the other possible typing.
The following would be the correct solution with \texttt{List<C1>} as the type for \texttt{ls}.
\begin{lstlisting}
class List<A> extends Object {
  List<A> add(A p){...}
}
class C1 extends Object {
  List<C1> m1((*@\color{green}List<C1>@*) ls){
    return ls.add(this);
  }
}
class C2 extends Object {
  List<C1> m2(){
    return new C1().m1((*@\color{green}new List<C1>()@*));
  }
}
\end{lstlisting}

\textbf{Example 5} (for global type inference)
\begin{lstlisting}

\end{lstlisting}

\section{Assessment}
\label{sec:assessment}

\begin{itemize}
\item NP-hard \todo[inline]{Show NP-completeness!}
\item cannot infer all possible generic methods
\item features that need to be addressed to make it practical (e.g.,
  what's necessary to move from FGJ to full Java: overloading,
  imperative, )
\end{itemize}

Java has some features which make global type inference hard:
\begin{itemize}
\item subtyping and overloading combined with a nominal type system;
  we show NP-hardness even without overloading
  \todo[inline]{correct?}
\item mutable local variables and mutable object state,
\item polymorphic recursion in method calls
\item Inside a Java method it is possible to call every other declared Java method
  \todo[inline]{meaning? The letrec-rule works on the fact that in a let statement:
  \lstinline{let x = e in e2} the expression \texttt{e} is not able to use \texttt{x}}
\item methods can have side effects.
\end{itemize}


For Featherweight Generic Java it is easier to decide because there is no state and therefore no wildcard types.
Also we exclude polymorphic recursion.

% Example for local type inference in Java:
% \begin{lstlisting}[language=java]
% // Java 8 code:
% class Local {
%   // type inference puts in "ArrayList<String>()"
%   List<String> field = new ArrayList<>();
% }
% \end{lstlisting}
% \todo[inline]{Is this a drawback for LVTI? Does GTI put
%   \lstinline{List<String>} or \lstinline{Map} in the
%   \lstinline{outerMap} example?}

\section{Limitations of the algorithm}
\label{sec:limits-algorithm}

Java does not allow generic variables with lower bounds.
The expression \texttt{<A super String>} is not a correct definition in FJ.

Take the following input program as an example:
\begin{lstlisting}{java}
class Example{
    method(list){
        return list.add(this).get();
    }
}
\end{lstlisting}
Lets assume this yields the constraints:
$p \lessdot \exptype{List}{b}, r \lessdot \exptype{List}{b}, \texttt{Example} \lessdot b$
Now we cannot insert a generic type variable with super bounds like this:
\texttt{B super Example}

We have to still calculate every possible supe\type{R}pe of \texttt{Example} which will lead to an array of possible solutions.


\section{Related Work}
\label{sec:related-work}

\input{relatedWork}

\section{Conclusions}
\label{sec:conclusions}


%\bibliographystyle{splncs04}
\bibliography{peter,martin}

\end{document}
\endinput
%%
%% End of file `TIforGFJ.tex'.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
