% APLAS 21: 18 pages in the Springer LNCS format(LaTeX template),
% including bibliography and figures
% APLAS 2021 will use a lightweight double-blind reviewing process.
\documentclass[runningheads]{llncs}

\usepackage{todonotes} % [disable]
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{subcaption}
\usepackage{prolog}
\usepackage{prftree}

\parindent=0mm
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Type Inference for Featherweight Generic Java}


\author{Andreas Stadelmeier \and
Martin Plümicke\and
Peter Thiemann}
%
\authorrunning{F. Author et al.}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{DHBW Stuttgart, Campus Horb
\email{a.stadelmeier@hb.dhbw-stuttgart.de}}
\authorrunning{Stadelmeier, Plümicke, Thiemann}


%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
  Type Inference for Featherweight Generic Java
  \keywords{type inference, Java, compiler}
\end{abstract}



\input{introduction}

\input{motivation}

\input{preliminaries}

\section{Type inference algorithm}
\label{sec:type-infer-algor}
In this chapter we present our type inference algorithm.
The algorithm is split into following parts, which are executed on a single class at a time:

\begin{enumerate}
\item Create assumptions and subtype relation
\item Constraint generation with \textbf{FJTYPE}
\item Unification of those constraints
\item Set in principal type solution
\end{enumerate}

The Unify algorithm returns a set of possible type solutions.
This means that there are possibly multiple type solutions for each method.
The last step has to choose the principal type out of those possibilities.

\subsection{Process multiple classes}
The algorithm processes only one class at a time.
Only the first step creating the type assumptions is able to consider other classes as well.

Nevertheless we allow the input to consist out of multiple classes.
But in that case there are some additional requirements for the input.
%TODO: these requirements can also be in "Preliminaries"

We assume that the algorithm are given the input classes in the correct order $C_1, \ldots C_2$.
Hereby there must exist a correct typisation for the class $C_1$ when existing on its own.
This is also regulated by our typing rules (see chapter \ref{chapter:type-rules}).

\textbf{Example:}
We give an example for a incorrect input program for our algorithm, where none of the given classes cannot be compiled on its own.
  \begin{figure}
    \centering
    \begin{minipage}{.5\textwidth}
      \centering
      \begin{lstlisting}
class C1 extends Object {
  C1(){ super(); }
  m1(){ return new C2().m2(); }
}
class C2 extends Object{
  C2(){ super(); }
  m2(){ return new C2().m1(); }
}
          \end{lstlisting}
            \caption{Invalid typeless GFJ program}
      \label{fig:invalidinput}
    \end{minipage}%
    \begin{minipage}{.5\textwidth}
      \centering

    \begin{lstlisting}
class C1 extends Object {
  C1(){ super(); }
}
class C2 extends Object{
  C2(){ super(); }
  m1(){ return new C2().m2(); }
  m2(){ return new C2().m1(); }
}
            \end{lstlisting}
          \caption{Correct typeless GFJ program}
      \label{fig:correctinput}
    \end{minipage}
\end{figure}

The problem in figure \ref{fig:invalidinput} is a circular method call graph.
Method \texttt{m1} calls method \texttt{m2} and other way round.
Our typing rules demand that one of the two classes has to only use his internal methods.
Figure \ref{fig:correctinput} shows a possible way to alter the incorrect input to make it comply with our typing rules.
The method \texttt{m1} was moved into the class \texttt{C2}.
Now both methods still call each other, but they are inherited by the same class.

Another problem we face when compiling multiple classes is the fact that there can be more than a single principal typing for a method.
When considering only one class at once it is not possible to set in the correc type right away.
This problem can be solved with backtracking.
Whenever the \textbf{Unify} algorithm gives more than one type solution, we pick the first one and continue.
If the algorithm fails at some point it has to backtrack to this point and try one of the other solutions.

\subsection{Generate Assumptions}
% Every empty Type T in the input is assigned a type variable.
% Assumptions saves every field, method and the class subtype relation

%Generate subtype relationships:

Generating assumptions consists of two parts.
At first we add type variables to the untyped class.
The second part generates the assumption set.
This is the same algorithm for the already typed classes as for the 
new untyped class, which is now equipped with type variables.

\begin{enumerate}
\item Every missing type in the input class gets assigned a fresh type variable.
For methods:
\begin{align*}
  \ddfrac{
  m(\ol{x}) \{ \ldots \} \quad \quad A \cup \ol{A} \ \text{are fresh type variables}
  }{
  A m(\ol{A}\ \ol{x}) \{ \ldots \}
  }
  \end{align*}
  For fields:
\begin{align*}
  \ddfrac{
  \texttt{class}\ \exptype{C}{\ol{X}} \{ \ol{f}; \quad \ldots \} \quad \quad \ol{F} \ \text{are fresh type variables}
  }{
    \texttt{class}\ \exptype{C}{\ol{X}} \{ \ol{F} \ \ol{f}; \quad \ldots \}
  }
\end{align*}
\item We define the two functions $\textit{ftype}_\textit{Ass}$ and $\textit{mtype}_\textit{Ass}$.
Both functions return a set of all types for a method \texttt{m} or a field \texttt{f}.
This is due to the fact that there can be multiple methods and fields with the same name.
\begin{align*}
  %TODO: fresh type variables for generic variables:
  \ddfrac{
    class\ \exptype{C}{\ol{X} \triangleleft \ol{N}}\ \{\ \ol{N}\ \ol{f};\ K\ \ol{M}\ \} \quad \quad
    \exptype{}{\ol{Y}}\ U\ \texttt{m}(\ol{U}\ \ol{x}) \{ \ldots \} \in \ol{M}
  }{
    \textit{mtype}_\textit{Ass}(\texttt{m}, \exptype{C}{\ol{X} \triangleleft \ol{N}}) =  \set{\exptype{}{\ol{Y}} (\ol{U} \to U )}
  }
\end{align*}
\begin{align*}
  \ddfrac{
    class\ \exptype{C}{\ol{X} \triangleleft \ol{N}}\ \{\ \ol{T}\ \ol{f};\ K\ \ol{M}\ \} \quad \quad
    T\ \texttt{f} \in \ol{f}
  }{
    \textit{ftype}_\textit{Ass}(\texttt{f}, \exptype{C}{\ol{X} \triangleleft \ol{N}}) = T
  }
\end{align*}
\item If the input for the type inference algorithm consists out of multiple classes we compile them one by one.
Additionally we add the types of the already compiled classes to the assumption set.
Therefore it is possible to have intersection types already in the assumptions.
\end{enumerate}


\subsection{FJTYPE}
The \textbf{FJTYPE} algorithm produces two kinds of constraints.
\begin{description}
\item[Constraint] A constraint consists of two types or type variables and an operator.
The operator can either be a $\doteq$ (same type) or $\lessdot$ (subtype).
Example: $(a \lessdot \mathtt{Object})$, means that the type variable $a$ should be a subtype of \texttt{Object}.
\item[OrConstraint] An OrConstraint consists out of multiple constraint sets.
For example $\textbf{OrConstraint}(\{ \ \{ (a \lessdot b), (a \leq \mathtt{Object}) \} \ , \ \{ (a \lessdot b)\} \ \})$
is an Or-Constraint consisting of two constraint sets.
\end{description}

Before the algorithm starts we equip every untyped method with type variables.
Every method parameter gets a unique type variable as a type aswell as every method gets a unique type variable as a return type.
After our algorithm found a correct typisation we replace the type variables with the inferred types and generate a GFJ program.

The algorithm \textbf{FJTYPE} is given as follows:

\textbf{FJTYPE}:
$
\texttt{Class} \rightarrow \texttt{Constraints}\\
 \begin{array}{@{}l@{}l@{}l}
 \textbf{FJT}&\textbf{Y} & \textbf{PE}(\mathtt{class } \ C \ \mathtt{ extends } \ D \{ \overline{T} \ \overline{f}; \, K \, \overline{M} \}) =\\
& \multicolumn{2}{@{}l@{}}{ \{ \ \textbf{TYPEMethod}(\{ \mathtt{this} : C \}, m_i) \quad | \quad m_i \in \overline{M} \ \} }\\ 
\end{array}$

The \textbf{FJTYPE} function gets called for every class in the input.
This function accumulates all the constraints generated from calling the
\textbf{TYPEMethod} function for each method declared in the given class.

$\textbf{TYPEMethod}:\texttt{TypeAssumptions} \times
\texttt{Method} \rightarrow \texttt{Constraints}\\
\begin{array}{@{}l@{}l@{}l}
\textbf{TY}& \textbf{PE} & \textbf{Method} (Ass, T_r \ \mathtt{m}(\overline{T} \, \overline{x})\{ \mathtt{ return }\ e; \}) =\\
& \textbf{let}
& Ass_m = Ass \cup \{ \overline{T} : \overline{x} \}\\
& & \ul{(e:rty, ConS)} = \textbf{TYPEExpr}(Ass_m, e)\\
& \mathbf{in}
& (ConS \cup (rty \lessdot T_r))\\
\end{array}
$

The \textbf{TYPEMethod} function for methods just calls the \textbf{TYPEExpr} function with the
return expression. It is significant to note that it adds the assumptions for the method parameters to the global assumptions before passing them to \textbf{TYPEExpr}.
%and the global assumptions plus the assumptions for the method parameters.

\smallskip

In the following we define the \textbf{TYPEExpr} function for every possible expression:

\smallskip

$\textbf{TYPEExpr}:\texttt{TypeAssumptions} \times
\texttt{Expression} \rightarrow \texttt{Type} \times \texttt{Constraints}\\
\begin{array}{@{}l@{}l}
\textbf{TY} \textbf{PE} & \textbf{Expr} (Ass, \mathtt{this}) = (t , \{\})\\
& \textbf{with } (\mathtt{this} : t) \in Ass 
\end{array}
$
\smallskip
$\begin{array}{@{}l@{}l}
\textbf{TY} \textbf{PE} & \textbf{Expr} (Ass,x) = (t , \{\})\\
& \textbf{with } (x : t) \in Ass 
\end{array}
$

\smallskip

$\begin{array}{@{}l@{}l@{}l}
\textbf{TY}& \textbf{PE} & \textbf{Expr} (Ass, e.f) = \\
& \textbf{let} % \\
% &
& (rty, ConS) = \textbf{TYPEExpr}(Ass, e),\\
& & \textbf{fresh} = \text{a mapping from each variable in}\ \ol{X} \ \text{to a fresh type variable},\\
& & Ass_{f} = \textit{ftype}_{Ass}(\textit{bound}_\triangle(f)) = \exptype{C}{\ol{X} \triangleleft \ol{N}} \to T \\
& & Cons_{f} = \{\ rty \doteq \exptype{C}{\textbf{fresh}(\ol{X})}, a \doteq \textbf{fresh}(T)\},\\
& & \begin{array}{@{}l@{}l}
  Cons_{f} = \{\ & rty \doteq \exptype{C}{\ol{X}}, a \doteq T \\
              & |\, \text{for every field}\ \exptype{}{\ol{Y}} T\ \texttt{m}(\ol{T}\  \ol{p}) \in \ol{M} \} \\%, \textbf{fresh}(\ol{X}) \lessdot \textbf{fresh}(\ol{N})\},\\
              & ,\, \text{in every class}\ \exptype{C}{\ol{X}} \{ \ldots \ol{M} \ldots \}\ \text{in the input} \} 
            \end{array}\\
%& & OrCons = \{ \{ rty \doteq cl, a \doteq t_f \} \ | \ cl.f : t_f \in Ass \},\\
& \mathbf{in}% \\
% &
& (a, ConS \cup Cons_{f})\\
& & \mathit{where\ } a \mathit{\ is\ a\ fresh\
  type\ variable}\\ 
\end{array}
$

\smallskip

$\begin{array}{@{}l@{}l@{}l}
\textbf{TY}& \textbf{PE} & \textbf{Expr} (Ass, e.\mathtt{m}(\overline{e}) ) = \\
& \textbf{let} % \\
% &
& (rty, ConS) = \textbf{TYPEExpr}(Ass, e),\\
& & \forall e_i \in \overline{e} : (pt_i, ConS_i) = \textbf{TYPEExpr}(e_i)  ,\\
& & \begin{array}{@{}l@{}l}
        Cons_{m} = \{\ & rty \doteq \exptype{C}{\ol{X}}, a \doteq T, \bigcup_{T_i \in \overline{T}} (pt_i \lessdot T_i)\\
                    & |\, \text{for every method}\ \exptype{}{\ol{Y}} T\ \texttt{m}(\ol{T}\  \ol{p}) \in \ol{M} \} \\%, \textbf{fresh}(\ol{X}) \lessdot \textbf{fresh}(\ol{N})\},\\
                    & ,\, \text{in every class}\ \exptype{C}{\ol{X}} \{ \ldots \ol{M} \ldots \}\ \text{in the input} \} 
                  \end{array}\\
& & OrCons = \textbf{OrConstraint}(Cons_{m})\\
& \mathbf{in}% \\
% &
& (a, [\textbf{fresh}(\ol{X})/\ol{X}][\textbf{fresh}(\ol{Y})/\ol{Y}](ConS \cup \bigcup_i ConS_i \cup OrCons))\\
& & \text{where\ } a \text{\ is\ a\ fresh\
  type\ variable}\\ 
\end{array}
$

\smallskip

The \texttt{new}-statement comes without the generic variables
(\texttt{new Classname(...)} instead of \texttt{new Classname<Class>(...)}).
The correct type will be inferred by our type inference algorithm.
We generate new type variables $\ol{X'}$ for the generic variables of the class \texttt{C},
so the \textbf{Unify} algorithm can later set in the correct types for these variables.
He has to comply to the bounds given by $\ol{N}$, which is why we add $\ol{X'} \lessdot \ol{N}$ to the constraints.
It is important to change every occurence of $\ol{X}$ with the fresh type variables $\ol{X'}$ in the generated constraints.
$\ol{X}$ can occur in the bound $\ol{N}$ aswell as in the types of the constructor parameters $\ol{T}$.

$\begin{array}{@{}l@{}l@{}l}
\textbf{TY}& \textbf{PE} & \textbf{Expr} (Ass, \mathtt{new }\ C(\overline{e}) ) = \\
& \textbf{let} % \\
& \forall e_i \in \overline{e} : (pt_i, Cons_i) = \textbf{TYPEExpr}(Ass, e_i)  ,\\
& & Cons = \{ \bigcup_{T_i \in \overline{T}} (pt_i \lessdot T_i) \ | \ \mathtt{class }\ \exptype{C}{\ol{X} \triangleleft \ol{N}}\{ \ldots, \texttt{C}(\overline{T} \overline{x}), \ldots \} \}\\
& \mathbf{in}% \\
% &
& (\exptype{C}{\ol{X'}}, [\textbf{fresh}(\ol{X})/\ol{X}](Cons \cup \bigcup_i Cons_i \cup \ol{X'} \lessdot \ol{N}))\\
\end{array}
$

We do not generate constraints for casts.

\subsubsection{Completeness of the type inference algorithm}
%Theorem: The Unify algorithm is complete
%Theorem: \textbf{FJTYPE} generates the principal type
\textbf{Proof:} The \textbf{Unify} algorithm is complete, so every correct type is included in the solution set.
We only have to choose the right type out of those solutions.
When compiling multiple classes the problem arises,
that only one of the type solutions calculated by \textbf{Unify} is correct
in respective to the other classes that will be compiled afterwards.

All types that are possible under the FGJ typing rules, plus our additional assumptions,
also comply with the generated constraints.

We match every generated constraint with the respective type rule to show completeness of our \textbf{FJTYPE} algorithm.
This shows that none of the generated constraints remove a type which otherwise would be possible under the FGJ typing rules.
The constraints are generated on expression statements.
We now compare the constraints for each expression with the appropriate type rule from FGJ:
\begin{description}
  \item [this]
  has always the type of the surrounding class and generates no constraints.
  \item [Local var]
  No constraints are generated.
  \item[Method invocation]
By direct comparison we show that each of the generated constraints do not apply more restrictions than the \texttt{GT-INVK} rule.
The \texttt{GT-INVK} rule states the condition $\textit{mtype}(m, \textit{bound}_\triangle(T_0)) = \exptype{}{\ol{Y}}\ \ol{U} \to U$.
%In our version of typeless FGJ every method name is unique
%and there is only one class with that particular method.
The constraint $rty \lessdot \exptype{C}{\textbf{fresh}(\ol{X})}$ assures that the type of the expression $e_0$ contains the method \texttt{m}.

\begin{tabular}{l|l}
  \textbf{FGJ Type rule} & \textbf{Constraints} \\
  $\triangle; \Gamma \vdash e_o : T_0$ & $(rty, ConS) = \textbf{TYPEExpr}(Ass, e_r)$\\ 
  $\quad \textit{mtype}(m, \textit{bound}_\triangle(T_0)) = \exptype{}{\ol{Y}}\ \ol{U} \to U$ & $rty \lessdot \exptype{C}{\textbf{fresh}(\ol{X})}$ \\
 %$\textit{mtype}(m, \textit{bound}_\triangle(T_0)) = \ol{U} \to U$ & $rty \doteq cl$\\
 $\triangle; \Gamma \vdash \ol{e} : \ol{S}$ & $\forall e_i \in \overline{e} : (pt_i, ConS_i) = \textbf{TYPEExpr}(Ass, e_i)$\\
 $\triangle \vdash \ol{S} <: \ol{U}$ & $ \bigcup_{T_i \in \overline{T}} (pt_i \lessdot \textbf{fresh}(T_i))$\\
 $\triangle; \Gamma \vdash \mathtt{e_0.m(\overline{e}) : U }$ & $a \doteq \textbf{fresh}(T)$ \\
\end{tabular}

\textit{Note}: The \textbf{TYPEExpr} function only generates constraints which apply to our assumption.
 \item[Field access]
Mostly the same as method invocation.
Fieldnames by default are unique in the FGJ language.

 \begin{tabular}{l|l}
   \textbf{FGJ Type rule} & \textbf{Constraints} \\
   $\Gamma \vdash e_0:T_0$ & $(rty, ConS) = \textbf{TYPEExpr}(Ass, e_r)$\\ 
   $\quad \mathit{fields}(\mathit{bound}_\triangle(T_0)) = \overline{T} \ \overline{f}$ & $rty \doteq \exptype{C}{\textbf{fresh}(\ol{X})}$ \\
  %$\textit{mtype}(m, \textit{bound}_\triangle(T_0)) = \ol{U} \to U$ & $rty \doteq cl$\\
  $\triangle; \Gamma \vdash \ol{e} : \ol{S}$ & $\forall e_i \in \overline{e} : (pt_i, ConS_i) = \textbf{TYPEExpr}(Ass, e_i)$\\
  $\triangle \vdash \ol{S} <: \ol{U}$ & $ \bigcup_{T_i \in \overline{T}} (pt_i \lessdot \textbf{fresh}(T_i))$\\
  $\triangle; \Gamma \vdash \mathtt{e_0.m(\overline{e}) : U }$ & $a \doteq \textbf{fresh}(T)$ \\
 \end{tabular}
 \item[Constructor]

\begin{tabular}{l|l}
  $\triangle; \Gamma \vdash \ol{e} : \ol{S}$ & $\forall e_i \in \overline{e} : (pt_i, ConS_i) = \textbf{TYPEExpr}(Ass, e_i)$\\
  $\triangle \vdash \ol{S} <: \ol{T}$ & $\bigcup_{T_i \in \overline{T}} (pt_i \lessdot T_i)$
\end{tabular}
  
\end{description}

\section{Unify}
\label{sec:unify}
This chapter describes the \textbf{GenericUnify} algorithm
which is used to find type solutions for the constraints generated by \textbf{FGJType}.

\begin{description}
\item[input] A set of type constraints $Cons_{in}$ %and a set of subtype relationships $S_\leq$
\item[output] A set of type unifiers $Uni$
or fail $Uni = \emptyset$.
%The unifiers have the form of $Uni = \{ \sigma_1, \ldots , \sigma_n \}$.
\end{description}

The unify algorithm first has to build the cartesian product of all the \textbf{OrConstraint}s and the remaining normal constraints:
\begin{align*}
\Omega &= \text{All }\mathbf{OrConstraints} \text{ in } {Cons}_{in}\\
C &= {Cons}_{in} \setminus \Omega \\
Eq_{set} &= \Omega_1 \times \ldots \times \Omega_n \times C \quad \text{for all }\Omega_i \in \Omega
\end{align*}

%The algorithm starts by setting $Eq_{set} = \set{ Cons_{in} }$.
Afterwards the following steps are repeatedly executed on $Eq_{set}$ until the algorithm termiates:
%For every $Eq \in Eq_{set}$ the following steps are applied.
%The resulting unifiers $\sigma$ from each $Eq$ merged together form the result of the \textbf{Unify} algorithm.

%$\textbf{SubUnify} :: [Constraint] \to [Unifier]$
\begin{enumerate}
\item Repeated application of the rules depicted in figure \ref{fig:fgjreduce-rules} and \ref{fig:fgjerase-rules}.
The end configuration of $Eq$ is reached if for each element
no rule is applicable.

\item
(The function $\textbf{fresh}(i)$ returns an array of $i$ fresh type variables.)

\begin{align*}
Eq_1 =& \text{Subset of pairs where both type terms are type variables}\\
Eq_2 =& Eq / Eq_1 \\
Eq_{set}\\ 
    = 
     %& \begin{array}[t]{l@{\,}ll}
     % \times \, (\displaystyle{\bigotimes_{(a \lessdot \exptype{C}{\ol{X}}) \in Eq'_2}}
     % \{\,(a \doteq \exptype{D}{\ol{A}}) \, \cup \, (\ol{X} \doteq \ol{Y'}) \ | \ \sarray{@{}l}{
     %   \exptype{D}{\ol{Z}} <: \exptype{C}{\ol{Y}}, \\
     %   \ol{A} = \textbf{fresh}(\#(\ol{Z})), \\
     %   \ol{Y'} = [\ol{A}/\ol{Z}]\ol{Y}
     %   \,\})}\\ 
     % \end{array}\\
   %& \times\, 
   %   (\displaystyle{\bigotimes_{(\exptype{C}{\overline{T}} \lessdot a) \in Eq'_2}}\!\!
   %   \set{(a \doteq [\ol{T}/\ol{X}]N ) \ | \ (\exptype{C}{\overline{X}} \leq N) \in
   %     S_\leq})\\
    & %\times\, 
    (\displaystyle{\bigotimes_{(\exptype{C}{\overline{T}} \lessdot a) \in Eq'_2}}\!\!
    \set{a \doteq [\ol{T}/\ol{X}]N ) \ | \ (\exptype{C}{\overline{X} \triangleleft \ol{N}} <: N})\\
    & \times\, 
      (\displaystyle{\bigotimes_{((X \triangleleft M)\lessdot a) \in Eq'_2}}\!\!
      \set{a \doteq (X \triangleleft M)} \cup
      \set{a \doteq N ) \ | \ M <: N } \cup \set{a \doteq (X \triangleleft M)})\\
      & \times\, \set{[a \doteq N \ | \  (a \doteq N) \in Eq'_2]} \\
      & \times\, \set{[a \lessdot N \ | \  (a \lessdot N) \in Eq'_2]} \times Eq_1 \\
\end{align*}

\item \label{subst-step}  Application of the following \emph{subst} rule
    %\begin{enumerate}
    %\item Apply the following subst\_eq rule
    
      $$\begin{array}[c]{lll}
        (\mathrm{subst}) &
        \begin{array}[c]{l}
          Eq'' \cup \set{a \doteq \theta}\\
          \hline
          Eq''[a \mapsto \theta] \cup \set{a \doteq \theta}
        \end{array}
        & a \textrm{ occurs in } Eq'' \textrm{ but not in } \theta 
      \end{array}$$
      
      for each $a \doteq \theta$ in each element of $Eq' \in Eq'_{set}$.

\item 
    \begin{enumerate}
    \item Foreach $Eq \in Eq_{set}$ which has changed in the last step
      start again with the first step.
    \item Build the union $Eq_{set}$ of all results of (a) and all $Eq' \in
      Eq'_{set}$ which has not changed in the last step.
    \end{enumerate}
\item
\begin{enumerate}
\item Filter all constraint sets which are in solved form:\\
$Eq_{solved} = \set{ Eq \ | \ Eq \in Eq_{set}, Eq \ \text{is in solved form}}$
\item We apply the following rule to every constraint set in $Eq_{solved}$:
\begin{align*}
\ddfrac{
  Eq \cup \set{ a \lessdot b } %There are only Type variables left at this point
}{
  Eq \cup \set{ a \doteq b }
}
\end{align*}
\item $\emph{Uni} = \set{\sigma \ | \ Eq \in Eq_{solved},\ \sigma = \set{a \mapsto \theta \ | \ (a \doteq \texttt{T}) \in Eq} }$
%\item $\emph{Uni} = \sarray{l@{\ }l}{\set{\sigma \ | & Eq'' \in Eq''_{set},
%        Eq'' \textrm{ is in solved form,}\\ 
%        & \sigma = \set{a \mapsto \theta \ | \ (a \doteq \theta) \in Eq''}
%        \\ & \quad \cup \ \set{a \mapsto \texttt{A}, b \mapsto \texttt{B} \ | \ (a \lessdot b) \in Eq \ \text{and a is an isolated type variable}}
%        }}$
\end{enumerate}
\end{enumerate}

\begin{definition}[Isolated type variable] \label{def:isolated-type-variable}
  \rm
An isolated type variable does only occur in constraints together with another isolated type variable.
\end{definition}

\begin{definition}[Solved form]\label{def:solved-form}
  \rm
  A set of constraints $Eq$ has reached solved form if it contains only the following kind of constraints:
  \begin{enumerate}
    \item $a \lessdot b$, with $a$ and $b$ both isolated type variables
    \item $a \lessdot \exptype{C}{\ol{X}}$
    \item $a \doteq \exptype{C}{\ol{X}}$
  \end{enumerate}j
\end{definition}

\begin{figure}
\begin{center}
    \leavevmode
    \fbox{
    \begin{tabular}[t]{ll}
      (match)
      & $
      \begin{array}[c]{ll}
      \begin{array}[c]{l}
         Eq \cup \, \set{a \lessdot
         \exptype{C}{\ol{X}},
         a \lessdot
          \exptype{D}{\ol{Y}}} \\ 
        \hline
        \vspace*{-0.4cm}\\
        Eq \cup \set{a \lessdot \exptype{C}{\ol{X}}
        , \exptype{C}{\ol{X}} \lessdot \exptype{D}{\ol{Y}}}
      %Eq \cup \set{\theta_1 \doteq \lambda'_1 \ldo \theta_n \doteq \lambda'_n}
      \end{array}
      & \exptype{C}{\ol{Z}} <: \exptype{D}{\ol{N}} 
      \end{array}
      $
    \\\\
    (adopt)
    & $
    \begin{array}[c]{ll}
    \begin{array}[c]{l}
       Eq \cup \, \set{a \lessdot
       \exptype{C}{\ol{X}},
       b \lessdot
        a} \\ 
      \hline
      \vspace*{-0.4cm}\\
      Eq \cup \set{
        a \lessdot
       \exptype{C}{\ol{X}},
       b \lessdot
        a
      , b \lessdot \exptype{C}{\ol{X}}}
    %Eq \cup \set{\theta_1 \doteq \lambda'_1 \ldo \theta_n \doteq \lambda'_n}
    \end{array}
    \end{array}
    $
  \\\\
      (adapt)
      & $
      \begin{array}[c]{ll}
      \begin{array}[c]{l}
         Eq \cup \, \set{\exptype{D}{\ol{A}} \lessdot
          \exptype{C}{\ol{B}}} \\ 
        \hline
        \vspace*{-0.4cm}\\
        Eq \cup \set{\exptype{C}{[ \ol{A} / \ol{X} ]\ol{Y}}
        \doteq \exptype{C}{\ol{B}}}
      %Eq \cup \set{\theta_1 \doteq \lambda'_1 \ldo \theta_n \doteq \lambda'_n}
      \end{array}
      & \exptype{D}{\ol{X}} <:\ \exptype{C}{\ol{Y}}
      \end{array}
      $
    \\\\
(reduce1) & $
\begin{array}[c]{l}
  Eq \cup \set{\exptype{D}{\ol{A}} \lessdot
    \exptype{D}{\ol{B}}}\\
  \hline
  Eq \cup \set{\ol{A} \doteq \ol{B}}
\end{array}
      $ \\\\
(reduce2) & $
\begin{array}[c]{l}
  Eq \cup \set{\exptype{D}{\ol{A}} \doteq
    \exptype{D}{\ol{B}}}\\
  \hline
  Eq \cup \set{\ol{A} \doteq \ol{B}}
\end{array}
      $ \\\\
(equals) & $
\begin{array}[c]{l}
  Eq \cup \set{a \lessdot
    b, b \lessdot a}\\
  \hline
  Eq \cup \set{a \doteq b}
\end{array}
      $ \\\\
    \end{tabular}}
  \end{center}
\caption{Reduce and adapt rules}\label{fig:fgjreduce-rules}
\end{figure}

\begin{figure}
  \begin{center}
      \leavevmode
      \fbox{
      \begin{tabular}[t]{ll}
        (matchG)
        & $
        \begin{array}[c]{ll}
        \begin{array}[c]{l}
           Eq \cup \, \set{a \lessdot
           \exptype{C}{\ol{X}},
           a \lessdot
            (X \triangleleft \exptype{D}{\ol{Y}})} \\ 
          \hline
          \vspace*{-0.4cm}\\
          Eq \cup \set{a \lessdot \exptype{C}{\ol{X}}
          , \exptype{C}{\ol{X}} \lessdot \exptype{D}{\ol{Y}}}
        %Eq \cup \set{\theta_1 \doteq \lambda'_1 \ldo \theta_n \doteq \lambda'_n}
        \end{array}
        & \exptype{C}{\ol{Z}} <: \exptype{D}{\ol{N}} 
        \end{array}
        $
      \\\\
      (adoptG)
      & (the same as adopt)
    \\\\
    (adaptG)
    & $
    \begin{array}[c]{ll}
    \begin{array}[c]{l}
       Eq \cup \, \set{(X \triangleleft \exptype{D}{\ol{A}}) \lessdot
        \exptype{C}{\ol{B}}} \\ 
      \hline
      \vspace*{-0.4cm}\\
      Eq \cup \set{\exptype{C}{[ \ol{A} / \ol{X} ]\ol{Y}}
      \doteq \exptype{C}{\ol{B}}}
    %Eq \cup \set{\theta_1 \doteq \lambda'_1 \ldo \theta_n \doteq \lambda'_n}
    \end{array}
    & \exptype{D}{\ol{X}} <:\ \exptype{C}{\ol{Y}}
    \end{array}
    $
  \\\\
  (adaptG2)
  & $
  \begin{array}[c]{ll}
  \begin{array}[c]{l}
     Eq \cup \, \set{(X \triangleleft \exptype{C}{\ol{A}}) \lessdot
      \exptype{D}{\ol{B}}} \\ 
    \hline
    \vspace*{-0.4cm}\\
    Eq \cup \set{\exptype{C}{\ol{A}}
    \doteq \exptype{C}{[ \ol{B} / \ol{X} ]\ol{Y}}}
  %Eq \cup \set{\theta_1 \doteq \lambda'_1 \ldo \theta_n \doteq \lambda'_n}
  \end{array}
  & \exptype{D}{\ol{X}} <:\ \exptype{C}{\ol{Y}}
  \end{array}
  $
\\\\
  (reduce1) & $
  \begin{array}[c]{l}
    Eq \cup \set{\exptype{D}{\ol{A}} \lessdot
      \exptype{D}{\ol{B}}}\\
    \hline
    Eq \cup \set{\ol{A} \doteq \ol{B}}
  \end{array}
        $ \\\\
  (reduce2) & $
  \begin{array}[c]{l}
    Eq \cup \set{\exptype{D}{\ol{A}} \doteq
      \exptype{D}{\ol{B}}}\\
    \hline
    Eq \cup \set{\ol{A} \doteq \ol{B}}
  \end{array}
        $ \\\\
      \end{tabular}}
    \end{center}
  \caption{Reduce and adapt rules with generic variables}\label{fig:fgjreduce-rules-generic}
  \end{figure}

\begin{figure}
\begin{align*}
&\begin{tabular}[t]{ll}
      (erase1)  & $ 
      \begin{array}[c]{ll}
        \begin{array}[c]{l}
          Eq \cup \set{C \lessdot D}\\
          \hline
          Eq
        \end{array}
        & C \leq^* D \in S_\leq
      \end{array}$\\
          \end{tabular}\\
&\begin{tabular}[t]{ll}
      (erase2)  & $ 
      \begin{array}[c]{ll}
        \begin{array}[c]{l}
          Eq \cup \set{C \doteq C}\\
          \hline
          Eq
        \end{array}
      \end{array}$\\
          \end{tabular}\\
    &      \begin{tabular}[t]{ll}
       (swap) & $
            \begin{array}[c]{ll}
              \begin{array}[c]{l}
                Eq \cup \set{C \doteq a}\\
                \hline
                Eq \cup \set{a \doteq C}
              \end{array}
            \end{array}$
          \end{tabular}
\end{align*}
\caption{Erase and swap rules}\label{fig:fgjerase-rules}
\end{figure}

\input{unifyProof}

\section{Insert principal type}
After generating all possible unifiers in the \textbf{Unify} we can insert the principal types.

\begin{align*}
\ddfrac{
  A\ \texttt{m}(\ol{A}\ \ol{p}) \{ \ldots \} \in M \quad \quad \texttt{class}\ \exptype{C}{\ol{X}} \{ \ldots\ M,\ \ldots\}
}{
  \textit{mtype}(\texttt{m}, \exptype{C}{\ol{X}}) = \set{\sigma(\ol{A}) \to \sigma(A) \,|\, \sigma \in {Uni}}
}
\end{align*}

The \textbf{Unify} algorithm returns a set of unifiers ${Uni}$.
Each element of that set is a correct solution.
The unifiers $\sigma$ map type placeholders to types.
When generating the intersection types for the methods we have to make sure that the
type placeholders for the return type as well as for the parameter types get replaced by the same unifier $\sigma$.
It can happen that two unifiers $\sigma_1$ and $\sigma_2$ lead to the same method type ($\sigma_1(A) = \sigma_2(A), \sigma_1(\ol A) = \sigma_2(\ol A)$).
The set of all the distinct combinations then builds the intersection type for the method.

\textbf{Example:}
\begin{lstlisting}
class Global{
  method1(a){
    a.add(this);
    return a.get();
  }
}
class List<A> {
  add(A item){...}
  A get() ...
}
\end{lstlisting}

The method \texttt{method1} would get the type $\set{ \exptype{List}{Object} \to \texttt{Object}
\ || \ \exptype{List}{Global} \to \texttt{Global}}$.
If FGJ would support overloaded methods this could be written as:
\begin{lstlisting}
class Global{
  Object method1(List<Object> a){
    a.add(this);
    return a.get();
  }
  String method1(List<Global> a){
    a.add(this);
    return a.get();
  }
}
class List<A> {
  add(A item){...}
  A get() ...
}
\end{lstlisting}

\section{Complexity}
\input{complexity}

\section{Examples}

\input{examples}

\textbf{Example 1}\\
The algorithm is able to infer the types of multiple classes under specific circumstances.
The individual classes must be given to him after one another.
This comes with the restriction, that the first class is correct on its own and does not use any other class.
The second class that gets compiled can use the first class and so on.

The following example shows how the algorithm infers and compiles multiple classes iteratively.
The class \texttt{Class1} is infered first.
It has only one method which is the identity function,
to which our algorithm allocates the type $\exptype{}{A}\ A \to A$.
The next class \texttt{Class2} is now able to use this generic method.
The blue colored types are inferred in the next iteration of our algorithm.

\begin{table}
\caption{Two classes as input. \texttt{Class1} is infered first (shown in {\color{red}red})}
\begin{tabular}{cc}
\begin{lstlisting}
class Class1 extends Object {
  Class1() { super(); }
  id(a){
    return a;
  }
}
class Class2 extends Class1 {
  Class2() { 
    super(); 
  }
  example(){
    return new Class1().id(this);
  }
}
\end{lstlisting}
&
\begin{lstlisting}
class Class1 extends Object {
  Class1() { super(); }
  (*@ \textcolor{red}{<A> A} @*) id((*@ \textcolor{red}{A} @*) a){
    return a;
  }
}
class Class2 extends Class1 {
  Class2() { 
    super(); 
  }
  (*@ \textcolor{blue}{Class1}@*) example(){
    return this.(*@\textcolor{blue}{<Class1>}@*)id(this);
  }
}
\end{lstlisting}
\end{tabular}
\end{table}

\textbf{Example 2}\\
When compiling a class like the following
we have to first split this class into two classes.
The \texttt{TwoMethods} class can be first split into the classes \texttt{Class1}
and \texttt{Class2} and after being processed by the type inference algorithm it can be assembled back together again.
This leads to a principal typing.
When using our type inference algorithm on the class \texttt{TwoMethods} alone
it would give the method \texttt{id} the type $\texttt{TwoMethods} \to \texttt{TwoMethods}$,
which is not the desired principal type.
\begin{lstlisting}
class TwoMethods extends Object {
  TwoMethods() { super(); }
  id(a){
    return a;
  }
  example(){
    return this.id(this);
  }
}
\end{lstlisting}

\textbf{Example 3}\\
%TODO: Ein Beispiel für die Unify-adapt Regel
FGJ allows subtype relations like the following:
\begin{lstlisting}
class Map<A,B> extends Object {
  Map<A,B>() { super(); }
}
class SpecialMap<A,B,C> extends Map<A,C> {
  SpecialMap<A,B,C>() { super(); }
}
\end{lstlisting}

If for example we have a method \texttt{method} like this:
\begin{lstlisting}
<X> void method(Map<X, String> map){
  ...
}
\end{lstlisting}
and call it:
\begin{lstlisting}
method(new SpecialMap<Object,Integer,String>());
\end{lstlisting}

Then the constraint $\exptype{SpecialMap}{Object,Integer,String} \lessdot \exptype{Map}{X,String}$
is generated by the \textbf{FJTYPE} algorithm.
This constraint will be processed by the \texttt{adapt} rule of the \textbf{Unify} algorithm.
Remember that $(\exptype{SpecialMap}{A,B,C} \olsub \exptype{Map}{A,C}) \in S_\leq$.
\begin{align*}
  Eq& \cup \exptype{SpecialMap}{Object,Integer,String} \lessdot \exptype{Map}{X,String} \\
  \cline{1-2} 
  Eq& \cup \set{\exptype{Map}{[ Object / A ][ Integer / B ][ String / C ](A,C)}
  \doteq \exptype{Map}{X,Integer}} \\
  \cline{1-2} 
  Eq& \cup \set{\exptype{Map}{Object,String}
  \doteq \exptype{C}{X, Integer}}
%Eq \cup \set{\theta_1 \doteq \lambda'_1 \ldo \theta_n \doteq \lambda'_n}
\end{align*}

After the \texttt{adapt} rule got applied we can already see that a correct unificator for this constraint would be
$\sigma(X) = \texttt{Object}$.

\textbf{Example 4 (Multiple type solutions):}
\begin{lstlisting}
class List<A> extends Object {
  List<A> add(A p){...}
}
class C1 extends Object {
  m1(ls){
    return ls.add(this);
  }
}
class C2 extends Object {
  m2(){
    return new C1().m1(new List<C1>());
  }
}
\end{lstlisting}
When compiling the class \texttt{C1} there are two possible method typings for \texttt{m1}.
One of it would 
\begin{lstlisting}
class List<A> extends Object {
  List<A> add(A p){...}
}
class C1 extends Object {
  List<Object> m1((*@\color{red}List<Object>@*) ls){
    return ls.add(this);
  }
}
class C2 extends Object {
  m2(){
    return new C1().m1((*@\color{red}new List<C1>()@*));
  }
}
\end{lstlisting}
\texttt{List<Object>} would be a correct type for the parameter \texttt{ls}.
The call \texttt{ls.add(this)} still works because the type of \texttt{this} is a subtype of \texttt{Object}.
But then the method \texttt{m2} will be incorrect when compiling the class \texttt{C2}.
Our algorithm has to backtrack to the class \texttt{C1} and use the other possible typing.
The following would be the correct solution with \texttt{List<C1>} as the type for \texttt{ls}.
\begin{lstlisting}
class List<A> extends Object {
  List<A> add(A p){...}
}
class C1 extends Object {
  List<C1> m1((*@\color{green}List<C1>@*) ls){
    return ls.add(this);
  }
}
class C2 extends Object {
  List<C1> m2(){
    return new C1().m1((*@\color{green}new List<C1>()@*));
  }
}
\end{lstlisting}

\textbf{Example 5} (for global type inference)
\begin{lstlisting}

\end{lstlisting}

\section{Assessment}
\label{sec:assessment}

\begin{itemize}
\item NP-hard \todo[inline]{Show NP-completeness!}
\item cannot infer all possible generic methods
\item features that need to be addressed to make it practical (e.g.,
  what's necessary to move from FGJ to full Java: overloading,
  imperative, )
\end{itemize}

Java has some features which make global type inference hard:
\begin{itemize}
\item subtyping and overloading combined with a nominal type system;
  we show NP-hardness even without overloading
  \todo[inline]{correct?}
\item mutable local variables and mutable object state,
\item polymorphic recursion in method calls
\item Inside a Java method it is possible to call every other declared Java method
  \todo[inline]{meaning? The letrec-rule works on the fact that in a let statement:
  \lstinline{let x = e in e2} the expression \texttt{e} is not able to use \texttt{x}}
\item methods can have side effects.
\end{itemize}


For Featherweight Generic Java it is easier to decide because there is no state and therefore no wildcard types.
Also we exclude polymorphic recursion.

% Example for local type inference in Java:
% \begin{lstlisting}[language=java]
% // Java 8 code:
% class Local {
%   // type inference puts in "ArrayList<String>()"
%   List<String> field = new ArrayList<>();
% }
% \end{lstlisting}
% \todo[inline]{Is this a drawback for LVTI? Does GTI put
%   \lstinline{List<String>} or \lstinline{Map} in the
%   \lstinline{outerMap} example?}

\section{Related Work}
\input{relatedWork}

\section{Conclusions}
\label{sec:conclusions}


\bibliographystyle{splncs04}
\bibliography{peter,martin}

\end{document}
\endinput
%%
%% End of file `TIforGFJ.tex'.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
