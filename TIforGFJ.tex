%%
%% This is file `sample-acmsmall-submission.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `acmsmall-submission')
%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-acmsmall-submission.tex.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%% The first command in your LaTeX source must be the \documentclass command.
\documentclass[acmsmall,screen,review]{acmart}

\usepackage{prolog}

%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmcopyright}
\copyrightyear{2018}
\acmYear{2018}
\acmDOI{10.1145/1122445.1122456}


%%
%% These commands are for a JOURNAL article.
\acmJournal{JACM}
\acmVolume{37}
\acmNumber{4}
\acmArticle{111}
\acmMonth{8}

%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}

%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Type inference for Generic Featherweight Java}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Andreas Stadelmeier}
\affiliation{%
  \institution{DHBW Stuttgart, Campus Horb}
  \streetaddress{Tannenweg 4}
  \city{Tübingen}
  \country{Germany}}
\email{a.stadelmeier@hb.dhbw-stuttgart.de}


%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
\renewcommand{\shortauthors}{Stadlmeier, Plümicke, Thiemann}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
  Type inference for Generic Featherweight Java
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
\begin{CCSXML}
<ccs2012>
 <concept>
  <concept_id>10010520.10010553.10010562</concept_id>
  <concept_desc>Computer systems organization~Embedded systems</concept_desc>
  <concept_significance>500</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010575.10010755</concept_id>
  <concept_desc>Computer systems organization~Redundancy</concept_desc>
  <concept_significance>300</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010553.10010554</concept_id>
  <concept_desc>Computer systems organization~Robotics</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
 <concept>
  <concept_id>10003033.10003083.10003095</concept_id>
  <concept_desc>Networks~Network reliability</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Computer systems organization~Embedded systems}
\ccsdesc[300]{Computer systems organization~Redundancy}
\ccsdesc{Computer systems organization~Robotics}
\ccsdesc[100]{Networks~Network reliability}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{typeinference, java, compiler}


%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}

\section{Preliminaries}

\subsection{Input assumptions}
% No overloaded methods
% No Or-Constraints
The input is a GFJ program lacking the type assignments for method parameters and method return types.


The Typeless Generic Featherweight Java (TGFJ) syntax is different in that from normal Generic Featherweight Java (GFJ) that it is possible
to omit any type annotation.%, except the ones for casts and \texttt{new} calls.
We declare the syntax for TGFJ as follows:

\begin{align*}
  T ::=& X \, | \, N \\
  N ::=& \exptype{C}{\ol{T}}\\
  L ::=& \mathtt{class } \ \exptype{C}{\ol{X} \triangleleft \ol{N}} \ \triangleleft \ N \{ \overline{T} \ \overline{f}; \, K \, \overline{M} \} \\
  K ::=& C(\overline{T} \ \overline{f})\{\mathtt{super}(\overline{f}); \ \mathtt{this}.\overline{f}=\overline{f};\} \\
  %M ::=& \exptype{}{\ol{X} \triangleleft \ol{X}}\ T \ \mathtt{m}(\overline{T} \, \overline{x})\{ \mathtt{ return }\ e; \} \\
  M ::=& \mathtt{m}(\overline{x})\{ \mathtt{ return }\ e; \} \\
  e ::=& \mathtt{this} \, | \, x \, | \, e.f \, | \, e.\mathtt{m}(\overline{e}) \, | \, \mathtt{new }\ C(\overline{e}) \, | \, (C) e
  %M ::=& T \ \mathtt{m}(\overline{T} \, \overline{x})\{ \mathtt{ return }\ e; \} \\
  %e ::=& \mathtt{this} \, | \, x \, | \, e.f \, | \, e.\exptype{\mathtt{m}}{\ol{T}}(\overline{e}) \, | \, \mathtt{new }\ C(\overline{e}) \, | \, (C) e \\
\end{align*}

All type annotations in our TGFJ language can be omitted ($T = \epsilon$).
The only exception are fields which must be given a concrete type.

Another difference to the syntax of FJ is that we added the special variable \texttt{this} to the syntax.
FJ treats \texttt{this} as a normal variable
but our algorithm treats it as a special variable which always has a predetermined type;
the type of the class it is used in.

We assume every method name is only used once in the input program.

Type inference for polymorphic recursion is undecidable.
Therefore we have to alter the GFJ typing rules to exclude polymorphic recursion in method calls:
\begin{enumerate}
    \item The \texttt{MT-CLASS} rule is removed.
    \item We change the \texttt{GT-METHOD} rule:
GT-METHOD:
\begin{align*}
\ddfrac{\begin{array}{c}
\triangle \vdash \ol{X} <: \ol{N}, \ol{Y} <: \ol{P}  \quad \quad 
\triangle \vdash \ol{T}, T \ \texttt{ok} \\
\triangle ; \ol{x}:\ol{T}, this : \exptype{C}{\ol{X}} \vdash e_0 : S \quad \quad
\triangle \vdash S <: T \\
\texttt{class}\ \exptype{C}{\ol{X} \triangleleft \ol{N}} \triangleleft N \{ \ldots \} \quad \quad
%\textit{override}(m, N, \exptype{}{\ol{Y} \triangleleft \ol{P}} \ol{T} \to T)
\textit{mtype}(m, \exptype{C}{\ol{X}}) := \ol{T} \to T \\
%\textit{override}(m, N,)
\end{array}}{
%{\exptype{}{\ol{Y} \triangleleft \ol{P}}\ T \ m(\ol{T}\ \ol{x}) \{ \texttt{return} \ e_0; \} \ \texttt{OK IN}\ \exptype{C}{\ol{X} \triangleleft \ol{N}}}
\textit{mtype}(m, \exptype{C}{\ol{Z}}) = [\ol{Z} / \ol{X}](\exptype{}{\ol{Y}} \ol{T} \to T)
}
\end{align*}
\end{enumerate}

\subsection{Principal Type}
%TODO: Subtype definition:

%In our input set we exclude method overloading.
%Also every method name has to be unique.
%These assumptions allows us to make the following definition of a principal type:

A type-scheme for a declaration is a principal type-scheme,
if any other type-scheme for the declaration is a subtype of a generic instance
of the type-scheme.

Additionally we define the subtype relation of methods as follows:
\begin{align*}
\ddfrac{
\ol{T} \ \leq^* \ \ol{U} \quad \quad U \ \leq^* \ T
}{
\ol{T} \to T \ \leq^* \ \ol{U} \to U
}
\end{align*}

%\begin{theoremAndi}
%  \label{theo:uniquePrincipalType}
%  \textbf{There is one unique principal type for any set of types}
%\end{theoremAndi}

%what about: c<A,Int>, c<Int, A> which is principal type?

\begin{theoremAndi}
  \label{theo:uniquePrincipalType}
  \textbf{There is one unique principal type for every method}
\end{theoremAndi}
Proof:
%We excluded polymorphic recursion
%Every expression $e$ in GFJ has a definitive type.
%%There is only one possible type our type inference algorithm can apply to any expression $e$.
%We will show this for every kind of expression:
%\begin{description}
  %\item[NEW] \texttt{new} can only have one type according to the \texttt{GT-NEW} type rule.
  %\item[Field access] A field access $e.f$ can only have one type according to the \texttt{GT-FIELD} type rule.
  %This also applies to our typeless GFJ version, because every field name has to be unique.
  %\item[Method call] We assume method names are also unique and cannot be overloaded.
  %Due to this assumption and the changed \texttt{GT-METHOD} rule a method type of a method \texttt{m}
  %is: $\textit{mtype(m, N) = \ol{T} \to T}$.
  %%The type of the respective method call $e.m(\ldots)$ is defined by \texttt{GT-INVK} as $T$.
  %%The return type $T$ of the method \texttt{m} is unique, because the 
%\end{description}

We exclude polymorphic recursion, remove overloading and assume every method and field name to be unique.
Now every method $T\ \texttt{m}(\ol{T}\ \ol{x})\{\ \texttt{return}\ e;\ \}$has one principal type.
This is when its return type $T$ is the same type as its return expression $e$.
For the parameter types $\ol{T}$ the principal type is chosen.

A method \texttt{m} can have multiple possible types due to the fact that GFJ has subtypes.
Example:
\begin{lstlisting}
class C1 {
  C1 f;
}
class C2 extends C1{
  m(x){
    return x.f;
  }
}
\end{lstlisting}
The method \texttt{m} can either have the type \texttt{C1 m(C1 x)}
or \texttt{C1 m(C2 x)}.


%The principal type is unique
%No overloading, therefore no types int -> int, byte -> byte

\section{Type inference algorithm}
In this chapter we present our type inference algorithm.
The algorithm is split into following parts:

\begin{enumerate}
\item Create assumptions and subtype relation
\item Constraint generation with \textbf{GFJTYPE}
\item Unification of those constraints
\item Set in a type solution
\end{enumerate}


\subsection{Generate Assumptions}
% Every empty Type T in the input is assigned a type variable.
% Assumptions saves every field, method and the class subtype relation

%Generate subtype relationships:

Generating assumptions consists of two parts.
At first we add type variables to the untyped class.
The second part generates the assumption set.
This is the same algorithm for the already typed classes as for the 
new untyped class, which is now equipped with type variables.

\begin{enumerate}
\item Every missing type in the input class gets assigned a fresh type variable.
For methods:
\begin{align*}
  \ddfrac{
  m(\ol{x}) \{ \ldots \} \quad \quad A \cup \ol{A} \ \text{are fresh type variables}
  }{
  A m(\ol{A}\ \ol{x}) \{ \ldots \}
  }
  \end{align*}
  For fields:
\begin{align*}
  \ddfrac{
  \texttt{class}\ \exptype{C}{\ol{X}} \{ \ol{f]}; \quad \ldots \} \quad \quad \ol{F} \ \text{are fresh type variables}
  }{
    \texttt{class}\ \exptype{C}{\ol{X}} \{ \ol{F} \ \ol{f]}; \quad \ldots \}
  }
\end{align*}
\item We define the two functions $\textit{ftype}_\textit{Ass}$ and $\textit{mtype}_\textit{Ass}$.
Both functions return a set of all types for a method \texttt{m} or a field \texttt{f}.
This is due to the fact that there can be multiple methods and fields with the same name.
\begin{align*}
  %TODO: fresh type variables for generic variables:
  \ddfrac{
    class\ \exptype{C}{\ol{X} \triangleleft \ol{N}}\ \{\ \ol{N}\ \ol{f};\ K\ \ol{M}\ \} \quad \quad
    \exptype{}{\ol{Y}}\ U\ \texttt{m}(\ol{U}\ \ol{x}) \{ \ldots \} \in \ol{M}
  }{
    \textit{mtype}_\textit{Ass}(\texttt{m}) = \exptype{C}{\ol{X} \triangleleft \ol{N}} \to \exptype{}{\ol{Y}} (\ol{U} \to U )
  }
\end{align*}
\begin{align*}
  \ddfrac{
    class\ \exptype{C}{\ol{X} \triangleleft \ol{N}}\ \{\ \ol{T}\ \ol{f};\ K\ \ol{M}\ \} \quad \quad
    T\ \texttt{f} \in \ol{f}
  }{
    \textit{ftype}_\textit{Ass}(\texttt{f}) = \exptype{C}{\ol{X} \triangleleft \ol{N}} \to T
  }
\end{align*}
\item We do not include casts in the syntax and therefore remove the \texttt{GT-UCAST} and \texttt{GT-DCAST} typing rules.
\end{enumerate}


\subsection{GFJTYPE}

The algorithm \textbf{GFJTYPE} is given as follows:

\textbf{FJTYPE}:
$\texttt{TypeAssumptions} \times
\texttt{Class} \rightarrow \texttt{Constraints}\\
 \begin{array}{@{}l@{}l@{}l}
 \textbf{FJT}&\textbf{Y} & \textbf{PE}(Ass, \mathtt{class } \ C \ \mathtt{ extends } \ D \{ \overline{T} \ \overline{f}; \, K \, \overline{M} \}) =\\
& \multicolumn{2}{@{}l@{}}{ \{ \ \textbf{TYPEMethod}(\textit{Ass} \cup \{ \mathtt{this} : C \}, m_i) \quad | \quad m_i \in \overline{M} \ \} }\\ 
\end{array}$

The \textbf{FJTYPE} function gets called for every class in the input.
This function accumulates all the constraints generated from calling the
\textbf{TYPEMethod} function for each method declared in the given class.

$\textbf{TYPEMethod}:\texttt{TypeAssumptions} \times
\texttt{Method} \rightarrow \texttt{Constraints}\\
\begin{array}{@{}l@{}l@{}l}
\textbf{TY}& \textbf{PE} & \textbf{Method} (Ass, T_r \ \mathtt{m}(\overline{T} \, \overline{x})\{ \mathtt{ return }\ e; \}) =\\
& \textbf{let}
& Ass_m = Ass \cup \{ \overline{T} : \overline{x} \}\\
& & \ul{(e:rty, ConS)} = \textbf{TYPEExpr}(Ass_m, e)\\
& \mathbf{in}
& (ConS \cup (rty \lessdot T_r))\\
\end{array}
$

The \textbf{TYPEMethod} function for methods just calls the \textbf{TYPEExpr} function with the
return expression. It is significant to note that it adds the assumptions for the method parameters to the global assumptions before passing them to \textbf{TYPEExpr}.
%and the global assumptions plus the assumptions for the method parameters.

\smallskip

In the following we define the \textbf{TYPEExpr} function for every possible expression:

\smallskip

$\textbf{TYPEExpr}:\texttt{TypeAssumptions} \times
\texttt{Expression} \rightarrow \texttt{Type} \times \texttt{Constraints}\\
\begin{array}{@{}l@{}l}
\textbf{TY} \textbf{PE} & \textbf{Expr} (Ass, \mathtt{this}) = (t , \{\})\\
& \textbf{with } (\mathtt{this} : t) \in Ass 
\end{array}
$
\smallskip
$\begin{array}{@{}l@{}l}
\textbf{TY} \textbf{PE} & \textbf{Expr} (Ass,x) = (t , \{\})\\
& \textbf{with } (x : t) \in Ass 
\end{array}
$

\smallskip

$\begin{array}{@{}l@{}l@{}l}
\textbf{TY}& \textbf{PE} & \textbf{Expr} (Ass, e.f ) = \\
& \textbf{let} % \\
% &
& (rty, ConS) = \textbf{TYPEExpr}(Ass, e),\\
& & \textbf{fresh} = \text{a mapping from each variable in}\ \ol{X} \ \text{to a fresh type variable},\\
& & Ass_{f} = \textit{ftype}_{Ass}(f) = \exptype{C}{\ol{X} \triangleleft \ol{N}} \to T \\
& & Cons_{f} = \{\ rty \doteq \exptype{C}{\textbf{fresh}(\ol{X})}, a \doteq \textbf{fresh}(T)\},\\
%& & OrCons = \{ \{ rty \doteq cl, a \doteq t_f \} \ | \ cl.f : t_f \in Ass \},\\
& \mathbf{in}% \\
% &
& (a, ConS \cup Cons_{f})\\
& & \mathit{where\ } a \mathit{\ is\ a\ fresh\
  type\ variable}\\ 
\end{array}
$

\smallskip

$\begin{array}{@{}l@{}l@{}l}
\textbf{TY}& \textbf{PE} & \textbf{Expr} (Ass, e_r.\mathtt{m}(\overline{e}) ) = \\
& \textbf{let} % \\
% &
& (rty, ConS) = \textbf{TYPEExpr}(Ass, e_r),\\
& & \forall e_i \in \overline{e} : (pt_i, ConS_i) = \textbf{TYPEExpr}(Ass, e_i)  ,\\
& & \textbf{fresh} = \text{a mapping from each variable in}\ \ol{X} \ \text{to a fresh type variable},\\
& & Ass_{m} = \textit{mtype}_{Ass}(m) = \exptype{C}{\ol{X} \triangleleft \ol{N}} \to \exptype{}{\ol{Y}} (\ol{T} \to T) \\
& & \begin{array}{@{}l@{}l}
        Cons_{m} = \{\ & rty \doteq \exptype{C}{\textbf{fresh}(\ol{X})}, a \doteq \textbf{fresh}(T),\\
                    & \bigcup_{T_i \in \overline{T}} (pt_i \lessdot \textbf{fresh}(T_i)) \} %, \textbf{fresh}(\ol{X}) \lessdot \textbf{fresh}(\ol{N})\},\\
    \end{array}\\
& \mathbf{in}% \\
% &
& (a, ConS \cup Cons_{m} \cup \bigcup_i ConS_i))\\
& & \text{where\ } a \text{\ is\ a\ fresh\
  type\ variable}\\ 
\end{array}
$

\smallskip

$\begin{array}{@{}l@{}l@{}l}
\textbf{TY}& \textbf{PE} & \textbf{Expr} (Ass, \mathtt{new }\ N(\overline{e}) ) = \\
& \textbf{let} % \\
& \forall e_i \in \overline{e} : (pt_i, ConS_i) = \textbf{TYPEExpr}(Ass, e_i)  ,\\
& & Cons = \{ \bigcup_{T_i \in \overline{T}} (pt_i \lessdot T_i) \ | \ \mathtt{constructor }\ \exptype{C}{\ol{X}}(\overline{T} \overline{x}) \in Ass \},\\
& \mathbf{in}% \\
% &
& (C, ConS \cup \bigcup_i ConS_i)\\
\end{array}
$


\subsection{Completeness}
Theorem: The Unify algorithm is complete
Theorem: \textbf{GFJTYPE} generates the principal type
Proof: The \textbf{Unify} algorithm is complete, so the principal type is included in the solution set.
We only have to choose the principal type out of those solutions.

All types that are possible under the GFJ typing rules, plus our additional assumptions,
also comply with the generated constraints.

We match every generated constraint with the respective type rule to show completeness of our \textbf{GFJTYPE} algorithm.
This shows that none of the generated constraints remove a type which otherwise would be possible under the GFJ typing rules.
The constraints are generated on expression statements.
We now compare the constraints for each expression with the appropriate type rule from GFJ:
\begin{description}
  \item [this]
  has always the type of the surrounding class and generates no constraints.
  \item [Local var]
  No constraints are generated.
  \item[Method invocation]
By direct comparison we show that each of the generated constraints do not apply more restrictions than the \texttt{GT-INVK} rule.
The \texttt{GT-INVK} rule states the condition $\textit{mtype}(m, \textit{bound}_\triangle(T_0)) = \exptype{}{\ol{Y}}\ \ol{U} \to U$.
In our version of typeless GFJ every method name is unique
and there is only one class with that particular method.
The constraint $rty \lessdot \exptype{C}{\textbf{fresh}(\ol{X})}$ assures that the type of the expression $e_0$ contains the method \texttt{m}.

\begin{tabular}{l|l}
  \textbf{GFJ Type rule} & \textbf{Constraints} \\
  $\triangle; \Gamma \vdash e_o : T_0$ & $(rty, ConS) = \textbf{TYPEExpr}(Ass, e_r)$\\ 
  $\quad \textit{mtype}(m, \textit{bound}_\triangle(T_0)) = \exptype{}{\ol{Y}}\ \ol{U} \to U$ & $rty \lessdot \exptype{C}{\textbf{fresh}(\ol{X})}$ \\
 %$\textit{mtype}(m, \textit{bound}_\triangle(T_0)) = \ol{U} \to U$ & $rty \doteq cl$\\
 $\triangle; \Gamma \vdash \ol{e} : \ol{S}$ & $\forall e_i \in \overline{e} : (pt_i, ConS_i) = \textbf{TYPEExpr}(Ass, e_i)$\\
 $\triangle \vdash \ol{S} <: \ol{U}$ & $ \bigcup_{T_i \in \overline{T}} (pt_i \lessdot \textbf{fresh}(T_i))$\\
 $\triangle; \Gamma \vdash \mathtt{e_0.m(\overline{e}) : U }$ & $a \doteq \textbf{fresh}(T)$ \\
\end{tabular}

\textit{Note}: The \textbf{TYPEExpr} function only generates constraints which apply to our assumption.
 \item[Field access]
Mostly the same as method invocation.
Fieldnames by default are unique in the GFJ language.

 \begin{tabular}{l|l}
   \textbf{GFJ Type rule} & \textbf{Constraints} \\
   $\Gamma \vdash e_0:T_0$ & $(rty, ConS) = \textbf{TYPEExpr}(Ass, e_r)$\\ 
   $\quad \mathit{fields}(\mathit{bound}_\triangle(T_0)) = \overline{T} \ \overline{f}$ & $rty \doteq \exptype{C}{\textbf{fresh}(\ol{X})}$ \\
  %$\textit{mtype}(m, \textit{bound}_\triangle(T_0)) = \ol{U} \to U$ & $rty \doteq cl$\\
  $\triangle; \Gamma \vdash \ol{e} : \ol{S}$ & $\forall e_i \in \overline{e} : (pt_i, ConS_i) = \textbf{TYPEExpr}(Ass, e_i)$\\
  $\triangle \vdash \ol{S} <: \ol{U}$ & $ \bigcup_{T_i \in \overline{T}} (pt_i \lessdot \textbf{fresh}(T_i))$\\
  $\triangle; \Gamma \vdash \mathtt{e_0.m(\overline{e}) : U }$ & $a \doteq \textbf{fresh}(T)$ \\
 \end{tabular}
 \item[Constructor]

\begin{tabular}{l|l}
  $\triangle; \Gamma \vdash \ol{e} : \ol{S}$ & $\forall e_i \in \overline{e} : (pt_i, ConS_i) = \textbf{TYPEExpr}(Ass, e_i)$\\
  $\triangle \vdash \ol{S} <: \ol{T}$ & $\bigcup_{T_i \in \overline{T}} (pt_i \lessdot T_i)$
\end{tabular}
  
\end{description}

\end{document}
\endinput
%%
%% End of file `TIforGFJ.tex'.
