\documentclass[a4paper,USenglish,cleveref, autoref, thm-restate, anonymous]{lipics-v2021}
%This is a template for producing LIPIcs articles. 
%See lipics-v2021-authors-guidelines.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling autoref support, use "autoref"
%for anonymousing the authors (e.g. for double-blind review), add "anonymous"
%for enabling thm-restate support, use "thm-restate"
%for enabling a two-column layout for the author/affilation part (only applicable for > 6 authors), use "authorcolumns"
%for producing a PDF according the PDF/A standard, add "pdfa"

\pdfoutput=1 %uncomment to ensure pdflatex processing (mandatatory e.g. to submit to arXiv)
%\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the mandatory bibstyle

\title{Global Type Inference for Featherweight Generic Java} %TODO Please add

% \titlerunning{Global Type Inference for Featherweight Generic Java} %TODO optional, please use if title is longer than one line

\author{Andreas Stadelmeier}{DHBW Stuttgart, Campus Horb, Germany}{a.stadelmeier@hb.dhbw-stuttgart.de}{}{}%TODO mandatory, please use full name; only 1 author per \author macro; first two parameters are mandatory, other parameters can be empty. Please provide at least the name of the affiliation and the country. The full address is optional. Use additional curly braces to indicate the correct name splitting when the last name consists of multiple name parts.

\author{Martin Plümicke}{DHBW Stuttgart, Campus Horb, Germany}{pl@dhbw.de}{}{}

\author{Peter Thiemann}{Universität Freiburg, Institut für Informatik, Germany}{thiemann@informatik.uni-freiburg.de}{}{}

\authorrunning{A. Stadelmeier and M. Plümicke and P. Thiemann} %TODO mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

\Copyright{Andreas Stadelmeier and Martin Plümicke and Peter Thiemann} %TODO mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

   
\ccsdesc[500]{Software and its engineering~Language features}
%\ccsdesc[300]{Software and its engineering~Syntax}

\keywords{type inference, Java, subtyping, generics} %TODO mandatory; please add comma-separated list of keywords

\category{} %optional, e.g. invited paper

\relatedversion{} %optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversiondetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93]{Classification (e.g. Full Version, Extended Version, Previous Version}{URL to related version} %linktext and cite are optional

%\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...
%\supplementdetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93, subcategory={Description, Subcategory}, swhid={Software Heritage Identifier}]{General Classification (e.g. Software, Dataset, Model, ...)}{URL to related version} %linktext, cite, and subcategory are optional

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

\acknowledgements{}%optional

%\nolinenumbers %uncomment to disable line numbering



%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{cite}
\usepackage{todonotes} % [disable]
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{subcaption}
\usepackage{prftree}
\usepackage{tabularx}
\usepackage{multicol}
\input{prolog}


\begin{document}

\maketitle

\begin{abstract}
  Type Inference for Featherweight Generic Java
\end{abstract}



\input{introduction}

\input{motivation}

\input{preliminaries}

\section{Type inference algorithm}
\label{sec:type-infer-algor}
This section presents our type inference algorithm.
The algorithm is given method assumptions $\mv\Pi$ and applied to a
single class $\mv L$ at a time:
\begin{gather*}
\fjtypeinference(\mv{\Pi}, \texttt{class}\ \exptype{C}{\ol{X}
\triangleleft \ol{N}} \triangleleft \type{N}\ \{ \ldots \}) = \\
\quad \quad \begin{array}[t]{rll}
  \textbf{let}\ 
  (\overline{\methodAssumption}, \consSet) &= \fjtype{}(\mv{\Pi}, \texttt{class}\ \exptype{C}{\ol{X}
  \triangleleft \ol{N}} \triangleleft \type{N}\ \{ \ldots \}) &
                                                                     \text{// constraint generation}\\
  \overline{(\sigma,  \ol{Y} \triangleleft \ol{P})}\commentarymark &= \unify{}(\consSet,\, \ol{X} <: \ol{N}) & \text{// constraint solving}\\
  %TODO: Describe whole algorithm (Insert types, try out every unify solution by backtracking (describe it as Non Deterministic algorithm))
\end{array}\\
\textbf{in}\ \mtypeEnvironment \cup
\set{(\exptype{C}{\ol{X} \triangleleft \ol{N}}.\mv{m} : \exptype{}{\ol{Y} \triangleleft \ol{P}}\ \ol{\sigma(\tv{a})} \to \sigma(\tv{a})) \ |\ (\exptype{C}{\ol{X} \triangleleft \ol{N}}.\mv{m} : \ol{\tv{a}} \to \tv{a}) \in \overline{\methodAssumption}}
% \fjtypeInsert(\overline{\methodAssumption}, (\sigma, \unifyGenerics{}) )
\end{gather*}
\commentary{$^*$Hier muss doch overline stehen, weil Unify mehrere Loesungen hat}

The overall algorithm is nondeterministic. There may be multiple solutions for a constraint set and a local solution for class $\mv C$ may not
be compatible with the constraints generated for a subsequent class. In this case, we have to backtrack to $\mv C$ and proceed to the next
local solution; if thats fail we have to backtrack further to an earlier class.

%This set inherits the principal type solution.
%The last step simplifies the calculated solutions and only inserts the principal typing.
%The last step chooses the principal type out of those possibilities.

\if0
The solver \unify{} returns a set of all possible type solutions for the currently processed class.
We generate the $\mv{\Pi}$ environment used in the next iteration of the \fjtype{} algorithm as follows:
\begin{align*}
  \fjtypeInsert{}(\overline{\methodAssumption}, (\sigma, \unifyGenerics{})) & = \begin{array}{l}
    \set{(\exptype{C}{\ol{X} \triangleleft \ol{N}}.\mv{m} : \exptype{}{\unifyGenerics{}}\ \ol{\sigma(\tv{a})} \to \sigma(\tv{a})) \ |\ (\exptype{C}{\ol{X} \triangleleft \ol{N}}.\mv{m} : \ol{\tv{a}} \to \tv{a}) \in \overline{\methodAssumption}}
  \end{array} 
\end{align*}
Here $\overline{\methodAssumption}$ are the newly generated method assumptions of the \fjtype{} function.
$(\sigma, \unifyGenerics{})$ is one of the solutions returned by \unify{}.
\fi

\subsection{Type inference for a program }
\label{sec:proc-mult-class}

\commentarymargintext{Type inference processes a program one class at a time.
To do so, it must be possible to order the classes such that early
classes never call methods in later classes.
As an example, Figure~\ref{fig:invalidinput} shows a program that is
acceptable in FGJ, but rejected by \TFGJ because the methods \mv{m1}
and \mv{m2} are mutually recursive across class boundaries. There is
no order in which classes \mv{C1} and \mv{C2} can be processed.

Figure~\ref{fig:correctinput} contains a program
acceptable to both \TFGJ and FGJ because the mutual recursion of
methods \mv{m1} and \mv{m2} is taking place inside class \mv{D2}. As
\mv{D2} invokes method \mv{m} of \mv{D1}, type inference must process
\mv{D1} before \mv{D2}, which corresponds to the constraints imposed
by the typing of \TFGJ in Section~\ref{chapter:type-rules}.}
{Das gehört doch zu den Typregeln oder willst Du es hier nochals wiederholen?}


\begin{figure}[tp]
    \centering
    \begin{minipage}{.48\textwidth}
\begin{lstlisting}[style=tfgj]
class C1 extends Object {
  m1(){ return new C2().m2(); }
}
class C2 extends Object{
  m2(){ return new C1().m1(); }
}
\end{lstlisting}
      \caption{Invalid \TFGJ program}
      \label{fig:invalidinput}
    \end{minipage}%
  ~$\left|~
    \begin{minipage}{.48\textwidth}
\begin{lstlisting}[style=tfgj]
class D1 extends Object {
  m(){ return ...; }
}
class D2 extends Object{
  m1(x){ return new D2().m2(); }
  m2( ){ return new D2().m1(
                new D1().m()); }
}
\end{lstlisting}
      \caption{Valid \TFGJ program}
      \label{fig:correctinput}
    \end{minipage}\right.$
\end{figure}

We obtain a viable order for processing the class declarations by
computing an approximate call graph based solely on method names. That
is, if method \mv{m} is used in \mv{C3} and defined both in \mv{C1}
and \mv{C2}, then \mv{C1} and \mv{C2} must both be processed before
\mv{C3}. In such a case, the use of \mv{m} might be ambiguous so that
type inference for class \mv{C3} proposes more than one solution. Global
type inference attempts to extend each partial solution to a solution for the
whole program and backtracks if that fails.

\subsection{Constraint generation}
\label{sec:fjtype}
\begin{figure}[tp]
  \begin{align*}
    % Type
    \itype{T}, \itype{U} &::= \tv{a} \mid \mv{T} && \text{type variable or type}\\
    \itype{N} &::= \exptype{C}{\il{T}} && \text{class type with type variables} \\
    % Constraints
    \simpleCons &::= \itype{T} \lessdot \itype{U} \mid \itype{T} \doteq \itype{U} && \text{simple constraint: subtype or equality}\\
    \orCons{} &::= \set{\set{\overline{\simpleCons_1}}, \ldots, \set{\overline{\simpleCons_n}}} && \text{or-constraint}\\
    \constraint &::= \simpleCons \mid \orCons && \text{constraint}\\
    \consSet &::= \set{\constraints} && \text{constraint set}\\
    % Method assumptions:
    \methodAssumption &::= \exptype{C}{\ol{X} \triangleleft \ol{N}}.\texttt{m} : \exptype{}{\ol{Y}
                        \triangleleft \ol{P}}\ \ol{\itype{T}} \to \itype{T}  &&
                                                                \text{method
                                                                type assumption}\\
    \localVarAssumption &::= \texttt{x} : \itype{T} && \text{parameter
                                                       assumption}\\
    \mtypeEnvironment & ::= \mv\Pi \cup \overline{\methodAssumption} &
                & \text{method type environment} \\
    \typeAssumptionsSymbol &::= ({\mtypeEnvironment} ; \overline{\localVarAssumption}) 
  \end{align*}
  \caption{Syntax of constraints and type assumptions}
  \label{fig:syntax-constraints}
\end{figure}

Figure~\ref{fig:syntax-constraints} defines the syntax of
constraints. We extend types with \emph{type variables} ranged over by
$\tv{a}$. A constraint is either a simple constraint $\simpleCons$ or
an or-constraint $\orCons$, which is a set of sets of simple
constraints. An or-constraint represents different alternatives,
similar to an intersection type, and
cannot be nested. The output of constraint generation is a set of
constraints $\consSet$, which can hold simple constraints as well as or-constraints.
% \begin{description}
%   \item[Constraint] A constraint (\constraint) consists of two types or type variables and an operator.
%   The operator can either be a $\doteq$ (same type) or $\lessdot$ (subtype).
%   Example: $(a \lessdot \mathtt{Object})$, means that the type variable $a$ should be a subtype of \texttt{Object}.
%   \item[Or-Constraint] An Or-Constraint (\orCons{}) consists out of multiple sets of constraints ($c$).
%   It is not possible to have \orCons{} nested inside another \orCons{}.\\
%   For example $\orCons{}(\{ \ \{ (a \lessdot b), (a \leq \mathtt{Object}) \} \ , \ \{ (a \lessdot b)\} \ \})$
%   is an Or-Constraint consisting of two sets of constraints.
%   \item[Constraint-Set] The \fjtype algorithm returns a Constraint-Set (\consSet).
%   It is able to hold a mix of normal Constraints and Or-Constraints.
%   \end{description}




%The \fjtype{} algorithm produces two kinds of constraints.
% Before the algorithm starts we equip every untyped method with type variables.
% Every method parameter gets a unique type variable as a type aswell as every method gets a unique type variable as a return type.
% After our algorithm found a correct typisation we replace the type variables with the inferred types and generate a GFJ program.


Figure~\ref{fig:constraints-for-classes} contains the algorithm
{\fjtype} to generate constraints for classes. Its input
consists of the method type environment $\mv\Pi$ of the previously
checked classes. It distinguishes between overriding and
non-overriding method definitions. The former are recognized by
successful lookup of their type using \textit{mtype}. We set up the
method type assumptions accordingly and generate a constraint between
the inferred return type $\tv{a}_{\mv m}$ and the one of the
overridden method to allow for covariant overriding.
Constraints for the latter methods are generated with all fresh
variables for the argument and result types.

\begin{figure}[tp]
  \begin{gather*}
    % \fjtype : \typeAssumptionsSymbol \times \texttt{L} \rightarrow \ol{\constraint}\\
    \begin{array}{@{}l@{}l}
      \fjtype & ({\mv{\Pi}}, \mathtt{class } \ \exptype{C}{\ol{X} \triangleleft \ol{N}} \ \mathtt{ extends } \ \mathtt{N \{ \overline{T} \ \overline{f}; \, K \, \overline{M} \}}) =\\
              & \begin{array}{ll@{}l}
                  \textbf{let} & \overline{\tv{a}}_{\mv m} \text{ be fresh type variables
                                 for each }\mv{m}\in\ol{M} \\
                               & \ol{\methodAssumption}_o = \set{\exptype{C}{\ol{X} \triangleleft \ol{N}}.\mv{m} :
                                 \exptype{}{\ol{Y} \triangleleft \ol{P}}\ \ol{T} \to \tv{a}_{\mv m} \mid \mv{m} \in \ol{M},
                                 \textit{mtype}(\mv{m}, \type{N}, \mv\Pi) = \exptype{}{\ol{Y} \triangleleft \ol{P}} \ol{\type{T}} \to \type{T}}\\
                               & \consSet_o = \set{\tv{a}_{\mv m} \lessdot \type{T} \ |\ \texttt{m} \in \ol{M}, 
                                 \textit{mtype}(\mv{m}, \mv{N}, \mv\Pi) = \exptype{}{\ol{Y} \triangleleft \ol{P}} \ol{\type{T}} \to \type{T}}\\
                               & \ol{\methodAssumption}' = 
                                 \set{ (\exptype{C}{\ol{X} \triangleleft \ol{N}}.\mv{m} : \ol{\tv{a}} \to \tv{a}_{\mv
                                 m}) \mid \mv{m} \in \ol{M},
                                 \textit{mtype} (\mv m, \mv N,
                                 \mv\Pi) \text{ not defined}, \ol{\tv{a}}\ \text{fresh} } \\
                               & \consSet_m = \set{ \set{\tv{a}_{\mv m} \lessdot \type{Object}, \, \ol{\tv{a}} \lessdot \ol{\type{Object}}}
                                \ |\ (\exptype{C}{\ol{X} \triangleleft \ol{N}}.\mv{m} : \ol{\tv{a}} \to \tv{a}_{\mv m}) \in \ol{\methodAssumption}'} \\
                               & \Pi = \mv{\Pi} \cup
                                 \ol{\methodAssumption}' \cup
                                 \ol{\methodAssumption}_o \\
                               % \cup \\
                               % \typeAssumptions \cup m_{override}
                  \textbf{in} 
                               & { ( \Pi, 
                                 \consSet_o \cup \consSet_m \cup
                                 \bigcup_{\texttt{m} \in \ol{M}}
                                 \typeMethod(\Pi, \exptype{C}{\ol{X}},  \mathtt{m}))
                                 } 
                \end{array}
    \end{array}
  \end{gather*}
  \caption{Constraint generation for classes}
  \label{fig:constraints-for-classes}
\end{figure}

% We use intersection types during the constraint generation.
% In the end we select one possible solution after all classes got infered.
%TODO: add this to syntax (intersection types in method assumptions)

\if0
The \fjtype function gets called for every class in the input.
This function accumulates all the constraints generated from calling the
typeMethod function for each method declared in the given class.
It also generares constraints for overriden methods.
If a method \texttt{m} in \texttt{C} overrides a method in its superclass,
then we make sure that the return type of \texttt{m} in \texttt{C} is
a subtype of the overriden method.
\fi

Constraint generation alternates with constraint solving: After
generating constraints with {\fjtype}, we solve them to obtain one or
more candidate extensions for the method type environment
$\mv\Pi$. Next, we pick a candidate and continue with the next class
until all classes are checked and we have an overall method type
environment.  Otherwise, we backtrack to check the next candidate. 

\begin{gather*}
%%%%%   \typeMethod: \typeAssumptionsSymbol \times \texttt{M} \rightarrow \ol{\constraint}\\
\begin{array}{@{}l@{}l@{}l}
  \typeMethod & (\ensuremath{\mv{\Pi} }, \exptype{C}{\ol{X}},\ &\  \mathtt{m}(\ol{x})\{ \mathtt{ return }\ \texttt{e}; \}) =\\
              & \textbf{let} & \exptype{}{\ol{Y} \triangleleft \ol{P}}\ \overline{T} \to T  = \mv{\Pi} (\exptype{C}{\ol{X \triangleleft \ol{N}}}.\mv{m})
  \\
              & %\textbf{let}
                                                                                              & ({R}, \consSet) =
                                                                                                \typeExpr(\mv\Pi ; \set{\mv{this} :
                                                                                                \exptype{C}{\ol{X}} } \cup \set{ \ol{x} : \overline{{T}} }), \texttt{e})\\
              & \mathbf{in}
                                                                                              & \consSet \cup \set{{R} \lessdot {T}}\\
\end{array}
\end{gather*}

The \typeMethod{} function for methods calls the \typeExpr{} function with the
return expression. It adds the assumptions for \texttt{this} and for the method parameters to the global assumptions before passing them to \typeExpr.
%and the global assumptions plus the assumptions for the method parameters.

\smallskip

In the following we define the \typeExpr{} function for every possible expression:

\smallskip

\noindent
$\typeExpr: \typeAssumptionsSymbol \times
\texttt{Expression} \rightarrow {T} \times \consSet
$
\begin{gather*}
  \typeExpr (({\mtypeEnvironment} ; 
  \overline{\localVarAssumption}), \mathtt{x}) =
  (\overline{\localVarAssumption} (\mv x) , \emptyset)
\end{gather*}
When we encounter a field $\mv e.\mv f$, we consider all classes
$\mv C$
that define field $\mv f$ and impose an or-constraint that covers all
alternatives: the type $R$ of the expression $\mv e$ must be a subtype of a generic instance
of $\mv C$ and the return type must be the corresponding field type. 
\begin{gather*}
  \begin{array}{@{}l@{}l}
    \typeExpr{} &(({\mtypeEnvironment} ;
                  \overline{\localVarAssumption}), \texttt{e}.\texttt{f}) = \\
                & \begin{array}{ll}
                    \textbf{let} 
                    & ({R}, \consSet_R) = \typeExpr(({\mtypeEnvironment} ;
                      \overline{\localVarAssumption}), \texttt{e})\\
                    & \tv{a} \text{ fresh} \\
                    & \constraint = \begin{array}[t]{@{}l@{}l}
                      \orCons\set{
                      \set{ &
                      {R} \lessdot \exptype{C}{\ol{\tv{a}}} , \tv{a} \doteq
                      [\overline{\tv{a}}/\ol{X}]\type{T} , \ol{\tv{a}} \lessdot [\overline{\tv{a}}/\ol{X}]\ol{N}
                      \mid \overline{\tv{a}} \text{ fresh}
                      } \\
                      & \quad \mid \mv{T}\ \mv{f} \in \texttt{class}\ \exptype{C}{\ol{X} \triangleleft \ol{N}} \set{ \ol{T}\ \ol{f}; \ldots}
                      }\end{array}\\
                    {\mathbf{in}} & {
                    (\tv{a}, (\consSet_R \cup \set{\constraint}))}
                  \end{array} 
  \end{array}
\end{gather*}
We treat method calls in a similar way. We impose an or-constraint
that considers a generic instance of a method type in a class
providing that method (with the same number of parameters). Each
choice imposes a subtyping constraint on the receiver type  $R$ as
well as subtyping constraints on the argument types
$\overline{R}$. Moreover, we need to check that the subtyping
constraints of the method type are obeyed by instantiating them
accordingly.

\noindent
$\begin{array}{@{}l@{}l}
\typeExpr{} & (({\mtypeEnvironment} ;
  \overline{\localVarAssumption}), \texttt{e}.\mathtt{m}(\overline{\texttt{e}}) ) = \\
& \begin{array}{ll}
\textbf{let}& ({R}, \consSet_R) = \typeExpr(({\mtypeEnvironment} ;
  \overline{\localVarAssumption}), \texttt{e})\\
& \forall \texttt{e}_i \in \ol{e} : (R_i, \consSet_i) = \typeExpr(({\mtypeEnvironment} ;
  \overline{\localVarAssumption}), \texttt{e}_i)  \\
                    & \tv{a} \text{ fresh} \\
& \begin{array}{@{}l@{}l}
  \constraint = \orCons\set{ & \{
            \begin{array}[t]{l}
              {R} \lessdot \exptype{C}{\ol{\tv{a}}}, \tv{a} \doteq [\ol{\tv{b}}/\ol{Y}][\ol{\tv{a}}/\ol{X}]{T},
              \overline{R} \lessdot [\ol{\tv{b}}/\ol{Y}][\ol{\tv{a}}/\ol{X}]\overline{T} , \\
              \ol{\tv{b}} \lessdot [\ol{\tv{b}}/\ol{Y}][\ol{\tv{a}}/\ol{X}]\ol{P} ,
              \ol{\tv{a}} \lessdot [\ol{\tv{a}}/\ol{X}]\ol{N}
              \mid \overline{\tv{a}}, \overline{\tv{b}} \text{ fresh} \}
            \end{array}\\
      & \ |\ (\exptype{C}{\ol{X} \triangleleft \ol{N}}.\texttt{m} : \exptype{}{\ol{Y} \triangleleft \ol{P}} \ \overline{T} \to {T}) \in {\mtypeEnvironment} }
  \end{array}\\
\mathbf{in} & (\tv{a},(\consSet_R \cup \bigcup_i \consSet_i \cup \set{\constraint}))
\end{array}
\end{array}
$


The \texttt{new}-expression is comparatively simple. Starting from a
generic instance of the class type, we calculate the types $\overline
T$ of the fields, impose subtyping constraints on the constructor
argument $\overline R$, and check the subtyping  constraints of the class.
\begin{gather*}
  \begin{array}{@{}l@{}l}
    \typeExpr &(({\mtypeEnvironment} ; 
                \overline{\localVarAssumption}), \mathtt{new }\ \texttt{C}(\ol{e}) ) = \\
              &\begin{array}{ll}
                 \textbf{let} % \\
                 & \forall \texttt{e}_i \in \overline{\texttt{e}} : (R_i, \consSet_i) = \typeExpr(({\mtypeEnvironment} ;
                   \overline{\localVarAssumption}), \texttt{e}_i)  \\
                 & \overline{\tv{a}} \text{ fresh} \\
                 & \textit{fields} (\exptype{C}{\overline{\tv{a}}}) = \overline{T}\ \ol{f} \\
                 & \consSet = \set{\overline{R} \lessdot \overline{T}}
                   \cup \set{\overline{\tv{a}} \lessdot
                   [\overline{\tv{a}}/\ol{X}]\ol{N}} 
                   \qquad\text{where}\ \texttt{class}\ \exptype{C}{\ol{X} \triangleleft \ol{N}} \set{\ldots} \\
                 \mathbf{in}& (\exptype{C}{\ol{\tv{a}}}, \consSet \cup \bigcup_i \consSet_i)
               \end{array}
  \end{array}
\end{gather*}

For cast expressions, we ignore the return type and pass on the
constraints for the subexpression. We return the target type of the cast.
\begin{gather*}
  \begin{array}{@{}l@{}l}
    \typeExpr &(({\mtypeEnvironment} ;
                \overline{\localVarAssumption}), (\texttt{N})\mv{e} ) = \\
              &\begin{array}{ll}
                 \textbf{let} % \\
                 & (R, \consSet) = \typeExpr(({\mtypeEnvironment} ;
                   \overline{\localVarAssumption}), \texttt{e})  \\
                 \mathbf{in} & (\mv{N}, \consSet)
               \end{array}
  \end{array}
\end{gather*}

\subsubsection{Completeness of the type inference algorithm}
\begin{theorem}\textbf{Soundness:}
  $\fjtypeinference(\mv{\Pi},\texttt{L}) = \mv{\Pi}'$ implies $\mv{\Pi} \vdash \texttt{L} : \mv{\Pi}'$
\end{theorem}
\begin{theorem}\textbf{Completeness:}
  If there exists a $\mv{\Pi}'$ and $\texttt{L}$ with $\mv{\Pi} \vdash \texttt{L} : \mv{\Pi}'$, then $\fjtypeinference(\mv{\Pi},\texttt{L}) = \mv{\Pi}''$ with $\mv{\Pi} \vdash \texttt{L} : \mv{\Pi}''$.
\end{theorem}
\textbf{Proof:}
Every type variable $\tv{a}$ in $\mv{\Pi}$ is replaced by $\sigma(\tv{a})$.
We show soundness and completeness by a case analysis over the type rules given by \TFGJ{}.
We can show that the constraints generated by \fjtype{} mirror the \TFGJ{} type rules.
The \unify{} algorithm is sound and complete (see theorem \label{theo:unifySoundness} and \label{theo:unifyCompleteness})
and therefore the $\fjtypeinference$ algorithm is sound and complete.

The biggest part of the type rules can be expressed with the constraints generated by the \fjtype{} function.
But the \texttt{WF-CLASS} rule checks types for well-formedness in a recursive fashion.
The types $\ol{T}$ used to instantiate the class $exptype{C}{\ol{X}}$ need to follow the bounds given by the class declaration $\ol{T} <: [\ol{T}/\ol{X}]\ol{N}$, but also have to be well-formed themselfes $\ol{N}\ \texttt{ok}$.
\begin{lemma} \textbf{Well-formedness:}
  Given method assumptions $\Pi$ and a class \normalfont{$\texttt{class}\ \exptype{C}{\ol{X} \triangleleft \ol{N}}$} with
  \normalfont{$\fjtypeinference(\mv{\Pi}, \texttt{class}\ \exptype{C}{\ol{X} \triangleleft \ol{N}}) = \mv{\Pi}'$},
  then the following statements holds:\\
  \normalfont $\forall (\exptype{C}{\ol{X} \triangleleft \ol{N}}.\texttt{m} : \exptype{}{\ol{Y} \triangleleft \ol{P}}\ \ol{\type{T}} \to \itype{T}) \in \mv{\Pi}': \quad \ol{X} <: \ol{N}, \ol{Y} <: \ol{P} \vdash \type{T}, \ol{T}, \ol{P}, \ol{N}\ \texttt{ok}$
\end{lemma}
\textbf{Proof:}
Well-formedness of types already declared in the input class can be easily checked before the start of the \fjtype{} algorithm.
We therefore assume all types and type variables given in the input to be well-formed and are not checking this during the type inference step.
%This applies to the bounds $\ol{N}$ of class definitions $\texttt{class}\ \exptype{C}{\ol{X} \triangleleft \ol{N}}$
%as well as field types and types given in cast expressions.
%This also means every generic variable used in the input to be correctly declared according to the \texttt{WF-VAR} rule.
So assuming $\ol{X} <: \ol{N}, \ol{Y} <: \ol{P} \vdash \ol{N}, \ol{P}\ \texttt{ok}$, we only have to show that every type inserted by our type inference algorithm is well-formed.

Using theorems \ref{theo:unifySoundness} and \ref{lemma:unify-exhaustive} we can show that $\ol{X} <: \ol{N}, \ol{Y} <: \ol{P} \vdash \type{T}, \ol{T}, \ol{P}, \ol{N}\ \texttt{ok}$.
There is only two ways our type inference algorithm is able to produce a type, which is not well-formed.
Either by violating a generic bound (see \texttt{WF-CLASS} rule)
or by using a generic variable, which is not in scope (see \texttt{WF-VAR} rule).
The \texttt{WF-CLASS} rule is always satisfied, because the \fjtype function generates constraints for every type used as a generic instantiation.
Also every type variable generated by \fjtype is used inside atleast one constraint.
Due to lemma \ref{lemma:unify-exhaustive} we can be sure that each type variable either gets a type assigned or a generic variable, which is correctly added to the method type by $\fjtypeInsert$.


\textbf{Proof:}
Now we show that the constraints generated by \textbf{GFJTYPE}
represent the type rules given in chapter \ref{chapter:type-rules}.
For most of the expression typing rules this is trivial.
Such as \texttt{GT-VAR}, \texttt{GT-FIELD} and \texttt{GT-NEW}.

%The \unify{} algorithm is complete, so every correct type is included in the solution set.
%We only have to choose the right type out of those solutions.
%When compiling multiple classes the problem arises,
%that only one of the type solutions calculated by \unify{} is correct
%in respective to the other classes that will be compiled afterwards.

%All types that are possible under the FGJ typing rules, plus our additional assumptions,
%also comply with the generated constraints.

We match every generated constraint with the respective type rule to show completeness of our \textbf{FJTYPE} algorithm.
This shows that none of the generated constraints remove a type which otherwise would be possible under the \TFGJ typing rules.
The constraints are generated on expression statements.
We now compare the constraints for each expression with the appropriate type rule from \TFGJ:
\begin{description}
  \item [this]
  has always the type of the surrounding class and generates no constraints.
  \item [Local var]
  No constraints are generated.
  \item[Method invocation (\texttt{GT-INVK})]
The \texttt{GT-INVK} rule is for method calls, which already have a type assignment.
By direct comparison we show that each of the generated constraints applies the same restrictions than the \texttt{GT-INVK} rule.
The \texttt{GT-INVK} rule states the condition $\textit{mtype}(m, \textit{bound}_\triangle(T_0)) = \exptype{}{\ol{Y}}\ \ol{U} \to U$.
%In our version of typeless FGJ every method name is unique
%and there is only one class with that particular method.
The constraint $\type{R} \lessdot \exptype{C}{\ol{X}}$ assures that the type of the expression $e_0$ contains the method \texttt{m}.

\begin{small}
\begin{tabularx}{\linewidth}{lX|Xl}
  \textbf{FGJ Type rule} &&& \textbf{Constraints} \\
  $\triangle; \Gamma \vdash e_o : T_0$ &&& $(\type{R}, ConS) = \typeExpr(Ass, e_r)$\\ 
  $\mathtt{\textit{bound}(T_0)}$ &&& $\type{R} \lessdot \exptype{C}{\ol{X}}$ \\
  $\mathtt{\exptype{}{\ol{Y} \triangleleft \ol{P}}\ \ol{U} \to U} \in \textit{mtype}(m, N)$ &&& Lookup in the assumptions \\
 %$\textit{mtype}(m, \textit{bound}_\triangle(T_0)) = \ol{U} \to U$ & $\type{R} \doteq cl$\\
 $\triangle; \Gamma \vdash \ol{e} : \ol{S}$ &&& $\forall e_i \in \overline{e} : (pt_i, ConS_i) = \typeExpr(Ass, e_i)$\\
 $\triangle \vdash \ol{S} <: \ol{U}$ &&& $ \bigcup_{T_i \in \overline{T}} (pt_i \lessdot T_i)$\\
 $\triangle; \Gamma \vdash \mathtt{e_0.m(\overline{e}) : U }$ &&& $a \doteq T$ \\
\end{tabularx}
\end{small}

\textit{Note}: The \typeExpr{} function only generates constraints which apply to our assumption.
\item[Method invocation (\texttt{GT-L-INVK})]
The \texttt{GT-INVK} rule is for local method calls.
The called method does not have a type yet and comes with type variables for the return and parameter types.
The difference for a normal method call is that we do not generate fresh type variables.
This results in the local method call not being polymorphic.
%TODO: Rewrite GT-INVK proof
%      Rewrite the FGJType algorithm for local method calls


 \item[Field access]
Mostly the same as method invocation.
Fieldnames by default are unique in the FGJ language.

 \begin{tabular}{l|l}
   \textbf{FGJ Type rule} & \textbf{Constraints} \\
   $\Gamma \vdash e_0:T_0$ & $(\type{R}, ConS) = \typeExpr(Ass, e_r)$\\ 
   $\quad \mathit{fields}(\mathit{bound}_\triangle(T_0)) = \overline{T} \ \overline{f}$ & $\type{R} \doteq \exptype{C}{\textbf{fresh}(\ol{X})}$ \\
  %$\textit{mtype}(m, \textit{bound}_\triangle(T_0)) = \ol{U} \to U$ & $\type{R} \doteq cl$\\
  $\triangle; \Gamma \vdash \ol{e} : \ol{S}$ & $\forall e_i \in \overline{e} : (pt_i, ConS_i) = \typeExpr(Ass, e_i)$\\
  $\triangle \vdash \ol{S} <: \ol{U}$ & $ \bigcup_{T_i \in \overline{T}} (pt_i \lessdot \textbf{fresh}(T_i))$\\
  $\triangle; \Gamma \vdash \mathtt{e_0.m(\overline{e}) : U }$ & $a \doteq \textbf{fresh}(T)$ \\
 \end{tabular}
 \item[Constructor]

\begin{tabular}{l|l}
  $\triangle; \Gamma \vdash \ol{e} : \ol{S}$ & $\forall e_i \in \overline{e} : (pt_i, ConS_i) = \typeExpr(Ass, e_i)$\\
  $\triangle \vdash \ol{S} <: \ol{T}$ & $\bigcup_{T_i \in \overline{T}} (pt_i \lessdot T_i)$
\end{tabular}

\item[Cast]
A cast can either be an upcast or a downcast or a so called stupid cast.
See respective type rules \texttt{GT-UCAST}, \texttt{GT-DCAST}, \texttt{GT-SCAST} in chapter \ref{chapter:type-rules}.
%Every type of cast is allowed in \TFGJ, therefore no restrictions in form of constraints are needed.
%The check if the cast type $\mathtt{N}$ is well formed ($\mathtt{N}\ \text{ok}$) is done in advance to the \textbf{FJTYPE} algorithm.
We assume that each given type in our input set is well-formed.
Therefore the cast type $\mathtt{N}$ is well formed ($\mathtt{N}\ \text{ok}$) too.
So every possible type of cast is allowed in \TFGJ, therefore no restrictions in form of constraints are needed.

\end{description}

\input{unify}

\input{unifyProof}

\section{Complexity}
\label{sec:complexity}

\input{complexity}

% \section{Examples}
% \label{sec:examples}
%\input{examples}

\input{relatedWork}

\input{conclusions}

%\bibliographystyle{splncs04}
\bibliography{peter,martin}

\end{document}
\endinput
%%
%% End of file `TIforGFJ.tex'.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
