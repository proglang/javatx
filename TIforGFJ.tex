\documentclass[a4paper,USenglish,cleveref, autoref, thm-restate]{lipics-v2021}
%This is a template for producing LIPIcs articles. 
%See lipics-v2021-authors-guidelines.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling autoref support, use "autoref"
%for anonymousing the authors (e.g. for double-blind review), add "anonymous"
%for enabling thm-restate support, use "thm-restate"
%for enabling a two-column layout for the author/affilation part (only applicable for > 6 authors), use "authorcolumns"
%for producing a PDF according the PDF/A standard, add "pdfa"

\pdfoutput=1 %uncomment to ensure pdflatex processing (mandatatory e.g. to submit to arXiv)
%\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the mandatory bibstyle

\title{Global Type Inference for Featherweight Generic Java} %TODO Please add

% \titlerunning{Global Type Inference for Featherweight Generic Java} %TODO optional, please use if title is longer than one line

\author{Andreas Stadelmeier}{DHBW Stuttgart, Campus Horb, Germany}{a.stadelmeier@hb.dhbw-stuttgart.de}{}{}%TODO mandatory, please use full name; only 1 author per \author macro; first two parameters are mandatory, other parameters can be empty. Please provide at least the name of the affiliation and the country. The full address is optional. Use additional curly braces to indicate the correct name splitting when the last name consists of multiple name parts.

\author{Martin Plümicke}{DHBW Stuttgart, Campus Horb, Germany}{pl@dhbw.de}{}{}

\author{Peter Thiemann}{Universität Freiburg, Institut für Informatik, Germany}{thiemann@informatik.uni-freiburg.de}{}{}

\authorrunning{A. Stadelmeier and M. Plümicke and P. Thiemann} %TODO mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

\Copyright{Andreas Stadelmeier and Martin Plümicke and Peter Thiemann} %TODO mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

   
\ccsdesc[500]{Software and its engineering~Language features}
%\ccsdesc[300]{Software and its engineering~Syntax}

\keywords{type inference, Java, compiler} %TODO mandatory; please add comma-separated list of keywords

\category{} %optional, e.g. invited paper

\relatedversion{} %optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversiondetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93]{Classification (e.g. Full Version, Extended Version, Previous Version}{URL to related version} %linktext and cite are optional

%\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...
%\supplementdetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93, subcategory={Description, Subcategory}, swhid={Software Heritage Identifier}]{General Classification (e.g. Software, Dataset, Model, ...)}{URL to related version} %linktext, cite, and subcategory are optional

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

\acknowledgements{}%optional

%\nolinenumbers %uncomment to disable line numbering



%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{todonotes} % [disable]
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{subcaption}
\usepackage{prftree}
\usepackage{tabularx}
\usepackage{multicol}
\input{prolog}


\begin{document}

\maketitle

\begin{abstract}
  Type Inference for Featherweight Generic Java
\end{abstract}



\input{introduction}

\input{motivation}

\input{preliminaries}

\section{Type inference algorithm}
\label{sec:type-infer-algor}
This section presents our type inference algorithm.
The algorithm is split into several parts, which are executed on a single class at a time:

\begin{enumerate}
\item Constraint generation with \fjtype{}
\item Constraint solving with \unify{}
\item \fjtypeInsert{}
\end{enumerate}

$\textbf{FJTypeInference} : \mv{\Pi} \times \texttt{L} \to \mv{\Pi}$\\
$\begin{array}{l}
\textbf{FJTypeInference}(\mv{\Pi}, \texttt{L}) = \\
\quad \quad \begin{array}[t]{rl}
  \textbf{let}\ 
  (\mtypeEnvironment, \consSet) &= \fjtype{}(\mv{\Pi}, \texttt{L})\\
  {Uni} &= \unify{}(\consSet)\\
  (\sigma, \unifyGenerics{}) &= \text{choose a solution from}\ {Uni}\\
  %TODO: Describe whole algorithm (Insert types, try out every unify solution by backtracking (describe it as Non Deterministic algorithm))
\end{array}\\
\textbf{in}\ \fjtypeInsert(\mv{\Pi}, (\sigma, \unifyGenerics{}) )
\end{array}$

%This set inherits the principal type solution.
%The last step simplifies the calculated solutions and only inserts the principal typing.
%The last step chooses the principal type out of those possibilities.

The solver \unify{} returns a set of all possible type solutions for the currently processed class.
We generate the $\mv{\Pi}$ environment used in the next iteration of the \fjtype{} algorithm as follows:
\begin{align*}
  \fjtypeInsert{}(\overline{\methodAssumption}, (\sigma, \unifyGenerics{}) = \begin{array}{l}
    \set{(\exptype{C}{\ol{X}}.\mv{m} : \exptype{}{\unifyGenerics{}}\ \ol{\sigma(\tv{a})} \to \sigma(\tv{a})) \ |\ (\exptype{C}{\ol{X}}.\mv{m} : \ol{\tv{a}} \to \tv{a}) \in \overline{\methodAssumption}}
  \end{array} 
\end{align*}
Here $\overline{\methodAssumption}$ are the newly generated method assumptions of the \fjtype{} function.
$(\sigma, \unifyGenerics{})$ is one of the solutions returned by \unify{}.
We try out one solution at a time.
It is possible that subsequent classes resolve some of the solutions as incorrect.
We solve this problem by backtracking and trying out every possible solution one by one if needed.

\subsection{Type inference for a program }
\label{sec:proc-mult-class}

\commentarymargintext{Type inference processes a program one class at a time.
To do so, it must be possible to order the classes such that early
classes never call methods in later classes.
As an example, Figure~\ref{fig:invalidinput} shows a program that is
acceptable in FGJ, but rejected by \TFGJ because the methods \mv{m1}
and \mv{m2} are mutually recursive across class boundaries. There is
no order in which classes \mv{C1} and \mv{C2} can be processed.

Figure~\ref{fig:correctinput} contains a program
acceptable to both \TFGJ and FGJ because the mutual recursion of
methods \mv{m1} and \mv{m2} is taking place inside class \mv{D2}. As
\mv{D2} invokes method \mv{m} of \mv{D1}, type inference must process
\mv{D1} before \mv{D2}, which corresponds to the constraints imposed
by the typing of \TFGJ in Section~\ref{chapter:type-rules}.}
{Das gehört doch zu den Typregeln oder willst Du es hier nochals wiederholen?}

% Only the first step creating the type assumptions is able to consider other classes as well.


\begin{figure}[tp]
    \centering
    \begin{minipage}{.48\textwidth}
\begin{lstlisting}[style=tfgj]
class C1 extends Object {
  m1(){ return new C2().m2(); }
}
class C2 extends Object{
  m2(){ return new C1().m1(); }
}
\end{lstlisting}
      \caption{Invalid \TFGJ program}
      \label{fig:invalidinput}
    \end{minipage}%
  ~$\left|~
    \begin{minipage}{.48\textwidth}
\begin{lstlisting}[style=tfgj]
class D1 extends Object {
  m(){ return ...; }
}
class D2 extends Object{
  m1(x){ return new D2().m2(); }
  m2( ){ return new D2().m1(
                new D1().m()); }
}
\end{lstlisting}
      \caption{Valid \TFGJ program}
      \label{fig:correctinput}
    \end{minipage}\right.$
\end{figure}

We obtain a viable order for processing the class declarations by
computing an approximate call graph based solely on method names. That
is, if method \mv{m} is used in \mv{C3} and defined both in \mv{C1}
and \mv{C2}, then \mv{C1} and \mv{C2} must both be processed before
\mv{C3}. In such a case, the use of \mv{m} might be ambiguous so that
type inference for class \mv{C3} proposes more than one solution. Global
type inference attempts to extend each partial solution to a solution for the
whole program and backtracks if that fails.

\subsection{Constraint generation}
\label{sec:fjtype}
\begin{figure}[tp]
  \begin{align*}
    % Type
    \itype{T}, \itype{U} &::= \tv{a} \mid \mv{T} && \text{type variable or type}\\
    \itype{N} &::= \exptype{C}{\il{T}} && \text{class type with type variables} \\
    % Constraints
    \simpleCons &::= \itype{T} \lessdot \itype{U} \mid \itype{T} \doteq \itype{U} && \text{simple constraint: subtype or equality}\\
    \orCons{} &::= \set{\set{\overline{\simpleCons_1}}, \ldots, \set{\overline{\simpleCons_n}}} && \text{or-constraint}\\
    \constraint &::= \simpleCons \mid \orCons && \text{constraint}\\
    \consSet &::= \set{\constraints} && \text{constraint set}\\
    % Method assumptions:
    \methodAssumption &::= \exptype{C}{\ol X}.\texttt{m} : \exptype{}{\ol{Y}
                        \triangleleft \ol{P}}\ \ol{\itype{T}} \to \itype{T}  &&
                                                                \text{method
                                                                type assumption}\\
    \localVarAssumption &::= \texttt{x} : \itype{T} && \text{parameter
                                                       assumption}\\
    \mtypeEnvironment & ::= \mv\Pi \cup \overline{\methodAssumption} &
                & \text{method type environment} \\
    \typeAssumptionsSymbol &::= ({\mtypeEnvironment} ; \overline{\localVarAssumption}) 
  \end{align*}
  \caption{Syntax of constraints and type assumptions}
  \label{fig:syntax-constraints}
\end{figure}

Figure~\ref{fig:syntax-constraints} defines the syntax of
constraints. We extend types with \emph{type variables} ranged over by
$\tv{a}$. A constraint is either a simple constraint $\simpleCons$ or
an or-constraint $\orCons$, which is a set of sets of simple
constraints. An or-constraint represents different alternatives,
similar to an intersection type, and
cannot be nested. The output of constraint generation is a set of
constraints $\consSet$, which can hold simple constraints as well as or-constraints.
% \begin{description}
%   \item[Constraint] A constraint (\constraint) consists of two types or type variables and an operator.
%   The operator can either be a $\doteq$ (same type) or $\lessdot$ (subtype).
%   Example: $(a \lessdot \mathtt{Object})$, means that the type variable $a$ should be a subtype of \texttt{Object}.
%   \item[Or-Constraint] An Or-Constraint (\orCons{}) consists out of multiple sets of constraints ($c$).
%   It is not possible to have \orCons{} nested inside another \orCons{}.\\
%   For example $\orCons{}(\{ \ \{ (a \lessdot b), (a \leq \mathtt{Object}) \} \ , \ \{ (a \lessdot b)\} \ \})$
%   is an Or-Constraint consisting of two sets of constraints.
%   \item[Constraint-Set] The \fjtype algorithm returns a Constraint-Set (\consSet).
%   It is able to hold a mix of normal Constraints and Or-Constraints.
%   \end{description}




%The \fjtype{} algorithm produces two kinds of constraints.
% Before the algorithm starts we equip every untyped method with type variables.
% Every method parameter gets a unique type variable as a type aswell as every method gets a unique type variable as a return type.
% After our algorithm found a correct typisation we replace the type variables with the inferred types and generate a GFJ program.


Figure~\ref{fig:constraints-for-classes} contains the algorithm
{\fjtype} to generate constraints for classes. Its input
consists of the method type environment $\mv\Pi$ of the previously
checked classes. It distinguishes between overriding and
non-overriding method definitions. The former are recognized by
successful lookup of their type using \textit{mtype}. We set up the
method type assumptions accordingly and generate a constraint between
the inferred return type $\tv{a}_{\mv m}$ and the one of the
overridden method to allow for covariant overriding.
Constraints for the latter methods are generated with all fresh
variables for the argument and result types.

\begin{figure}[tp]
  \begin{gather*}
    % \fjtype : \typeAssumptionsSymbol \times \texttt{L} \rightarrow \ol{\constraint}\\
    \begin{array}{@{}l@{}l}
      \fjtype & ({\mv{\Pi}}, \mathtt{class } \ \exptype{C}{\ol{X} \triangleleft \ol{N}} \ \mathtt{ extends } \ \mathtt{N \{ \overline{T} \ \overline{f}; \, K \, \overline{M} \}}) =\\
              & \begin{array}{ll@{}l}
                  \textbf{let} & \overline{\tv{a}}_{\mv m} \text{ be fresh type variables
                                 for each }\mv{m}\in\ol{M} \\
                               & \ol{\methodAssumption}_o = \set{\exptype{C}{\ol{X}}.\mv{m} :
                                 \exptype{}{\ol{Y} \triangleleft \ol{P}}\ \ol{T} \to \tv{a}_{\mv m} \mid \mv{m} \in \ol{M},
                                 \textit{mtype}(\mv{m}, \type{N}, \mv\Pi) = \exptype{}{\ol{Y} \triangleleft \ol{P}} \ol{\type{T}} \to \type{T}}\\
                               & \consSet_o = \set{\tv{a}_{\mv m} \lessdot \type{T} \ |\ \texttt{m} \in \ol{M}, 
                                 \textit{mtype}(\mv{m}, \mv{N}, \mv\Pi) = \exptype{}{\ol{Y} \triangleleft \ol{P}} \ol{\type{T}} \to \type{T}}\\
                               & \ol{\methodAssumption}' = 
                                 \set{ (\exptype{C}{\ol{X}}.\mv{m} : \ol{\tv{a}} \to \tv{a}_{\mv
                                 m}) \mid \mv{m} \in \ol{M},
                                 \textit{mtype} (\mv m, \mv N,
                                 \mv\Pi) \text{ not defined}, \ol{\tv{a}}\ \text{fresh} } \\
                               & \consSet_m = \set{ \set{\tv{a}_{\mv m} \lessdot \type{Object}, \, \ol{\tv{a}} \lessdot \ol{\type{Object}}}
                                \ |\ (\exptype{C}{\ol{X}}.\mv{m} : \ol{\tv{a}} \to \tv{a}_{\mv m}) \in \ol{\methodAssumption}'} \\
                               & \Pi = \mv{\Pi} \cup
                                 \ol{\methodAssumption}' \cup
                                 \ol{\methodAssumption}_o \\
                               % \cup \\
                               % \typeAssumptions \cup m_{override}
                  \textbf{in} 
                               & { ( \Pi, 
                                 \consSet_o \cup \consSet_m \cup
                                 \bigcup_{\texttt{m} \in \ol{M}}
                                 \typeMethod(\Pi, \exptype{C}{\ol{X}},  \mathtt{m}))
                                 } 
                \end{array}
    \end{array}
  \end{gather*}
  \caption{Constraint generation for classes}
  \label{fig:constraints-for-classes}
\end{figure}

% We use intersection types during the constraint generation.
% In the end we select one possible solution after all classes got infered.
%TODO: add this to syntax (intersection types in method assumptions)

\if0
The \fjtype function gets called for every class in the input.
This function accumulates all the constraints generated from calling the
typeMethod function for each method declared in the given class.
It also generares constraints for overriden methods.
If a method \texttt{m} in \texttt{C} overrides a method in its superclass,
then we make sure that the return type of \texttt{m} in \texttt{C} is
a subtype of the overriden method.
\fi

Constraint generation alternates with constraint solving: After
generating constraints with {\fjtype}, we solve them to obtain one or
more candidate extensions for the method type environment
$\mv\Pi$. Next, we pick a candidate and continue with the next class
until all classes are checked and we have an overall method type
environment.  Otherwise, we backtrack to check the next candidate. 

\begin{gather*}
%%%%%   \typeMethod: \typeAssumptionsSymbol \times \texttt{M} \rightarrow \ol{\constraint}\\
\begin{array}{@{}l@{}l@{}l}
  \typeMethod & (\ensuremath{\mv{\Pi} }, \exptype{C}{\ol{X}},\ &\  \mathtt{m}(\ol{x})\{ \mathtt{ return }\ \texttt{e}; \}) =\\
              & \textbf{let} & \exptype{}{\ol{Y} \triangleleft \ol{P}}\ \overline{T} \to T  = \mv{\Pi} (\exptype{C}{\ol{X}}.\mv{m})
  \\
              & %\textbf{let}
                                                                                              & ({R}, \consSet) =
                                                                                                \typeExpr(\mv\Pi ; \set{\mv{this} :
                                                                                                \exptype{C}{\ol{X}} } \cup \set{ \ol{x} : \overline{{T}} }), \texttt{e})\\
              & \mathbf{in}
                                                                                              & \consSet \cup \set{{R} \lessdot {T}}\\
\end{array}
\end{gather*}

The \typeMethod{} function for methods calls the \typeExpr{} function with the
return expression. It adds the assumptions for \texttt{this} and for the method parameters to the global assumptions before passing them to \typeExpr.
%and the global assumptions plus the assumptions for the method parameters.

\smallskip

In the following we define the \typeExpr{} function for every possible expression:

\smallskip

\noindent
$\typeExpr: \typeAssumptionsSymbol \times
\texttt{Expression} \rightarrow {T} \times \consSet
$
\begin{gather*}
  \typeExpr (({\mtypeEnvironment} ; 
  \overline{\localVarAssumption}), \mathtt{x}) =
  (\overline{\localVarAssumption} (\mv x) , \emptyset)
\end{gather*}
When we encounter a field $\mv e.\mv f$, we consider all classes
$\mv C$
that define field $\mv f$ and impose an or-constraint that covers all
alternatives: the type $R$ of the expression $\mv e$ must be a subtype of a generic instance
of $\mv C$ and the return type must be the corresponding field type. 
\begin{gather*}
  \begin{array}{@{}l@{}l}
    \typeExpr{} &(({\mtypeEnvironment} ;
                  \overline{\localVarAssumption}), \texttt{e}.\texttt{f}) = \\
                & \begin{array}{ll}
                    \textbf{let} 
                    & ({R}, \consSet_R) = \typeExpr(({\mtypeEnvironment} ;
                      \overline{\localVarAssumption}), \texttt{e})\\
                    & \tv{a} \text{ fresh} \\
                    & \constraint = \begin{array}[t]{@{}l@{}l}
                      \orCons\set{
                      \set{ &
                      {R} \lessdot \exptype{C}{\ol{\tv{a}}} , \tv{a} \doteq
                      [\overline{\tv{a}}/\ol{X}]\type{T} , \ol{\tv{a}} \lessdot [\overline{\tv{a}}/\ol{X}]\ol{N}
                      \mid \overline{\tv{a}} \text{ fresh}
                      } \\
                      & \quad \mid \mv{T}\ \mv{f} \in \texttt{class}\ \exptype{C}{\ol{X} \triangleleft \ol{N}} \set{ \ol{T}\ \ol{f}; \ldots}
                      }\end{array}\\
                    {\mathbf{in}} & {
                    (\tv{a}, (\consSet_R \cup \set{\constraint}))}
                  \end{array} 
  \end{array}
\end{gather*}
We treat method calls in a similar way. We impose an or-constraint
that considers a generic instance of a method type in a class
providing that method (with the same number of parameters). Each
choice imposes a subtyping constraint on the receiver type  $R$ as
well as subtyping constraints on the argument types
$\overline{R}$. Moreover, we need to check that the subtyping
constraints of the method type are obeyed by instantiating them
accordingly.

\noindent
$\begin{array}{@{}l@{}l}
\typeExpr{} & (({\mtypeEnvironment} ;
  \overline{\localVarAssumption}), \texttt{e}.\mathtt{m}(\overline{\texttt{e}}) ) = \\
& \begin{array}{ll}
\textbf{let}& ({R}, \consSet_R) = \typeExpr(({\mtypeEnvironment} ;
  \overline{\localVarAssumption}), \texttt{e})\\
& \forall \texttt{e}_i \in \ol{e} : (R_i, \consSet_i) = \typeExpr(({\mtypeEnvironment} ;
  \overline{\localVarAssumption}), \texttt{e}_i)  \\
                    & \tv{a} \text{ fresh} \\
& \begin{array}{@{}l@{}l}
  \constraint = \orCons\set{ & \set{{R} \lessdot \exptype{C}{\ol{\tv{a}}}, \tv{a} \doteq {T},
                                \overline{R} \lessdot \overline{T} , \ol{\tv{b}} \lessdot
                                [\ol{\tv{b}}/\ol{Y}][\ol{\tv{a}}/\ol{X}]\ol{P} \mid \overline{\tv{a}}, \overline{\tv{b}} \text{ fresh}}\\
  & \ |\ (\exptype{C}{\ol{X}}.\texttt{m} : \exptype{}{\ol{Y} \triangleleft \ol{P}} \ \overline{T} \to {T}) \in {\mtypeEnvironment} }
  \end{array}\\
\mathbf{in} & (\tv{a},(\consSet_R \cup \bigcup_i \consSet_i \cup \set{\constraint}))
\end{array}
\end{array}
$


The \texttt{new}-expression is comparatively simple. Starting from a
generic instance of the class type, we calculate the types $\overline
T$ of the fields, impose subtyping constraints on the constructor
argument $\overline R$, and check the subtyping  constraints of the class.
\begin{gather*}
  \begin{array}{@{}l@{}l}
    \typeExpr &(({\mtypeEnvironment} ; 
                \overline{\localVarAssumption}), \mathtt{new }\ \texttt{C}(\ol{e}) ) = \\
              &\begin{array}{ll}
                 \textbf{let} % \\
                 & \forall \texttt{e}_i \in \overline{\texttt{e}} : (R_i, \consSet_i) = \typeExpr(({\mtypeEnvironment} ;
                   \overline{\localVarAssumption}), \texttt{e}_i)  \\
                 & \overline{\tv{a}} \text{ fresh} \\
                 & \textit{fields} (\exptype{C}{\overline{\tv{a}}}) = \overline{T}\ \ol{f} \\
                 & \consSet = \set{\overline{R} \lessdot \overline{T}}
                   \cup \set{\overline{\tv{a}} \lessdot
                   [\overline{\tv{a}}/\ol{X}]\ol{N}} 
                   \qquad\text{where}\ \texttt{class}\ \exptype{C}{\ol{X} \triangleleft \ol{N}} \set{\ldots} \\
                 \mathbf{in}& (\exptype{C}{\ol{\tv{a}}}, \consSet \cup \bigcup_i \consSet_i)
               \end{array}
  \end{array}
\end{gather*}

For cast expressions, we ignore the return type and pass on the
constraints for the subexpression. We return the target type of the cast.
\begin{gather*}
  \begin{array}{@{}l@{}l}
    \typeExpr &(({\mtypeEnvironment} ;
                \overline{\localVarAssumption}), (\texttt{N})\mv{e} ) = \\
              &\begin{array}{ll}
                 \textbf{let} % \\
                 & (R, \consSet) = \typeExpr(({\mtypeEnvironment} ;
                   \overline{\localVarAssumption}), \texttt{e})  \\
                 \mathbf{in} & (\mv{N}, \consSet)
               \end{array}
  \end{array}
\end{gather*}

\subsubsection{Completeness of the type inference algorithm}
\todo[inline]{The following theorem talks about soundness of type inference and it lacks a formal
  statement! Before it can be stated, we need to say what is a solution of a constraint. Moreover,
  the constraint generation for classes has to return the newly generated method type assumptions:
  when we apply the solution to those, we obtain an updated method environment, which we can relate
  to the output of the \TFGJ class typing.}


%every unifier is a correct solution
%\begin{lemma}
%  Given a $\exptype{C}{\ol{X}}.\texttt{m} \mapsto \ol{\tv{a}} \to \tv{a}$ and a unifier $\sigma$ there is a
%\end{lemma}

%\begin{lemma}
%  $\fjtype{}(\emptyset,\texttt{L}) = \mv{\Pi}$ implies $\emptyset \vdash \texttt{L} : \mv{\Pi}$
%\end{lemma}


%Lemmas needed for soundness:
\begin{lemma}
If there is a type $\type{T}$ for an expression $\texttt{e}$ with $\mathtt{\environmentvdash e : T}$,
then $\sigma(\mtypeEnvironment); \sigma(\triangle) ; \sigma(\Gamma) \vdash $
\end{lemma}
\begin{lemma}
  If there exists a $\fjtype{}(\mv{\Pi},\texttt{L}) = (\mtypeEnvironment, \consSet)$ and a $\sigma \in \unify{}(\consSet)$
  then $\mv{\Pi} \vdash \texttt{L} : \sigma(\mtypeEnvironment)$.
\end{lemma}
\textbf{Proof:}

\begin{theorem}\textbf{Soundness:}
  $\textbf{FJTypeInference}(\mv{\Pi},\texttt{L}) = \mv{\Pi}'$ implies $\mv{\Pi} \vdash \texttt{L} : \mv{\Pi}'$
\end{theorem}
\begin{theorem}\textbf{Completeness:}
  $\textbf{FJTypeInference}(\mv{\Pi},\texttt{L}) = \mv{\Pi}'$ implies $\mv{\Pi} \vdash \texttt{L} : \mv{\Pi}'$
\end{theorem}
\textbf{Proof:}
Every type variable $\tv{a}$ in $\mv{\Pi}$ is replaced by $\sigma(\tv{a})$.
We show soundness by a case analysis over the type rules given by \TFGJ using theorem \label{theo:unifySoundness}.


\begin{description}
  \item[Well-formed types] We assume all types given in the input class $\texttt{L}$ to be well-formed.
  Only types added by the algorithm have to be checked for well-formedness.
  \item[GT-CLASS]
  $\ol{P}\ \texttt{ok}$
\end{description}


%$We show that the inserted types into the method assumptions render $\mv{\Pi} \vdash \texttt{L} : \mv{\Pi}'$ correct.
%
%We show this by induction over the \TFGJ type rules.
%Assuming $\mv{\Pi}$ is correct.
%
%%Lemma:
%Given a $\fjtype{}(({\mtypeEnvironment} ; \overline{\fieldAssumption};
%\overline{\localVarAssumption}), \texttt{e}) = (\itype{T}, \consSet)$ and a $\unify{}(\consSet) = \sigma$
%
%$\environmentvdash e : T$ implies $\environmentvdash e : \sigma(\itype{T})$
%and $\sigma(\itype{T}) <: \type{T}$ 

%TODO: hier noch schlussfolgern, dass es nicht nur für eine Klasse, sondern für mehrere Klassen gilt
\begin{lemma}
  $\fjtype{}(\mv{\Pi},\texttt{L}) = \mv{\Pi}'$ implies $\mv{\Pi} \vdash \texttt{L} : \mv{\Pi}'$
\end{lemma}


\begin{lemma}
  If $\mv{\Pi} \vdash \mathtt{L} : \mv{\Pi}'$ then $\mv{\Pi} \vdash \mathtt{L} : \mv{\Pi}''$ for an environment $\mv{\Pi}''$ generated by $\fjtype{}(\mv{\Pi}, \mathtt{L}) = \mv{\Pi}''$
\end{lemma}

\begin{theorem}\textbf{Completeness:}
  If $\vdash \ol{L} : \mv{\Pi}$, then $\vdash \ol{L} : \mv{\Pi}'$ for a environment $\mv{\Pi}'$ generated by 
  $\fjtype{}(\emptyset,\ol{L}) = \mv{\Pi}'$ 
\end{theorem}

%\begin{lemma}
%  \textbf{Expression Soundness:}
%  %If $\mathtt{\Pi; \Delta ; \ol{x}:\ol{T},\ this : \exptype{C}{\ol{X}} \vdash e_0 : S}$ and $\mathtt{\exptype{}{} \ol{T} \to T \in
%  %\Pi(\exptype{C}{\ol{X}}.m)}$
%  If $\mathtt{\exptype{C}{\ol{X}}.m \mapsto \exptype{}{} \ol{\itype{T}} \to \itype{T} \in \ol{\methodAssumption} }$
%  and
%  $\vdash e : T$
%  , then 
%\end{lemma}

\begin{lemma}
  A type assignment which satisfies the constraints generated by \FGJType also satisfies the type rules of our \TFGJ language.
\end{lemma}
\textbf{Proof:}
We show that the constraints generated by \textbf{GFJTYPE}
represent the type rules given in chapter \ref{chapter:type-rules}.
For most of the expression typing rules this is trivial.
Such as \texttt{GT-VAR}, \texttt{GT-FIELD} and \texttt{GT-NEW}.
The \texttt{GT-INVK} and \texttt{GT-L-INVK} rules are covered by the same constraints.
They just differ in the assumptions used to create those constraints.
For local method calls the method assumption comes without generic type variables ($\mathtt{\ol{Y}}$).
This has the effect that the type variables of this assumption will not be freshly instantiated
via $\mathtt{[\textbf{fresh}(\ol{Y})/\ol{Y}]}$, because $\mathtt{\ol{Y}}$ is empty.
This prevents polymorphic recursion for local method calls.

\begin{theorem}

\end{theorem}
%Theorem: The Unify algorithm is complete
%Theorem: \textbf{FJTYPE} generates the principal type
\textbf{Proof:} The \unify{} algorithm is complete, so every correct type is included in the solution set.
We only have to choose the right type out of those solutions.
When compiling multiple classes the problem arises,
that only one of the type solutions calculated by \unify{} is correct
in respective to the other classes that will be compiled afterwards.

All types that are possible under the FGJ typing rules, plus our additional assumptions,
also comply with the generated constraints.

We match every generated constraint with the respective type rule to show completeness of our \textbf{FJTYPE} algorithm.
This shows that none of the generated constraints remove a type which otherwise would be possible under the \TFGJ typing rules.
The constraints are generated on expression statements.
We now compare the constraints for each expression with the appropriate type rule from \TFGJ:
\begin{description}
  \item [this]
  has always the type of the surrounding class and generates no constraints.
  \item [Local var]
  No constraints are generated.
  \item[Method invocation (\texttt{GT-INVK})]
The \texttt{GT-INVK} rule is for method calls, which already have a type assignment.
By direct comparison we show that each of the generated constraints applies the same restrictions than the \texttt{GT-INVK} rule.
The \texttt{GT-INVK} rule states the condition $\textit{mtype}(m, \textit{bound}_\triangle(T_0)) = \exptype{}{\ol{Y}}\ \ol{U} \to U$.
%In our version of typeless FGJ every method name is unique
%and there is only one class with that particular method.
The constraint $\type{R} \lessdot \exptype{C}{\ol{X}}$ assures that the type of the expression $e_0$ contains the method \texttt{m}.

\begin{small}
\begin{tabularx}{\linewidth}{lX|Xl}
  \textbf{FGJ Type rule} &&& \textbf{Constraints} \\
  $\triangle; \Gamma \vdash e_o : T_0$ &&& $(\type{R}, ConS) = \typeExpr(Ass, e_r)$\\ 
  $\mathtt{\textit{bound}(T_0)}$ &&& $\type{R} \lessdot \exptype{C}{\ol{X}}$ \\
  $\mathtt{\exptype{}{\ol{Y} \triangleleft \ol{P}}\ \ol{U} \to U} \in \textit{mtype}(m, N)$ &&& Lookup in the assumptions \\
 %$\textit{mtype}(m, \textit{bound}_\triangle(T_0)) = \ol{U} \to U$ & $\type{R} \doteq cl$\\
 $\triangle; \Gamma \vdash \ol{e} : \ol{S}$ &&& $\forall e_i \in \overline{e} : (pt_i, ConS_i) = \typeExpr(Ass, e_i)$\\
 $\triangle \vdash \ol{S} <: \ol{U}$ &&& $ \bigcup_{T_i \in \overline{T}} (pt_i \lessdot T_i)$\\
 $\triangle; \Gamma \vdash \mathtt{e_0.m(\overline{e}) : U }$ &&& $a \doteq T$ \\
\end{tabularx}
\end{small}

\textit{Note}: The \typeExpr{} function only generates constraints which apply to our assumption.
\item[Method invocation (\texttt{GT-L-INVK})]
The \texttt{GT-INVK} rule is for local method calls.
The called method does not have a type yet and comes with type variables for the return and parameter types.
The difference for a normal method call is that we do not generate fresh type variables.
This results in the local method call not being polymorphic.
%TODO: Rewrite GT-INVK proof
%      Rewrite the FGJType algorithm for local method calls


 \item[Field access]
Mostly the same as method invocation.
Fieldnames by default are unique in the FGJ language.

 \begin{tabular}{l|l}
   \textbf{FGJ Type rule} & \textbf{Constraints} \\
   $\Gamma \vdash e_0:T_0$ & $(\type{R}, ConS) = \typeExpr(Ass, e_r)$\\ 
   $\quad \mathit{fields}(\mathit{bound}_\triangle(T_0)) = \overline{T} \ \overline{f}$ & $\type{R} \doteq \exptype{C}{\textbf{fresh}(\ol{X})}$ \\
  %$\textit{mtype}(m, \textit{bound}_\triangle(T_0)) = \ol{U} \to U$ & $\type{R} \doteq cl$\\
  $\triangle; \Gamma \vdash \ol{e} : \ol{S}$ & $\forall e_i \in \overline{e} : (pt_i, ConS_i) = \typeExpr(Ass, e_i)$\\
  $\triangle \vdash \ol{S} <: \ol{U}$ & $ \bigcup_{T_i \in \overline{T}} (pt_i \lessdot \textbf{fresh}(T_i))$\\
  $\triangle; \Gamma \vdash \mathtt{e_0.m(\overline{e}) : U }$ & $a \doteq \textbf{fresh}(T)$ \\
 \end{tabular}
 \item[Constructor]

\begin{tabular}{l|l}
  $\triangle; \Gamma \vdash \ol{e} : \ol{S}$ & $\forall e_i \in \overline{e} : (pt_i, ConS_i) = \typeExpr(Ass, e_i)$\\
  $\triangle \vdash \ol{S} <: \ol{T}$ & $\bigcup_{T_i \in \overline{T}} (pt_i \lessdot T_i)$
\end{tabular}

\item[Cast]
A cast can either be an upcast or a downcast or a so called stupid cast.
See respective type rules \texttt{GT-UCAST}, \texttt{GT-DCAST}, \texttt{GT-SCAST} in chapter \ref{chapter:type-rules}.
%Every type of cast is allowed in \TFGJ, therefore no restrictions in form of constraints are needed.
%The check if the cast type $\mathtt{N}$ is well formed ($\mathtt{N}\ \text{ok}$) is done in advance to the \textbf{FJTYPE} algorithm.
We assume that each given type in our input set is well-formed.
Therefore the cast type $\mathtt{N}$ is well formed ($\mathtt{N}\ \text{ok}$) too.
So every possible type of cast is allowed in \TFGJ, therefore no restrictions in form of constraints are needed.

\end{description}

\input{unify}

\input{unifyProof}

\section{Complexity}
\label{sec:complexity}

\input{complexity}

\section{Examples}
\label{sec:examples}

\input{examples}

\textbf{Example 1}\\
The algorithm is able to infer the types of multiple classes under specific circumstances.
The individual classes must be given to him after one another.
This comes with the restriction, that the first class is correct on its own and does not use any other class.
The second class that gets compiled can use the first class and so on.

The following example shows how the algorithm infers and compiles multiple classes iteratively.
The class \texttt{Class1} is infered first.
It has only one method which is the identity function,
to which our algorithm allocates the type $\exptype{}{A}\ A \to A$.
The next class \texttt{Class2} is now able to use this generic method.
The blue colored types are inferred in the next iteration of our algorithm.

\begin{table}
\caption{Two classes as input. \texttt{Class1} is infered first (shown in {\color{red}red})}
\begin{tabular}{cc}
\begin{lstlisting}
class Class1 extends Object {
  Class1() { super(); }
  id(a){
    return a;
  }
}
class Class2 extends Class1 {
  Class2() { 
    super(); 
  }
  example(){
    return new Class1().id(this);
  }
}
\end{lstlisting}
&
\begin{lstlisting}
class Class1 extends Object {
  Class1() { super(); }
  (*@ \textcolor{red}{<A> A} @*) id((*@ \textcolor{red}{A} @*) a){
    return a;
  }
}
class Class2 extends Class1 {
  Class2() { 
    super(); 
  }
  (*@ \textcolor{blue}{Class1}@*) example(){
    return this.(*@\textcolor{blue}{<Class1>}@*)id(this);
  }
}
\end{lstlisting}
\end{tabular}
\end{table}

\textbf{Example 2}\\
When compiling a class like the following
we have to first split this class into two classes.
The \texttt{TwoMethods} class can be first split into the classes \texttt{Class1}
and \texttt{Class2} and after being processed by the type inference algorithm it can be assembled back together again.
This leads to a principal typing.
When using our type inference algorithm on the class \texttt{TwoMethods} alone
it would give the method \texttt{id} the type $\texttt{TwoMethods} \to \texttt{TwoMethods}$,
which is not the desired principal type.
\begin{lstlisting}
class TwoMethods extends Object {
  TwoMethods() { super(); }
  id(a){
    return a;
  }
  example(){
    return this.id(this);
  }
}
\end{lstlisting}

\textbf{Example 3}\\
%TODO: Ein Beispiel für die Unify-adapt Regel
FGJ allows subtype relations like the following:
\begin{lstlisting}
class Map<A,B> extends Object {
  Map<A,B>() { super(); }
}
class SpecialMap<A,B,C> extends Map<A,C> {
  SpecialMap<A,B,C>() { super(); }
}
\end{lstlisting}

If for example we have a method \texttt{method} like this:
\begin{lstlisting}
<X> void method(Map<X, String> map){
  ...
}
\end{lstlisting}
and call it:
\begin{lstlisting}
method(new SpecialMap<Object,Integer,String>());
\end{lstlisting}

Then the constraint $\exptype{SpecialMap}{Object,Integer,String} \lessdot \exptype{Map}{X,String}$
is generated by the \textbf{FJTYPE} algorithm.
This constraint will be processed by the \texttt{adapt} rule of the \unify{} algorithm.
Remember that $(\exptype{SpecialMap}{A,B,C} \olsub \exptype{Map}{A,C}) \in S_\leq$.
\begin{align*}
  Eq& \cup \exptype{SpecialMap}{Object,Integer,String} \lessdot \exptype{Map}{X,String} \\
  \cline{1-2} 
  Eq& \cup \set{\exptype{Map}{[ Object / A ][ Integer / B ][ String / C ](A,C)}
  \doteq \exptype{Map}{X,Integer}} \\
  \cline{1-2} 
  Eq& \cup \set{\exptype{Map}{Object,String}
  \doteq \exptype{C}{X, Integer}}
%Eq \cup \set{\theta_1 \doteq \lambda'_1 \ldo \theta_n \doteq \lambda'_n}
\end{align*}

After the \texttt{adapt} rule got applied we can already see that a correct unificator for this constraint would be
$\sigma(X) = \texttt{Object}$.

\textbf{Example 4 (Multiple type solutions):}
\begin{lstlisting}
class List<A> extends Object {
  List<A> add(A p){...}
}
class C1 extends Object {
  m1(ls){
    return ls.add(this);
  }
}
class C2 extends Object {
  m2(){
    return new C1().m1(new List<C1>());
  }
}
\end{lstlisting}
When compiling the class \texttt{C1} there are two possible method typings for \texttt{m1}.
One of it would 
\begin{lstlisting}
class List<A> extends Object {
  List<A> add(A p){...}
}
class C1 extends Object {
  List<Object> m1((*@\color{red}List<Object>@*) ls){
    return ls.add(this);
  }
}
class C2 extends Object {
  m2(){
    return new C1().m1((*@\color{red}new List<C1>()@*));
  }
}
\end{lstlisting}
\texttt{List<Object>} would be a correct type for the parameter \texttt{ls}.
The call \texttt{ls.add(this)} still works because the type of \texttt{this} is a subtype of \texttt{Object}.
But then the method \texttt{m2} will be incorrect when compiling the class \texttt{C2}.
Our algorithm has to backtrack to the class \texttt{C1} and use the other possible typing.
The following would be the correct solution with \texttt{List<C1>} as the type for \texttt{ls}.
\begin{lstlisting}
class List<A> extends Object {
  List<A> add(A p){...}
}
class C1 extends Object {
  List<C1> m1((*@\color{green}List<C1>@*) ls){
    return ls.add(this);
  }
}
class C2 extends Object {
  List<C1> m2(){
    return new C1().m1((*@\color{green}new List<C1>()@*));
  }
}
\end{lstlisting}

\textbf{Example 5} (for global type inference)
\begin{lstlisting}

\end{lstlisting}

\section{Assessment}
\label{sec:assessment}

\begin{itemize}
\item NP-hard \todo[inline]{Show NP-completeness!}
\item cannot infer all possible generic methods
\item features that need to be addressed to make it practical (e.g.,
  what's necessary to move from FGJ to full Java: overloading,
  imperative, )
\end{itemize}

Java has some features which make global type inference hard:
\begin{itemize}
\item subtyping and overloading combined with a nominal type system;
  we show NP-hardness even without overloading
  \todo[inline]{correct?}
\item mutable local variables and mutable object state,
\item polymorphic recursion in method calls
\item Inside a Java method it is possible to call every other declared Java method
  \todo[inline]{meaning? The letrec-rule works on the fact that in a let statement:
  \lstinline{let x = e in e2} the expression \texttt{e} is not able to use \texttt{x}}
\item methods can have side effects.
\end{itemize}


For Featherweight Generic Java it is easier to decide because there is no state and therefore no wildcard types.
Also we exclude polymorphic recursion.

% Example for local type inference in Java:
% \begin{lstlisting}[language=java]
% // Java 8 code:
% class Local {
%   // type inference puts in "ArrayList<String>()"
%   List<String> field = new ArrayList<>();
% }
% \end{lstlisting}
% \todo[inline]{Is this a drawback for LVTI? Does GTI put
%   \lstinline{List<String>} or \lstinline{Map} in the
%   \lstinline{outerMap} example?}

\section{Limitations of the algorithm}
\label{sec:limits-algorithm}

Java does not allow generic variables with lower bounds.
The expression \texttt{<A super String>} is not a correct definition in FJ.

Take the following input program as an example:
\begin{lstlisting}{java}
class Example{
    method(list){
        return list.add(this).get();
    }
}
\end{lstlisting}
Lets assume this yields the constraints:
$p \lessdot \exptype{List}{b}, r \lessdot \exptype{List}{b}, \texttt{Example} \lessdot b$
Now we cannot insert a generic type variable with super bounds like this:
\texttt{B super Example}

We have to still calculate every possible supe\type{R}pe of \texttt{Example} which will lead to an array of possible solutions.


\section{Related Work}
\label{sec:related-work}

\input{relatedWork}

\section{Conclusions}
\label{sec:conclusions}


%\bibliographystyle{splncs04}
\bibliography{peter,martin}

\end{document}
\endinput
%%
%% End of file `TIforGFJ.tex'.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
