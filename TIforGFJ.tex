%%
%% This is file `sample-acmsmall-submission.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `acmsmall-submission')
%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-acmsmall-submission.tex.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%% The first command in your LaTeX source must be the \documentclass command.
\documentclass[acmsmall,screen,review]{acmart}

\usepackage{prolog}

%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmcopyright}
\copyrightyear{2018}
\acmYear{2018}
\acmDOI{10.1145/1122445.1122456}


%%
%% These commands are for a JOURNAL article.
\acmJournal{JACM}
\acmVolume{37}
\acmNumber{4}
\acmArticle{111}
\acmMonth{8}

%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}

%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Type inference for Generic Featherweight Java}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Andreas Stadelmeier}
\affiliation{%
  \institution{DHBW Stuttgart, Campus Horb}
  \streetaddress{Tannenweg 4}
  \city{Tübingen}
  \country{Germany}}
\email{a.stadelmeier@hb.dhbw-stuttgart.de}


%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
\renewcommand{\shortauthors}{Stadlmeier, Plümicke, Thiemann}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
  Type inference for Generic Featherweight Java
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
\begin{CCSXML}
<ccs2012>
 <concept>
  <concept_id>10010520.10010553.10010562</concept_id>
  <concept_desc>Computer systems organization~Embedded systems</concept_desc>
  <concept_significance>500</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010575.10010755</concept_id>
  <concept_desc>Computer systems organization~Redundancy</concept_desc>
  <concept_significance>300</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010553.10010554</concept_id>
  <concept_desc>Computer systems organization~Robotics</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
 <concept>
  <concept_id>10003033.10003083.10003095</concept_id>
  <concept_desc>Networks~Network reliability</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Computer systems organization~Embedded systems}
\ccsdesc[300]{Computer systems organization~Redundancy}
\ccsdesc{Computer systems organization~Robotics}
\ccsdesc[100]{Networks~Network reliability}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{typeinference, java, compiler}


%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}

\section{Preliminaries}

\subsection{Input assumptions}
% No overloaded methods
% No Or-Constraints
The input is a GFJ program lacking the type assignments for method parameters and method return types.


The Typeless Generic Featherweight Java (TGFJ) syntax is different in that from normal Generic Featherweight Java (GFJ) that it is possible
to omit any type annotation.%, except the ones for casts and \texttt{new} calls.
We declare the syntax for TGFJ as follows:

\begin{align*}
  T ::=& X \, | \, N \\
  N ::=& \exptype{C}{\ol{T}}\\
  L ::=& \mathtt{class } \ \exptype{C}{\ol{X} \triangleleft \ol{N}} \ \triangleleft \ N \{ \overline{T} \ \overline{f}; \, K \, \overline{M} \} \\
  K ::=& C(\overline{T} \ \overline{f})\{\mathtt{super}(\overline{f}); \ \mathtt{this}.\overline{f}=\overline{f};\} \\
  %M ::=& \exptype{}{\ol{X} \triangleleft \ol{X}}\ T \ \mathtt{m}(\overline{T} \, \overline{x})\{ \mathtt{ return }\ e; \} \\
  M ::=& \mathtt{m}(\overline{x})\{ \mathtt{ return }\ e; \} \\
  e ::=& \mathtt{this} \, | \, x \, | \, e.f \, | \, e.\mathtt{m}(\overline{e}) \, | \, \mathtt{new }\ C(\overline{e}) \, | \, (C) e
  %M ::=& T \ \mathtt{m}(\overline{T} \, \overline{x})\{ \mathtt{ return }\ e; \} \\
  %e ::=& \mathtt{this} \, | \, x \, | \, e.f \, | \, e.\exptype{\mathtt{m}}{\ol{T}}(\overline{e}) \, | \, \mathtt{new }\ C(\overline{e}) \, | \, (C) e \\
\end{align*}

All type annotations in our TGFJ language can be omitted ($T = \epsilon$).
The only exception are fields which must be given a concrete type.

Another difference to the syntax of FJ is that we added the special variable \texttt{this} to the syntax.
FJ treats \texttt{this} as a normal variable
but our algorithm treats it as a special variable which always has a predetermined type;
the type of the class it is used in.

We assume every method name is only used once in the input program.

Type inference for polymorphic recursion is undecidable.
Therefore we have to alter the GFJ typing rules to exclude polymorphic recursion in method calls:
\begin{enumerate}
    \item The \texttt{MT-CLASS} rule is removed.
    \item We change the \texttt{GT-METHOD} rule:
GT-METHOD:
\begin{align*}
\ddfrac{\begin{array}{c}
\triangle \vdash \ol{X} <: \ol{N}, \ol{Y} <: \ol{P}  \quad \quad 
\triangle \vdash \ol{T}, T \ \texttt{ok} \\
\triangle ; \ol{x}:\ol{T}, this : \exptype{C}{\ol{X}} \vdash e_0 : S \quad \quad
\triangle \vdash S <: T \\
\texttt{class}\ \exptype{C}{\ol{X} \triangleleft \ol{N}} \triangleleft N \{ \ldots \} \quad \quad
%\textit{override}(m, N, \exptype{}{\ol{Y} \triangleleft \ol{P}} \ol{T} \to T)
\textit{mtype}(m, \exptype{C}{\ol{X}}) := \ol{T} \to T \\
%\textit{override}(m, N,)
\end{array}}{
%{\exptype{}{\ol{Y} \triangleleft \ol{P}}\ T \ m(\ol{T}\ \ol{x}) \{ \texttt{return} \ e_0; \} \ \texttt{OK IN}\ \exptype{C}{\ol{X} \triangleleft \ol{N}}}
\textit{mtype}(m, \exptype{C}{\ol{Z}}) = [\ol{Z} / \ol{X}](\exptype{}{\ol{Y}} \ol{T} \to T)
}
\end{align*}
\end{enumerate}

\subsection{Principal Type}
%TODO: Subtype definition:

%In our input set we exclude method overloading.
%Also every method name has to be unique.
%These assumptions allows us to make the following definition of a principal type:

GFJ supports two kinds of types;
Type variables and nonvariable types.
Nonvariable types have the form $\exptype{C}{\ol{T}}$ and can contain multiple type variables.
The type $T_2 = [N/X]\exptype{C}{\ol{T}}$ is a generic instantiation,
where all occurences of the type variable $X$ are replaced by the nonvariable type $N$.

\textbf{Principal Type:}
A nonvariable type for a declaration is a principal nonvariable type,
if any other type-scheme for the declaration is a subtype of a generic instance
of the type-scheme.

Additionally we define the subtype relation of methods as follows:
\begin{align*}
\ddfrac{
\ol{T} \ \leq^* \ \ol{U} \quad \quad U \ \leq^* \ T
}{
\ol{T} \to T \ \leq^* \ \ol{U} \to U
}
\end{align*}

%\begin{theoremAndi}
%  \label{theo:uniquePrincipalType}
%  \textbf{There is one unique principal type for any set of types}
%\end{theoremAndi}

%what about: c<A,Int>, c<Int, A> which is principal type?

\begin{theoremAndi}
  \label{theo:uniquePrincipalType}
  \textbf{There is one unique principal type for every method}
\end{theoremAndi}
Proof:
%We excluded polymorphic recursion
%Every expression $e$ in GFJ has a definitive type.
%%There is only one possible type our type inference algorithm can apply to any expression $e$.
%We will show this for every kind of expression:
%\begin{description}
  %\item[NEW] \texttt{new} can only have one type according to the \texttt{GT-NEW} type rule.
  %\item[Field access] A field access $e.f$ can only have one type according to the \texttt{GT-FIELD} type rule.
  %This also applies to our typeless GFJ version, because every field name has to be unique.
  %\item[Method call] We assume method names are also unique and cannot be overloaded.
  %Due to this assumption and the changed \texttt{GT-METHOD} rule a method type of a method \texttt{m}
  %is: $\textit{mtype(m, N) = \ol{T} \to T}$.
  %%The type of the respective method call $e.m(\ldots)$ is defined by \texttt{GT-INVK} as $T$.
  %%The return type $T$ of the method \texttt{m} is unique, because the 
%\end{description}

We exclude polymorphic recursion, remove overloading and assume every method and field name to be unique.
Now every method $T\ \texttt{m}(\ol{T}\ \ol{x})\{\ \texttt{return}\ e;\ \}$ has one principal type.
This is when its return type $T$ is the same type as its return expression $e$.
For the parameter types $\ol{T}$ the principal type is chosen.

\textit{Example:}
A method \texttt{m} can have multiple possible types due to the fact that GFJ has subtypes.

\begin{lstlisting}
class C1 {
  C1 f;
}
class C2 extends C1{
  m(x){
    return x.f;
  }
}
\end{lstlisting}
The method \texttt{m} can either have the type \texttt{C1 m(C1 x)}
or \texttt{C1 m(C2 x)}.
In this case the principal type would be \texttt{C1 m(C1 x)}.
This type has the type of the return expression as its return type
and for every parameter type it has the principal type.
%The principal type is unique
%No overloading, therefore no types int -> int, byte -> byte

\section{Type inference algorithm}
In this chapter we present our type inference algorithm.
The algorithm is split into following parts:

\begin{enumerate}
\item Create assumptions and subtype relation
\item Constraint generation with \textbf{GFJTYPE}
\item Unification of those constraints
\item Set in a type solution
\end{enumerate}


\subsection{Generate Assumptions}
% Every empty Type T in the input is assigned a type variable.
% Assumptions saves every field, method and the class subtype relation

%Generate subtype relationships:

Generating assumptions consists of two parts.
At first we add type variables to the untyped class.
The second part generates the assumption set.
This is the same algorithm for the already typed classes as for the 
new untyped class, which is now equipped with type variables.

\begin{enumerate}
\item Every missing type in the input class gets assigned a fresh type variable.
For methods:
\begin{align*}
  \ddfrac{
  m(\ol{x}) \{ \ldots \} \quad \quad A \cup \ol{A} \ \text{are fresh type variables}
  }{
  A m(\ol{A}\ \ol{x}) \{ \ldots \}
  }
  \end{align*}
  For fields:
\begin{align*}
  \ddfrac{
  \texttt{class}\ \exptype{C}{\ol{X}} \{ \ol{f}; \quad \ldots \} \quad \quad \ol{F} \ \text{are fresh type variables}
  }{
    \texttt{class}\ \exptype{C}{\ol{X}} \{ \ol{F} \ \ol{f}; \quad \ldots \}
  }
\end{align*}
\item We define the two functions $\textit{ftype}_\textit{Ass}$ and $\textit{mtype}_\textit{Ass}$.
Both functions return a set of all types for a method \texttt{m} or a field \texttt{f}.
This is due to the fact that there can be multiple methods and fields with the same name.
\begin{align*}
  %TODO: fresh type variables for generic variables:
  \ddfrac{
    class\ \exptype{C}{\ol{X} \triangleleft \ol{N}}\ \{\ \ol{N}\ \ol{f};\ K\ \ol{M}\ \} \quad \quad
    \exptype{}{\ol{Y}}\ U\ \texttt{m}(\ol{U}\ \ol{x}) \{ \ldots \} \in \ol{M}
  }{
    \textit{mtype}_\textit{Ass}(\texttt{m}) = \exptype{C}{\ol{X} \triangleleft \ol{N}} \to \exptype{}{\ol{Y}} (\ol{U} \to U )
  }
\end{align*}
\begin{align*}
  \ddfrac{
    class\ \exptype{C}{\ol{X} \triangleleft \ol{N}}\ \{\ \ol{T}\ \ol{f};\ K\ \ol{M}\ \} \quad \quad
    T\ \texttt{f} \in \ol{f}
  }{
    \textit{ftype}_\textit{Ass}(\texttt{f}) = \exptype{C}{\ol{X} \triangleleft \ol{N}} \to T
  }
\end{align*}
\item We do not include casts in the syntax and therefore remove the \texttt{GT-UCAST} and \texttt{GT-DCAST} typing rules.
\end{enumerate}


\subsection{GFJTYPE}

The algorithm \textbf{GFJTYPE} is given as follows:

\textbf{FJTYPE}:
$\texttt{TypeAssumptions} \times
\texttt{Class} \rightarrow \texttt{Constraints}\\
 \begin{array}{@{}l@{}l@{}l}
 \textbf{FJT}&\textbf{Y} & \textbf{PE}(Ass, \mathtt{class } \ C \ \mathtt{ extends } \ D \{ \overline{T} \ \overline{f}; \, K \, \overline{M} \}) =\\
& \multicolumn{2}{@{}l@{}}{ \{ \ \textbf{TYPEMethod}(\textit{Ass} \cup \{ \mathtt{this} : C \}, m_i) \quad | \quad m_i \in \overline{M} \ \} }\\ 
\end{array}$

The \textbf{FJTYPE} function gets called for every class in the input.
This function accumulates all the constraints generated from calling the
\textbf{TYPEMethod} function for each method declared in the given class.

$\textbf{TYPEMethod}:\texttt{TypeAssumptions} \times
\texttt{Method} \rightarrow \texttt{Constraints}\\
\begin{array}{@{}l@{}l@{}l}
\textbf{TY}& \textbf{PE} & \textbf{Method} (Ass, T_r \ \mathtt{m}(\overline{T} \, \overline{x})\{ \mathtt{ return }\ e; \}) =\\
& \textbf{let}
& Ass_m = Ass \cup \{ \overline{T} : \overline{x} \}\\
& & \ul{(e:rty, ConS)} = \textbf{TYPEExpr}(Ass_m, e)\\
& \mathbf{in}
& (ConS \cup (rty \lessdot T_r))\\
\end{array}
$

The \textbf{TYPEMethod} function for methods just calls the \textbf{TYPEExpr} function with the
return expression. It is significant to note that it adds the assumptions for the method parameters to the global assumptions before passing them to \textbf{TYPEExpr}.
%and the global assumptions plus the assumptions for the method parameters.

\smallskip

In the following we define the \textbf{TYPEExpr} function for every possible expression:

\smallskip

$\textbf{TYPEExpr}:\texttt{TypeAssumptions} \times
\texttt{Expression} \rightarrow \texttt{Type} \times \texttt{Constraints}\\
\begin{array}{@{}l@{}l}
\textbf{TY} \textbf{PE} & \textbf{Expr} (Ass, \mathtt{this}) = (t , \{\})\\
& \textbf{with } (\mathtt{this} : t) \in Ass 
\end{array}
$
\smallskip
$\begin{array}{@{}l@{}l}
\textbf{TY} \textbf{PE} & \textbf{Expr} (Ass,x) = (t , \{\})\\
& \textbf{with } (x : t) \in Ass 
\end{array}
$

\smallskip

$\begin{array}{@{}l@{}l@{}l}
\textbf{TY}& \textbf{PE} & \textbf{Expr} (Ass, e.f ) = \\
& \textbf{let} % \\
% &
& (rty, ConS) = \textbf{TYPEExpr}(Ass, e),\\
& & \textbf{fresh} = \text{a mapping from each variable in}\ \ol{X} \ \text{to a fresh type variable},\\
& & Ass_{f} = \textit{ftype}_{Ass}(f) = \exptype{C}{\ol{X} \triangleleft \ol{N}} \to T \\
& & Cons_{f} = \{\ rty \doteq \exptype{C}{\textbf{fresh}(\ol{X})}, a \doteq \textbf{fresh}(T)\},\\
%& & OrCons = \{ \{ rty \doteq cl, a \doteq t_f \} \ | \ cl.f : t_f \in Ass \},\\
& \mathbf{in}% \\
% &
& (a, ConS \cup Cons_{f})\\
& & \mathit{where\ } a \mathit{\ is\ a\ fresh\
  type\ variable}\\ 
\end{array}
$

\smallskip

$\begin{array}{@{}l@{}l@{}l}
\textbf{TY}& \textbf{PE} & \textbf{Expr} (Ass, e_r.\mathtt{m}(\overline{e}) ) = \\
& \textbf{let} % \\
% &
& (rty, ConS) = \textbf{TYPEExpr}(Ass, e_r),\\
& & \forall e_i \in \overline{e} : (pt_i, ConS_i) = \textbf{TYPEExpr}(Ass, e_i)  ,\\
& & \textbf{fresh} = \text{a mapping from each variable in}\ \ol{X} \ \text{to a fresh type variable},\\
& & Ass_{m} = \textit{mtype}_{Ass}(m) = \exptype{C}{\ol{X} \triangleleft \ol{N}} \to \exptype{}{\ol{Y}} (\ol{T} \to T) \\
& & \begin{array}{@{}l@{}l}
        Cons_{m} = \{\ & rty \doteq \exptype{C}{\textbf{fresh}(\ol{X})}, a \doteq \textbf{fresh}(T),\\
                    & \bigcup_{T_i \in \overline{T}} (pt_i \lessdot \textbf{fresh}(T_i)) \} %, \textbf{fresh}(\ol{X}) \lessdot \textbf{fresh}(\ol{N})\},\\
    \end{array}\\
& \mathbf{in}% \\
% &
& (a, ConS \cup Cons_{m} \cup \bigcup_i ConS_i))\\
& & \text{where\ } a \text{\ is\ a\ fresh\
  type\ variable}\\ 
\end{array}
$

\smallskip

$\begin{array}{@{}l@{}l@{}l}
\textbf{TY}& \textbf{PE} & \textbf{Expr} (Ass, \mathtt{new }\ N(\overline{e}) ) = \\
& \textbf{let} % \\
& \forall e_i \in \overline{e} : (pt_i, ConS_i) = \textbf{TYPEExpr}(Ass, e_i)  ,\\
& & Cons = \{ \bigcup_{T_i \in \overline{T}} (pt_i \lessdot T_i) \ | \ \mathtt{constructor }\ \exptype{C}{\ol{X}}(\overline{T} \overline{x}) \in Ass \},\\
& \mathbf{in}% \\
% &
& (C, ConS \cup \bigcup_i ConS_i)\\
\end{array}
$


\subsection{Completeness}
Theorem: The Unify algorithm is complete
Theorem: \textbf{GFJTYPE} generates the principal type
Proof: The \textbf{Unify} algorithm is complete, so the principal type is included in the solution set.
We only have to choose the principal type out of those solutions.

All types that are possible under the GFJ typing rules, plus our additional assumptions,
also comply with the generated constraints.

We match every generated constraint with the respective type rule to show completeness of our \textbf{GFJTYPE} algorithm.
This shows that none of the generated constraints remove a type which otherwise would be possible under the GFJ typing rules.
The constraints are generated on expression statements.
We now compare the constraints for each expression with the appropriate type rule from GFJ:
\begin{description}
  \item [this]
  has always the type of the surrounding class and generates no constraints.
  \item [Local var]
  No constraints are generated.
  \item[Method invocation]
By direct comparison we show that each of the generated constraints do not apply more restrictions than the \texttt{GT-INVK} rule.
The \texttt{GT-INVK} rule states the condition $\textit{mtype}(m, \textit{bound}_\triangle(T_0)) = \exptype{}{\ol{Y}}\ \ol{U} \to U$.
In our version of typeless GFJ every method name is unique
and there is only one class with that particular method.
The constraint $rty \lessdot \exptype{C}{\textbf{fresh}(\ol{X})}$ assures that the type of the expression $e_0$ contains the method \texttt{m}.

\begin{tabular}{l|l}
  \textbf{GFJ Type rule} & \textbf{Constraints} \\
  $\triangle; \Gamma \vdash e_o : T_0$ & $(rty, ConS) = \textbf{TYPEExpr}(Ass, e_r)$\\ 
  $\quad \textit{mtype}(m, \textit{bound}_\triangle(T_0)) = \exptype{}{\ol{Y}}\ \ol{U} \to U$ & $rty \lessdot \exptype{C}{\textbf{fresh}(\ol{X})}$ \\
 %$\textit{mtype}(m, \textit{bound}_\triangle(T_0)) = \ol{U} \to U$ & $rty \doteq cl$\\
 $\triangle; \Gamma \vdash \ol{e} : \ol{S}$ & $\forall e_i \in \overline{e} : (pt_i, ConS_i) = \textbf{TYPEExpr}(Ass, e_i)$\\
 $\triangle \vdash \ol{S} <: \ol{U}$ & $ \bigcup_{T_i \in \overline{T}} (pt_i \lessdot \textbf{fresh}(T_i))$\\
 $\triangle; \Gamma \vdash \mathtt{e_0.m(\overline{e}) : U }$ & $a \doteq \textbf{fresh}(T)$ \\
\end{tabular}

\textit{Note}: The \textbf{TYPEExpr} function only generates constraints which apply to our assumption.
 \item[Field access]
Mostly the same as method invocation.
Fieldnames by default are unique in the GFJ language.

 \begin{tabular}{l|l}
   \textbf{GFJ Type rule} & \textbf{Constraints} \\
   $\Gamma \vdash e_0:T_0$ & $(rty, ConS) = \textbf{TYPEExpr}(Ass, e_r)$\\ 
   $\quad \mathit{fields}(\mathit{bound}_\triangle(T_0)) = \overline{T} \ \overline{f}$ & $rty \doteq \exptype{C}{\textbf{fresh}(\ol{X})}$ \\
  %$\textit{mtype}(m, \textit{bound}_\triangle(T_0)) = \ol{U} \to U$ & $rty \doteq cl$\\
  $\triangle; \Gamma \vdash \ol{e} : \ol{S}$ & $\forall e_i \in \overline{e} : (pt_i, ConS_i) = \textbf{TYPEExpr}(Ass, e_i)$\\
  $\triangle \vdash \ol{S} <: \ol{U}$ & $ \bigcup_{T_i \in \overline{T}} (pt_i \lessdot \textbf{fresh}(T_i))$\\
  $\triangle; \Gamma \vdash \mathtt{e_0.m(\overline{e}) : U }$ & $a \doteq \textbf{fresh}(T)$ \\
 \end{tabular}
 \item[Constructor]

\begin{tabular}{l|l}
  $\triangle; \Gamma \vdash \ol{e} : \ol{S}$ & $\forall e_i \in \overline{e} : (pt_i, ConS_i) = \textbf{TYPEExpr}(Ass, e_i)$\\
  $\triangle \vdash \ol{S} <: \ol{T}$ & $\bigcup_{T_i \in \overline{T}} (pt_i \lessdot T_i)$
\end{tabular}
  
\end{description}

\section{Unify}
This chapter describes the \textbf{GenericUnify} algorithm
which is used to find type solutions for the constraints generated by \textbf{FGJType}.

\begin{description}
\item[input] A set of type constraints $Cons_{in}$ and a set of subtype relationships $S_\leq$
\item[output] A tuple of type unifiers and unassigned type variables $(Uni, vars)$
or fail $Uni = \emptyset$.
The unifiers have the form of $Uni = \{ \sigma_1, \ldots , \sigma_n \}$.
\item[postcondition] If the algorithm succeeds the resulting unifiers $\sigma$ assign a type to every type variable in the input set $Cons_{in}$.
The assigned types for each type variable have the form:
\begin{align*}
T ::= X \ | \ N \\
N ::= \exptype{C}{\ol{T}} \\
X ::= A %\triangleleft N
\end{align*}
where $C$ is a classname existing in $S_\leq$ and $A$ is a generic type variable.
\end{description}

For every $Eq \in Eq_{set}$ the following steps are applied.
%The resulting unifiers $\sigma$ from each $Eq$ merged together form the result of the \textbf{Unify} algorithm.

%$\textbf{SubUnify} :: [Constraint] \to [Unifier]$
\begin{enumerate}
\item Repeated application of the rules depicted in figure \ref{fig:fgjreduce-rules} and \ref{fig:fgjerase-rules}.
The end configuration of $Eq$ is reached if for each element
no rule is applicable.

\item
(The function $\textbf{fresh}(i)$ returns an array of $i$ fresh type variables.)

\begin{align*}
Eq_1 =& \text{Subset of pairs where both type terms are type variables}\\
Eq_2 =& Eq / Eq_1 \\
Eq_{set}\\ 
    = 
     & \begin{array}[t]{l@{\,}ll}
      \times \, (\displaystyle{\bigotimes_{(a \lessdot \exptype{C}{\ol{X}}) \in Eq'_2}}
      \{\,(a \doteq \exptype{D}{\ol{A}}) \, \cup \, (\ol{X} \doteq \ol{Y'}) \ | \ \sarray{@{}l}{
        (\exptype{D}{\ol{Z}} \olsub \exptype{C}{\ol{Y}}) \in S_\leq, \\
        \ol{A} = \textbf{fresh}(\#(\ol{Z})), \\
        \ol{Y'} = [\ol{A}/\ol{Z}]\ol{Y}
        \,\})}\\ 
      \end{array}\\
   %& \times\, 
   %   (\displaystyle{\bigotimes_{(\exptype{C}{\overline{T}} \lessdot a) \in Eq'_2}}\!\!
   %   \set{(a \doteq [\ol{T}/\ol{X}]N ) \ | \ (\exptype{C}{\overline{X}} \leq N) \in
   %     S_\leq})\\
    & \times\, 
      (\displaystyle{\bigotimes_{(\exptype{C}{\overline{T}} \lessdot a) \in Eq'_2}}\!\!
      \set{(a \doteq [\ol{T}/\ol{X}]N ) \ | \ (\exptype{C}{\overline{X} \triangleleft \ol{N}} \leq N) \in
        S_\leq})\\
    & \times\, \set{[a \doteq \theta \ | \  (a \doteq \theta) \in Eq'_2]} \times Eq_1 \\
\end{align*}

\item \label{subst-step}  Application of the following \emph{subst} rule
    %\begin{enumerate}
    %\item Apply the following subst\_eq rule
    
      $$\begin{array}[c]{lll}
        (\mathrm{subst}) &
        \begin{array}[c]{l}
          Eq'' \cup \set{a \doteq \theta}\\
          \hline
          Eq''[a \mapsto \theta] \cup \set{a \doteq \theta}
        \end{array}
        & a \textrm{ occurs in } Eq'' \textrm{ but not in } \theta 
      \end{array}$$
      
      for each $a \doteq \theta$ in each element of $Eq' \in Eq'_{set}$.

\item 
    \begin{enumerate}
    \item Foreach $Eq \in Eq_{set}$ which has changed in the last step
      start again with the first step.
    \item Build the union $Eq_{set}$ of all results of (a) and all $Eq' \in
      Eq'_{set}$ which has not changed in the last step.
    \end{enumerate}
\item
  We can set all TVs equal, because we allow only same TVs when having circles in a method call.
  This still will lead to the principal type.
  We apply the following rule to set all type variables equal:
  \begin{align*}
  \ddfrac{
    Eq \cup \set{ a \lessdot b } %There are only Type variables left at this point
  }{
    Eq \cup \set{ a \doteq b }
  }
  \end{align*}
\item
$\emph{Uni} = \sarray{l@{\ }l}{\set{\sigma \ | & Eq'' \in Eq''_{set},
        Eq'' \textrm{ is in solved form,}\\ 
        & \sigma = \set{a \mapsto \theta \ | \ (a \doteq \theta) \in Eq''}
        \\ & \quad \cup \ \set{a \mapsto \texttt{A}, b \mapsto \texttt{B} \ | \ (a \lessdot b) \in Eq \ \text{and a is an isolated type variable}}
        }}$
\end{enumerate}

Problem: solved form definition is incorrect for generic Unify
TODO!
%There can be a constraint X = Vector<B>, Y = Vector<C>, and C <. B
%The TV's in constraints like a <. b are not isolated.
%They are only in a =. b constraints with other TV's that do not show up in a =. b constraints

%After Step 5 there are no:
%a .= T, a <. b constraints
%if there is a constraint a <. b or a =. b then a and b will be generic variables
%TODO: Hier kann man isolated type variables vlt umformulieren:
%  - Es gibt weder für a noch b einen konkreten Typen der eingesetzt wird
%  - noch erben sie von einem konkreten Typen, sondern nur anderen TVs

\begin{figure}
\begin{center}
    \leavevmode
    \fbox{
    \begin{tabular}[t]{ll}
      (adapt)
      & $
      \begin{array}[c]{ll}
      \begin{array}[c]{l}
         Eq \cup \, \set{\exptype{D}{\ol{A}} \lessdot
          \exptype{C}{\ol{B}}} \\ 
        \hline
        \vspace*{-0.4cm}\\
        Eq \cup \set{\exptype{C}{[ \ol{A} / \ol{X} ]\ol{Y}}
        \doteq \exptype{C}{\ol{B}}}
      %Eq \cup \set{\theta_1 \doteq \lambda'_1 \ldo \theta_n \doteq \lambda'_n}
      \end{array}
      & (\exptype{D}{\ol{X}} \olsub \exptype{C}{\ol{Y}}) \in S_\leq 
      \end{array}
      $
    \\\\
(reduce1) & $
\begin{array}[c]{l}
  Eq \cup \set{\exptype{D}{\ol{A}} \lessdot
    \exptype{D}{\ol{B}}}\\
  \hline
  Eq \cup \set{\ol{A} \doteq \ol{B}}
\end{array}
      $ \\\\
(reduce2) & $
\begin{array}[c]{l}
  Eq \cup \set{\exptype{D}{\ol{A}} \doteq
    \exptype{D}{\ol{B}}}\\
  \hline
  Eq \cup \set{\ol{A} \doteq \ol{B}}
\end{array}
      $ \\\\
    \end{tabular}}
  \end{center}
\caption{Reduce and adapt rules}\label{fig:fgjreduce-rules}
\end{figure}

\begin{figure}
\begin{align*}
&\begin{tabular}[t]{ll}
      (erase1)  & $ 
      \begin{array}[c]{ll}
        \begin{array}[c]{l}
          Eq \cup \set{C \lessdot D}\\
          \hline
          Eq
        \end{array}
        & C \leq^* D \in S_\leq
      \end{array}$\\
          \end{tabular}\\
&\begin{tabular}[t]{ll}
      (erase2)  & $ 
      \begin{array}[c]{ll}
        \begin{array}[c]{l}
          Eq \cup \set{C \doteq C}\\
          \hline
          Eq
        \end{array}
      \end{array}$\\
          \end{tabular}\\
    &      \begin{tabular}[t]{ll}
       (swap) & $
            \begin{array}[c]{ll}
              \begin{array}[c]{l}
                Eq \cup \set{C \doteq a}\\
                \hline
                Eq \cup \set{a \doteq C}
              \end{array}
            \end{array}$
          \end{tabular}
\end{align*}
\caption{Erase and swap rules}\label{fig:fgjerase-rules}
\end{figure}

\subsubsection{Using remaining type variables as generics (the java-tx way)}
At first we have to assign each type variable in the isolated type variables set an unifier.

\begin{align*}
\ddfrac{(\ol{a} \lessdot \ol{b}) \in Eq_{isolated}
}{
  \sigma = \set{ \ol{a} \mapsto \ol{A} } \cup \set{ \ol{b} \mapsto \ol{B}}
}
\end{align*}

We assign all of the type variables in the isolated type variables set to every method
as generic type variables.
Afterwards we set in the correct types for each method call.
This can generate unnecessary generic variables, but the result is still a correct GFJ program.

\begin{align*}
\ddfrac{T\ m(\overline{T}\ \overline{x})\{return\ e;\}
\quad \quad (\ol{a} \lessdot \ol{b}) \in Eq_{isolated}
}{
  \exptype{}{\ol{A} \triangleleft \ol{B},\ \ol{B} \triangleleft \texttt{Object}}\ T[a \to Y]\ m(\overline{T}[a \to Y]\ \overline{x})\{return\ e;\}
}
\end{align*}

%
%%
%%%
%%%%
%%%%%
%%% OLD DRAFT: start
\begin{theoremAndi}\label{theo:isolatedtypevariables-one-method}
\textbf{Isolated type variables belong to one method only:} There will never be an isolated type variable which is used by two methods at once.
It is not possible for two isolated type variables appearing in one constraint $(a \lessdot b)$,
where $a$ and $b$ appear in the type of two different functions or where one 
type variable appears in two or more methods at once.
\end{theoremAndi}
\textit{Proof:}
The field types are not inferred. If a field type contains a generic variable it was already declared in the input TFGJ program.
A field type will never contain a type variable,
therefore we only have to look into method types.

Each method's return and parameter types get assigned distinct type variables at the start of \textbf{GFJType}.

During the \textbf{FJTYPE} algorithm two of those never appear in the same constraint.
(Trivial to show)
There is no transitive chain between two type variables during constraint generation.
Proof:
(Trivial, looking at all \textbf{TYPEExpr} rules)
We only have to look at $\lessdot$-constraints.
A $\doteq$ constraint will never change into a $\lessdot$ constraint and therefore never show up in the isolated type variables set.
So we will have a look at the only part where a $(a \lessdot b)$ with $a$ and $b$ containing type variables can be generated.
This is for the method call case $\textbf{TYPEExpr}(Ass, e_r.\texttt{m}(\ol{e})$.
Here two type variables from different methods get into one constraint.
The method which gets called either has no generic type variables or the same one as the caller method.

The \textbf{Unify} algorithm will never put two of those in a transitive chain inside the isolated type variables set.

Is this correct? Maybe remove this block (TODO)
%%% OLD DRAFT: end
%%%%%
%%%%
%%%
%%
%

\subsubsection{Using remaining type variables as generics(the FJ way)}
All types for fields are already given.
But we want methods to be generic when possible.
Remaining type variables can be used as generic type parameters for methods.

It is not possible for two methods to have a constraint $(a \lessdot b)$,
where $a$ is used in the first and $b$ is used in the other method or where one 
type variable is used in both methods.
%REASON:
% - no TPHs for fields, only for parameters -> only used in one method
% - if one method calls another method, this method will not be generic or get the same generic parameter

% id1(x) {return id2(x);} -> *TypeInference* -> <A> A id1(A x){ return id2<A>(x);}

% Twice example proofs that we need <A extends B> generics for methods
%twice(x,f) = f(f(x)) 
% <A extends B> B twice(A x, Fun1<B,A> f)

First we apply following rules to all constraint sets $Eq$ in solved form:
\begin{align*}
\ddfrac{
  Eq \cup a \lessdot b
}{
  Eq[b \to a] \cup a \lessdot \texttt{Object}
}
\end{align*}
\begin{align*}
\ddfrac{
  Eq \cup a \doteq b
}{
  Eq[b \to a] \cup a \lessdot \texttt{Object}
}
\end{align*}

After this step there are only constraints of the form $(a \doteq \theta)$ and $b \lessdot \texttt{Object})$ left.

We generate the set of unifiers as follows:
\begin{align*}
\emph{Uni} =& \set{a \mapsto \theta \ | \ (a \doteq \theta) \in Eq''}
        \\  \cup & \ \set{b \mapsto G \ | \ (b \lessdot \texttt{Object}) \in Eq'' ,\ G\ \text{is a fresh generic variable name}}
\end{align*}

Apply solution:
At first we substitute every empty type in the input program:

$\mathtt{\ddfrac{T\ m(\overline{T}\ \overline{x})\{return\ e;\}
}{
  \sigma(\ol{T})\ m(\sigma(\ol{T})\ \overline{x})\{return\ e;\}
}}$

Afterwards we have to add generics to the method declarations:

$\mathtt{\ddfrac{\exptype{}{\ol{X} \triangleleft N}\ T\ m(\overline{T}\ \overline{x})\{return\ e;\}
\quad \quad a \in (T \cup \overline{T}) \quad \quad \sigma(a)\ \text{is a generic type variable}
}{
  \exptype{}{\ol{X} \triangleleft N,\ \sigma(a) \triangleleft \texttt{Object}}\ T[a \to Y]\ m(\overline{T}[a \to Y]\ \overline{x})\{return\ e;\}
}}$


\end{document}
\endinput
%%
%% End of file `TIforGFJ.tex'.
