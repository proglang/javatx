
\documentclass[runningheads]{llncs}

\usepackage{todonotes} % [disable]
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{prolog}

\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Type Inference for Featherweight Generic Java}


\author{Andreas Stadelmeier \and
Martin Pl端micke\and
Peter Thiemann}
%
\authorrunning{F. Author et al.}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{DHBW Stuttgart, Campus Horb
\email{a.stadelmeier@hb.dhbw-stuttgart.de}}
\authorrunning{Stadelmeier, Pl端micke, Thiemann}


%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
  Type Inference for Featherweight Generic Java
  \keywords{type inference, Java, compiler}
\end{abstract}



\input{introduction}

\input{motivation}

\section{Preliminaries}
\label{sec:preliminaries}

\subsection{Featherweight Java Typing Rules}
\input{fjtyperules}

\subsection{Input assumptions}
% No overloaded methods
% No Or-Constraints
The input is a GFJ program lacking the type assignments for method parameters and method return types.


The Typeless Generic Featherweight Java (TGFJ) syntax is different in that from normal Generic Featherweight Java (GFJ) that it is possible
to omit the type annotations for methods.%, except the ones for casts and \texttt{new} calls.
We declare the syntax for TGFJ as follows:

\begin{align*}
  T ::=& X \, | \, N \\
  N ::=& \exptype{C}{\ol{T}}\\
  L ::=& \mathtt{class } \ \exptype{C}{\ol{X} \triangleleft \ol{N}} \ \triangleleft \ N \{ \overline{T} \ \overline{f}; \, K \, \overline{M} \} \\
  K ::=& C(\overline{T} \ \overline{f})\{\mathtt{super}(\overline{f}); \ \mathtt{this}.\overline{f}=\overline{f};\} \\
  %M ::=& \exptype{}{\ol{X} \triangleleft \ol{X}}\ T \ \mathtt{m}(\overline{T} \, \overline{x})\{ \mathtt{ return }\ e; \} \\
  M ::=& \mathtt{m}(\overline{x})\{ \mathtt{ return }\ e; \} \\
  e ::=& \mathtt{this} \, | \, x \, | \, e.f \, | \, e.\mathtt{m}(\overline{e}) \, | \, \mathtt{new }\ N(\overline{e})
  %M ::=& T \ \mathtt{m}(\overline{T} \, \overline{x})\{ \mathtt{ return }\ e; \} \\
  %e ::=& \mathtt{this} \, | \, x \, | \, e.f \, | \, e.\exptype{\mathtt{m}}{\ol{T}}(\overline{e}) \, | \, \mathtt{new }\ C(\overline{e}) \, | \, (C) e \\
\end{align*}

All type annotations in our TGFJ language can be omitted ($T = \epsilon$).
The only exception are fields which must be given a concrete type.

Another difference to the syntax of GFJ is that we added the special variable \texttt{this} to the syntax.
FJ treats \texttt{this} as a normal variable
but our algorithm treats it as a special variable which always has a predetermined type;
the type of the class it is used in.

Type inference for polymorphic recursion is undecidable.
Therefore we have to alter the GFJ typing rules to exclude polymorphic recursion in method calls:
\begin{enumerate}
    \item The \texttt{MT-CLASS} rule is removed.
    \item We change the \texttt{GT-METHOD} rule:
GT-METHOD:
\begin{align*}
\ddfrac{\begin{array}{c}
\triangle \vdash \ol{X} <: \ol{N}, \ol{Y} <: \ol{P}  \quad \quad 
\triangle \vdash \ol{T}, T \ \texttt{ok} \\
\triangle ; \ol{x}:\ol{T}, this : \exptype{C}{\ol{X}} \vdash e_0 : S \quad \quad
\triangle \vdash S <: T \\
\texttt{class}\ \exptype{C}{\ol{X} \triangleleft \ol{N}} \triangleleft N \{ \ldots \} \quad \quad
%\textit{override}(m, N, \exptype{}{\ol{Y} \triangleleft \ol{P}} \ol{T} \to T)
\ol{T} \to T  \in \textit{mtype}(m, \exptype{C}{\ol{X}}) \\
%\textit{override}(m, N,)
\end{array}}{
%{\exptype{}{\ol{Y} \triangleleft \ol{P}}\ T \ m(\ol{T}\ \ol{x}) \{ \texttt{return} \ e_0; \} \ \texttt{OK IN}\ \exptype{C}{\ol{X} \triangleleft \ol{N}}}
\textit{mtype}(m, \exptype{C}{\ol{Z}}) = [\ol{Z} / \ol{X}](\exptype{}{\ol{Y}} \ol{T} \to T)
}
\end{align*}
\end{enumerate}

\subsection{Principal Type and Intersection Types}
Generic Featherweight Java has no principal typing.
We can show this easily with an example.
We try to find the principal type for the method \texttt{method1}.
\begin{lstlisting}
class Global{
  method1(a){
    a.add(this);
    return a.get();
  }
}
class List<A> {
  add(A item){...}
  A get() ...
}
\end{lstlisting}
In \texttt{method1} neither the return type nor the type for the parameter \texttt{a} are specified.
The return type of the method depends on the type of \texttt{a}.
If we set in the type \texttt{List<Object>} here, then \texttt{method1} would return \texttt{Object}.
The type \texttt{List<Global>} would also be correct.
Then the return type of the method can also be the type \texttt{Global}.

The principal type would either be an intersection type or the method \texttt{method1} has to be overloaded.
GFJ neither supports intersection types nor overloading.
Therefore we cannot set in the principal type and have to stick with one of the possible solutions,
for example\\
\texttt{List<Global> method1(List<Global> a)}.

We therefore infer intersection types for methods.
The same method body can now have multiple return and parameter type combinations.

\begin{align*}
\textit{mtype}(\texttt{method}, \exptype{C}{\ol{X}}) = \set{ \exptype{List}{Object} \to \texttt{Object}
\ || \ \exptype{List}{String} \to \texttt{String}} 
\end{align*}


\section{Type inference algorithm}
In this chapter we present our type inference algorithm.
The algorithm is split into following parts:

\begin{enumerate}
\item Create assumptions and subtype relation
\item Constraint generation with \textbf{FJTYPE}
\item Unification of those constraints
\item Set in principal type solution
\end{enumerate}

The Unify algorithm returns a set of possible type solutions.
This means that there are possibly multiple type solutions for each method.
The last step has to choose the principal type out of those possibilities.

\subsection{Process multiple classes}
The algorithm processes only one class at a time.
Only the first step creating the type assumptions is able to consider other classes as well.

Nevertheless we allow the input to consist out of multiple classes.
But in that case there are some additional requirements for the input.
%TODO: these requirements can also be in "Preliminaries"

We assume that the algorithm are given the input classes in the correct order $C_1, \ldots C_2$.
Hereby there must exist a correct typisation for the class $C_1$ when existing on its own.
When there are two classes which depend on one another this would be invalid input for our algorithm.
\begin{lstlisting}
class C1 extends Object {
  C1(){ super(); }
  m1(){ return new C2(); }
}
class C2 extends C1{
  C2(){ super(); }
}
\end{lstlisting}
Here the class \texttt{C2} extends \texttt{C1}, but the class \texttt{C1} cannot be processed first because it already uses \texttt{C2}.
Without the method \texttt{m1} the class \texttt{C1} would not reference any other class and stand on its own.
\begin{lstlisting}
  class C1 extends Object {
    C1(){ super(); }
  }
  class C2 extends C1{
    C2(){ super(); }
    m1(){ return new C2(); }
  }
  \end{lstlisting}
By moving \texttt{m1} to class \texttt{C2} we create a valid input for our algorithm.

When processing the second class the first step of the algorithm (create assumptions) also considers the first and already compiled class.
A class $C_n$ therefore can use and reference all the classes before it ($C_1, \ldots, C_{n-1}$).

\subsection{Generate Assumptions}
% Every empty Type T in the input is assigned a type variable.
% Assumptions saves every field, method and the class subtype relation

%Generate subtype relationships:

Generating assumptions consists of two parts.
At first we add type variables to the untyped class.
The second part generates the assumption set.
This is the same algorithm for the already typed classes as for the 
new untyped class, which is now equipped with type variables.

\begin{enumerate}
\item Every missing type in the input class gets assigned a fresh type variable.
For methods:
\begin{align*}
  \ddfrac{
  m(\ol{x}) \{ \ldots \} \quad \quad A \cup \ol{A} \ \text{are fresh type variables}
  }{
  A m(\ol{A}\ \ol{x}) \{ \ldots \}
  }
  \end{align*}
  For fields:
\begin{align*}
  \ddfrac{
  \texttt{class}\ \exptype{C}{\ol{X}} \{ \ol{f}; \quad \ldots \} \quad \quad \ol{F} \ \text{are fresh type variables}
  }{
    \texttt{class}\ \exptype{C}{\ol{X}} \{ \ol{F} \ \ol{f}; \quad \ldots \}
  }
\end{align*}
\item We define the two functions $\textit{ftype}_\textit{Ass}$ and $\textit{mtype}_\textit{Ass}$.
Both functions return a set of all types for a method \texttt{m} or a field \texttt{f}.
This is due to the fact that there can be multiple methods and fields with the same name.
\begin{align*}
  %TODO: fresh type variables for generic variables:
  \ddfrac{
    class\ \exptype{C}{\ol{X} \triangleleft \ol{N}}\ \{\ \ol{N}\ \ol{f};\ K\ \ol{M}\ \} \quad \quad
    \exptype{}{\ol{Y}}\ U\ \texttt{m}(\ol{U}\ \ol{x}) \{ \ldots \} \in \ol{M}
  }{
    \textit{mtype}_\textit{Ass}(\texttt{m}, \exptype{C}{\ol{X} \triangleleft \ol{N}}) =  \set{\exptype{}{\ol{Y}} (\ol{U} \to U )}
  }
\end{align*}
\begin{align*}
  \ddfrac{
    class\ \exptype{C}{\ol{X} \triangleleft \ol{N}}\ \{\ \ol{T}\ \ol{f};\ K\ \ol{M}\ \} \quad \quad
    T\ \texttt{f} \in \ol{f}
  }{
    \textit{ftype}_\textit{Ass}(\texttt{f}) = \exptype{C}{\ol{X} \triangleleft \ol{N}} \to T
  }
\end{align*}
\item If the input for the type inference algorithm consists out of multiple classes we compile them one by one.
Additionally we add the types of the already compiled classes to the assumption set.
Therefore it is possible to have intersection types already in the assumptions.
\end{enumerate}


\subsection{FJTYPE}
The \textbf{FJTYPE} algorithm produces two kinds of constraints.
\begin{description}
\item[Constraint] A constraint consists of two types or type variables and an operator.
The operator can either be a $\doteq$ (same type) or $\lessdot$ (subtype).
Example: $(a \lessdot \mathtt{Object})$, means that the type variable $a$ should be a subtype of \texttt{Object}.
\item[OrConstraint] An OrConstraint consists out of multiple constraint sets.
For example $\textbf{OrConstraint}(\{ \ \{ (a \lessdot b), (a \leq \mathtt{Object}) \} \ , \ \{ (a \lessdot b)\} \ \})$
is an Or-Constraint consisting of two constraint sets.
\end{description}

The algorithm \textbf{FJTYPE} is given as follows:

\textbf{FJTYPE}:
$\texttt{TypeAssumptions} \times
\texttt{Class} \rightarrow \texttt{Constraints}\\
 \begin{array}{@{}l@{}l@{}l}
 \textbf{FJT}&\textbf{Y} & \textbf{PE}(Ass, \mathtt{class } \ C \ \mathtt{ extends } \ D \{ \overline{T} \ \overline{f}; \, K \, \overline{M} \}) =\\
& \multicolumn{2}{@{}l@{}}{ \{ \ \textbf{TYPEMethod}(\textit{Ass} \cup \{ \mathtt{this} : C \}, m_i) \quad | \quad m_i \in \overline{M} \ \} }\\ 
\end{array}$

The \textbf{FJTYPE} function gets called for every class in the input.
This function accumulates all the constraints generated from calling the
\textbf{TYPEMethod} function for each method declared in the given class.

$\textbf{TYPEMethod}:\texttt{TypeAssumptions} \times
\texttt{Method} \rightarrow \texttt{Constraints}\\
\begin{array}{@{}l@{}l@{}l}
\textbf{TY}& \textbf{PE} & \textbf{Method} (Ass, T_r \ \mathtt{m}(\overline{T} \, \overline{x})\{ \mathtt{ return }\ e; \}) =\\
& \textbf{let}
& Ass_m = Ass \cup \{ \overline{T} : \overline{x} \}\\
& & \ul{(e:rty, ConS)} = \textbf{TYPEExpr}(Ass_m, e)\\
& \mathbf{in}
& (ConS \cup (rty \lessdot T_r))\\
\end{array}
$

The \textbf{TYPEMethod} function for methods just calls the \textbf{TYPEExpr} function with the
return expression. It is significant to note that it adds the assumptions for the method parameters to the global assumptions before passing them to \textbf{TYPEExpr}.
%and the global assumptions plus the assumptions for the method parameters.

\smallskip

In the following we define the \textbf{TYPEExpr} function for every possible expression:

\smallskip

$\textbf{TYPEExpr}:\texttt{TypeAssumptions} \times
\texttt{Expression} \rightarrow \texttt{Type} \times \texttt{Constraints}\\
\begin{array}{@{}l@{}l}
\textbf{TY} \textbf{PE} & \textbf{Expr} (Ass, \mathtt{this}) = (t , \{\})\\
& \textbf{with } (\mathtt{this} : t) \in Ass 
\end{array}
$
\smallskip
$\begin{array}{@{}l@{}l}
\textbf{TY} \textbf{PE} & \textbf{Expr} (Ass,x) = (t , \{\})\\
& \textbf{with } (x : t) \in Ass 
\end{array}
$

\smallskip

$\begin{array}{@{}l@{}l@{}l}
\textbf{TY}& \textbf{PE} & \textbf{Expr} (Ass, e.f ) = \\
& \textbf{let} % \\
% &
& (rty, ConS) = \textbf{TYPEExpr}(Ass, e),\\
& & \textbf{fresh} = \text{a mapping from each variable in}\ \ol{X} \ \text{to a fresh type variable},\\
& & Ass_{f} = \textit{ftype}_{Ass}(f) = \exptype{C}{\ol{X} \triangleleft \ol{N}} \to T \\
& & Cons_{f} = \{\ rty \doteq \exptype{C}{\textbf{fresh}(\ol{X})}, a \doteq \textbf{fresh}(T)\},\\
%& & OrCons = \{ \{ rty \doteq cl, a \doteq t_f \} \ | \ cl.f : t_f \in Ass \},\\
& \mathbf{in}% \\
% &
& (a, ConS \cup Cons_{f})\\
& & \mathit{where\ } a \mathit{\ is\ a\ fresh\
  type\ variable}\\ 
\end{array}
$

\smallskip

$\begin{array}{@{}l@{}l@{}l}
\textbf{TY}& \textbf{PE} & \textbf{Expr} (Ass, e_r.\mathtt{m}(\overline{e}) ) = \\
& \textbf{let} % \\
% &
& (rty, ConS) = \textbf{TYPEExpr}(Ass, e_r),\\
& & \forall e_i \in \overline{e} : (pt_i, ConS_i) = \textbf{TYPEExpr}(Ass, e_i)  ,\\
& & \textbf{fresh} = \text{a mapping from each variable in}\ \ol{X} \ \text{to a fresh type variable},\\
& & Ass_{m} =  \set{\exptype{}{\ol{Y}} (\ol{T} \to T) \,|\, \exptype{}{\ol{Y}} (\ol{T} \to T) \in \textit{mtype}(m, \exptype{C}{\ol{X}})} \\
& & \begin{array}{@{}l@{}l}
        Cons_{m} = \{\ & rty \doteq \exptype{C}{\textbf{fresh}(\ol{X})}, a \doteq \textbf{fresh}(T), \bigcup_{T_i \in \overline{T}} (pt_i \lessdot \textbf{fresh}(T_i))\\
                    & |\, \exptype{}{\ol{Y}} (\ol{T} \to T) \in \textit{mtype}(m, \exptype{C}{\ol{X}}) \} %, \textbf{fresh}(\ol{X}) \lessdot \textbf{fresh}(\ol{N})\},\\
    \end{array}\\
& \mathbf{in}% \\
% &
& (a, ConS \cup \bigcup_i ConS_i \cup \textbf{OrConstraint}(Cons_{m}))\\
& & \text{where\ } a \text{\ is\ a\ fresh\
  type\ variable}\\ 
\end{array}
$

\smallskip

$\begin{array}{@{}l@{}l@{}l}
\textbf{TY}& \textbf{PE} & \textbf{Expr} (Ass, \mathtt{new }\ N(\overline{e}) ) = \\
& \textbf{let} % \\
& \forall e_i \in \overline{e} : (pt_i, ConS_i) = \textbf{TYPEExpr}(Ass, e_i)  ,\\
& & Cons = \{ \bigcup_{T_i \in \overline{T}} (pt_i \lessdot T_i) \ | \ \mathtt{constructor }\ \exptype{C}{\ol{X}}(\overline{T} \overline{x}) \in Ass \},\\
& \mathbf{in}% \\
% &
& (C, ConS \cup \bigcup_i ConS_i)\\
\end{array}
$

\subsubsection{Completeness}
Theorem: The Unify algorithm is complete
Theorem: \textbf{FJTYPE} generates the principal type
Proof: The \textbf{Unify} algorithm is complete, so the principal type is included in the solution set.
We only have to choose the principal type out of those solutions.

All types that are possible under the GFJ typing rules, plus our additional assumptions,
also comply with the generated constraints.

We match every generated constraint with the respective type rule to show completeness of our \textbf{FJTYPE} algorithm.
This shows that none of the generated constraints remove a type which otherwise would be possible under the GFJ typing rules.
The constraints are generated on expression statements.
We now compare the constraints for each expression with the appropriate type rule from GFJ:
\begin{description}
  \item [this]
  has always the type of the surrounding class and generates no constraints.
  \item [Local var]
  No constraints are generated.
  \item[Method invocation]
By direct comparison we show that each of the generated constraints do not apply more restrictions than the \texttt{GT-INVK} rule.
The \texttt{GT-INVK} rule states the condition $\textit{mtype}(m, \textit{bound}_\triangle(T_0)) = \exptype{}{\ol{Y}}\ \ol{U} \to U$.
%In our version of typeless GFJ every method name is unique
%and there is only one class with that particular method.
The constraint $rty \lessdot \exptype{C}{\textbf{fresh}(\ol{X})}$ assures that the type of the expression $e_0$ contains the method \texttt{m}.

\begin{tabular}{l|l}
  \textbf{GFJ Type rule} & \textbf{Constraints} \\
  $\triangle; \Gamma \vdash e_o : T_0$ & $(rty, ConS) = \textbf{TYPEExpr}(Ass, e_r)$\\ 
  $\quad \textit{mtype}(m, \textit{bound}_\triangle(T_0)) = \exptype{}{\ol{Y}}\ \ol{U} \to U$ & $rty \lessdot \exptype{C}{\textbf{fresh}(\ol{X})}$ \\
 %$\textit{mtype}(m, \textit{bound}_\triangle(T_0)) = \ol{U} \to U$ & $rty \doteq cl$\\
 $\triangle; \Gamma \vdash \ol{e} : \ol{S}$ & $\forall e_i \in \overline{e} : (pt_i, ConS_i) = \textbf{TYPEExpr}(Ass, e_i)$\\
 $\triangle \vdash \ol{S} <: \ol{U}$ & $ \bigcup_{T_i \in \overline{T}} (pt_i \lessdot \textbf{fresh}(T_i))$\\
 $\triangle; \Gamma \vdash \mathtt{e_0.m(\overline{e}) : U }$ & $a \doteq \textbf{fresh}(T)$ \\
\end{tabular}

\textit{Note}: The \textbf{TYPEExpr} function only generates constraints which apply to our assumption.
 \item[Field access]
Mostly the same as method invocation.
Fieldnames by default are unique in the GFJ language.

 \begin{tabular}{l|l}
   \textbf{GFJ Type rule} & \textbf{Constraints} \\
   $\Gamma \vdash e_0:T_0$ & $(rty, ConS) = \textbf{TYPEExpr}(Ass, e_r)$\\ 
   $\quad \mathit{fields}(\mathit{bound}_\triangle(T_0)) = \overline{T} \ \overline{f}$ & $rty \doteq \exptype{C}{\textbf{fresh}(\ol{X})}$ \\
  %$\textit{mtype}(m, \textit{bound}_\triangle(T_0)) = \ol{U} \to U$ & $rty \doteq cl$\\
  $\triangle; \Gamma \vdash \ol{e} : \ol{S}$ & $\forall e_i \in \overline{e} : (pt_i, ConS_i) = \textbf{TYPEExpr}(Ass, e_i)$\\
  $\triangle \vdash \ol{S} <: \ol{U}$ & $ \bigcup_{T_i \in \overline{T}} (pt_i \lessdot \textbf{fresh}(T_i))$\\
  $\triangle; \Gamma \vdash \mathtt{e_0.m(\overline{e}) : U }$ & $a \doteq \textbf{fresh}(T)$ \\
 \end{tabular}
 \item[Constructor]

\begin{tabular}{l|l}
  $\triangle; \Gamma \vdash \ol{e} : \ol{S}$ & $\forall e_i \in \overline{e} : (pt_i, ConS_i) = \textbf{TYPEExpr}(Ass, e_i)$\\
  $\triangle \vdash \ol{S} <: \ol{T}$ & $\bigcup_{T_i \in \overline{T}} (pt_i \lessdot T_i)$
\end{tabular}
  
\end{description}

\section{Unify}
\label{sec:unify}
This chapter describes the \textbf{GenericUnify} algorithm
which is used to find type solutions for the constraints generated by \textbf{FGJType}.

\begin{description}
\item[input] A set of type constraints $Cons_{in}$ and a set of subtype relationships $S_\leq$
\item[output] A set of type unifiers $Uni$
or fail $Uni = \emptyset$.
%The unifiers have the form of $Uni = \{ \sigma_1, \ldots , \sigma_n \}$.
\end{description}

The unify algorithm first has to build the cartesian product of all the \textbf{OrConstraint}s and the remaining normal constraints:
\begin{align*}
\Omega &= \text{All }\mathbf{OrConstraints} \text{ in } {Cons}_{in}\\
C &= {Cons}_{in} \setminus \Omega \\
Eq_{set} &= \Omega_1 \times \ldots \times \Omega_n \times C \quad \text{for all }\Omega_i \in \Omega
\end{align*}

%The algorithm starts by setting $Eq_{set} = \set{ Cons_{in} }$.
Afterwards the following steps are repeatedly executed on $Eq_{set}$ until the algorithm termiates:
%For every $Eq \in Eq_{set}$ the following steps are applied.
%The resulting unifiers $\sigma$ from each $Eq$ merged together form the result of the \textbf{Unify} algorithm.

%$\textbf{SubUnify} :: [Constraint] \to [Unifier]$
\begin{enumerate}
\item Repeated application of the rules depicted in figure \ref{fig:fgjreduce-rules} and \ref{fig:fgjerase-rules}.
The end configuration of $Eq$ is reached if for each element
no rule is applicable.

\item
(The function $\textbf{fresh}(i)$ returns an array of $i$ fresh type variables.)

\begin{align*}
Eq_1 =& \text{Subset of pairs where both type terms are type variables}\\
Eq_2 =& Eq / Eq_1 \\
Eq_{set}\\ 
    = 
     & \begin{array}[t]{l@{\,}ll}
      \times \, (\displaystyle{\bigotimes_{(a \lessdot \exptype{C}{\ol{X}}) \in Eq'_2}}
      \{\,(a \doteq \exptype{D}{\ol{A}}) \, \cup \, (\ol{X} \doteq \ol{Y'}) \ | \ \sarray{@{}l}{
        (\exptype{D}{\ol{Z}} \olsub \exptype{C}{\ol{Y}}) \in S_\leq, \\
        \ol{A} = \textbf{fresh}(\#(\ol{Z})), \\
        \ol{Y'} = [\ol{A}/\ol{Z}]\ol{Y}
        \,\})}\\ 
      \end{array}\\
   %& \times\, 
   %   (\displaystyle{\bigotimes_{(\exptype{C}{\overline{T}} \lessdot a) \in Eq'_2}}\!\!
   %   \set{(a \doteq [\ol{T}/\ol{X}]N ) \ | \ (\exptype{C}{\overline{X}} \leq N) \in
   %     S_\leq})\\
    & \times\, 
      (\displaystyle{\bigotimes_{(\exptype{C}{\overline{T}} \lessdot a) \in Eq'_2}}\!\!
      \set{(a \doteq [\ol{T}/\ol{X}]N ) \ | \ (\exptype{C}{\overline{X} \triangleleft \ol{N}} \leq N) \in
        S_\leq})\\
    & \times\, \set{[a \doteq \theta \ | \  (a \doteq \theta) \in Eq'_2]} \times Eq_1 \\
\end{align*}

\item \label{subst-step}  Application of the following \emph{subst} rule
    %\begin{enumerate}
    %\item Apply the following subst\_eq rule
    
      $$\begin{array}[c]{lll}
        (\mathrm{subst}) &
        \begin{array}[c]{l}
          Eq'' \cup \set{a \doteq \theta}\\
          \hline
          Eq''[a \mapsto \theta] \cup \set{a \doteq \theta}
        \end{array}
        & a \textrm{ occurs in } Eq'' \textrm{ but not in } \theta 
      \end{array}$$
      
      for each $a \doteq \theta$ in each element of $Eq' \in Eq'_{set}$.

\item 
    \begin{enumerate}
    \item Foreach $Eq \in Eq_{set}$ which has changed in the last step
      start again with the first step.
    \item Build the union $Eq_{set}$ of all results of (a) and all $Eq' \in
      Eq'_{set}$ which has not changed in the last step.
    \end{enumerate}
\item
\begin{enumerate}
\item Filter all constraint sets which are in solved form:\\
$Eq_{solved} = \set{ Eq \ | \ Eq \in Eq_{set}, Eq \ \text{is in solved form}}$
\item We apply the following rule to every constraint set in $Eq_{solved}$:
\begin{align*}
\ddfrac{
  Eq \cup \set{ a \lessdot b } %There are only Type variables left at this point
}{
  Eq \cup \set{ a \doteq b }
}
\end{align*}
\item $\emph{Uni} = \set{\sigma \ | \ Eq \in Eq_{solved},\ \sigma = \set{a \mapsto \theta \ | \ (a \doteq \texttt{T}) \in Eq} }$
%\item $\emph{Uni} = \sarray{l@{\ }l}{\set{\sigma \ | & Eq'' \in Eq''_{set},
%        Eq'' \textrm{ is in solved form,}\\ 
%        & \sigma = \set{a \mapsto \theta \ | \ (a \doteq \theta) \in Eq''}
%        \\ & \quad \cup \ \set{a \mapsto \texttt{A}, b \mapsto \texttt{B} \ | \ (a \lessdot b) \in Eq \ \text{and a is an isolated type variable}}
%        }}$
\end{enumerate}
\end{enumerate}

\begin{figure}
\begin{center}
    \leavevmode
    \fbox{
    \begin{tabular}[t]{ll}
      (adapt)
      & $
      \begin{array}[c]{ll}
      \begin{array}[c]{l}
         Eq \cup \, \set{\exptype{D}{\ol{A}} \lessdot
          \exptype{C}{\ol{B}}} \\ 
        \hline
        \vspace*{-0.4cm}\\
        Eq \cup \set{\exptype{C}{[ \ol{A} / \ol{X} ]\ol{Y}}
        \doteq \exptype{C}{\ol{B}}}
      %Eq \cup \set{\theta_1 \doteq \lambda'_1 \ldo \theta_n \doteq \lambda'_n}
      \end{array}
      & (\exptype{D}{\ol{X}} \olsub \exptype{C}{\ol{Y}}) \in S_\leq 
      \end{array}
      $
    \\\\
(reduce1) & $
\begin{array}[c]{l}
  Eq \cup \set{\exptype{D}{\ol{A}} \lessdot
    \exptype{D}{\ol{B}}}\\
  \hline
  Eq \cup \set{\ol{A} \doteq \ol{B}}
\end{array}
      $ \\\\
(reduce2) & $
\begin{array}[c]{l}
  Eq \cup \set{\exptype{D}{\ol{A}} \doteq
    \exptype{D}{\ol{B}}}\\
  \hline
  Eq \cup \set{\ol{A} \doteq \ol{B}}
\end{array}
      $ \\\\
    \end{tabular}}
  \end{center}
\caption{Reduce and adapt rules}\label{fig:fgjreduce-rules}
\end{figure}

\begin{figure}
\begin{align*}
&\begin{tabular}[t]{ll}
      (erase1)  & $ 
      \begin{array}[c]{ll}
        \begin{array}[c]{l}
          Eq \cup \set{C \lessdot D}\\
          \hline
          Eq
        \end{array}
        & C \leq^* D \in S_\leq
      \end{array}$\\
          \end{tabular}\\
&\begin{tabular}[t]{ll}
      (erase2)  & $ 
      \begin{array}[c]{ll}
        \begin{array}[c]{l}
          Eq \cup \set{C \doteq C}\\
          \hline
          Eq
        \end{array}
      \end{array}$\\
          \end{tabular}\\
    &      \begin{tabular}[t]{ll}
       (swap) & $
            \begin{array}[c]{ll}
              \begin{array}[c]{l}
                Eq \cup \set{C \doteq a}\\
                \hline
                Eq \cup \set{a \doteq C}
              \end{array}
            \end{array}$
          \end{tabular}
\end{align*}
\caption{Erase and swap rules}\label{fig:fgjerase-rules}
\end{figure}

\subsection{Unify proof}

%Soundness: We have to prove that each calculated result of the algorithm is a general unifier of the corresponding input
\begin{theoremAndi}
  \label{theo:unifySoundness}
  \textbf{(Soundness):}
  If the \textbf{Unify} algorithm finds a solution it does not contradict any of the input constraints:
  $\nexists (a \lessdot b) \in {Cons}_{in}$ where $\sigma(a) \nleq \sigma(b)$  
\end{theoremAndi}
%We show this by induction.
%No step alters the constraint set in a way that would make a wrong solution possible.
\textit{Proof:}
We show theorem \ref{theo:unifySoundness} by going backwards over every step of the algorithm.
We assume there exists a unifier $\sigma = \set {a_1 \mapsto \theta_1, \ldots , a_n \mapsto \theta_n}$ for the input constraints,
which is the result of the \textbf{Unify} algorithm.
This means for every constraint in the input set $(a \lessdot b) \in {Cons}_{in}$ and $(c \doteq d) \in {Cons}_{in}$
this unifier will substitute all variables in a way that all constraints are satisfied:
$\sigma(a) \leq \sigma(b)$, $\sigma(c) = \sigma(d)$\\

We now look at each step of the \textbf{Unify} algorithm
which transforms the input set of constraints $Eq$ to a set $Eq'$.
If we assume the unifier $\sigma$ is correct for the set $Eq'$,
then we can show that it will also be correct for the constraints $Eq$. 


%TODO:
%Assume we find a unifier. Then do every step backwards.
%For each step the constraint set before and after the step have the same unifier.
% -> This means no step adds an incorrect unifier / makes a incorrecto unifier possible
%At the end we must end at the correct unifier.

\begin{description}
\item[Step 5 c)]
The last step of the algorithm transforms a set of constraints $Eq$ of the the form

$Eq = \set{a_1 \doteq \theta_1, \ldots , a_n \doteq \theta_n}$

to the unifier $\sigma$.
Trivial.

\item[Step 5 b)]
A unifier which is correct for $a \doteq b$ is also correct for $a \lessdot b$.

\item[Step 5 a)]
Trivial, we do not alter the constraint set which lateron leads to the unifier.

\item[Step 4]
Trivial, the constraint sets are not altered here.

\item[Step 3]
An unifier $\sigma$ that is correct for a constraint set
$Eq[a \to \theta] \cup (a \doteq \theta)$ is also correct for
the set $Eq \cup (a \doteq \theta)$.
From the constraint $(a \doteq \theta)$ it follows that $\sigma(a) = \theta$.
This means that $\sigma(Eq) = \sigma(Eq[a \to \theta])$,
because every occurence of $a$ in $Eq$ will be raplaced by $\theta$ anyways when using the unifier $\sigma$.

\item[Step 2]
This step transforms constraints of the form $(\exptype{C}{\ol{X}} \lessdot a)$ and $(a \lessdot \exptype{C}{\ol{X}})$
into sets of constraints and builds the cartesian product with the remaining constraints.
We can show that if there is a resulting set of constraints which has $\sigma$ as its correct unifier
then $\sigma$ also has to be a correct unifier for the constraints before this transformation.
Proof:
%normal version:
%\begin{description}
%\item[$(a \lessdot C)$] If $\sigma$ is a correct unifier for a set containing $(a \doteq \theta)$
%and $\theta \leq C$, then $\sigma$ is also a correct unifier for the set containing $(a \lessdot C)$.
%\item[$(C \lessdot a)$] Same goes the other way. If $C leq \theta$ and $\sigma$ is correct for $(C \lessdot \theta)$
%then $\sigma$ is also correct for $(a \doteq \theta)$
%\end{description}

\begin{description}
\item[$(a \lessdot \exptype{C}{\ol{X}})$] If $\sigma$ is a correct unifier for a set containing $(a \doteq \exptype{D}{\ol{A}})$
and $(\ol{X} \doteq \ol{Y'})$
, then $\sigma$ is also a correct unifier for the set containing $(a \lessdot \exptype{C}{\ol{X}})$.
The reason is the \texttt{S-CLASS} subtype rule of GFJ. %TODO: Hier etwas ausf端hrlicher?
%TODO:
%\item[$(\exptype{C}{\ol{T}} \lessdot a)$] Same goes the other way. If $\exptype{C}{\ol{X} leq \theta$ and $\sigma$ is correct for $(C \lessdot \theta)$
%then $\sigma$ is also correct for $(a \doteq \theta)$

%If $\sigma$ is a correct unifier for a set \\
%$Eq = Eq' \cup (a \doteq \exptype{D}{\ol{A}}) \, \cup \, (\ol{X} \doteq \ol{Y'})$ \\
%then it is also a correct unifier for a set $Eq = Eq' \cup (a \lessdot \exptype{C}{\ol{X}})$: \\
When substituting $(a \to \exptype{D}{\ol{A}})$ and $(\ol{X} \to \ol{Y'})$
and finally $ (\ol{Y'} \to [\ol{A}/\ol{Z}]\ol{Y})$ in the constraint $(a \lessdot \exptype{C}{\ol{X}})$
we get: $(\exptype{D}{\ol{A}} \lessdot [\ol{A}/\ol{Z}]\exptype{C}{\ol{Y}}$
which is correct under the \texttt{S-CLASS} rule (see figure \ref{fig:gfj-subtyping-rules}).

\item[$(\exptype{C}{\ol{T}} \lessdot a)$] If $\exptype{C}{\ol{X}} leq \theta$ and $\sigma$ is correct for $(a \doteq [\ol{T}/\ol{X}]N)$
then $\sigma$ is also correct for $(\exptype{C}{\ol{T}} \lessdot a))$.
When substitutin $a$ for $[\ol{T}/\ol{X}]N$ we get 
$(\exptype{C}{\ol{T}} \lessdot [\ol{T}/\ol{X}]N)$
, which is correct because $(\exptype{C}{\ol{X}} \leq \exptype{C}{\ol{Y}}$
(see \texttt{S-CLASS} rule).

\begin{figure}
$\ddfrac{
  \texttt{class}\ \exptype{C}{\ol{X} \triangleleft \ol{N}} \triangleleft N \set{ \ldots }
}{
  \triangle \vdash \exptype{C}{\ol{T}} <: [\ol{T}/\ol{X}]N
}$ 
\caption{Generic Featherweight Java subtyping rules}\label{fig:gfj-subtyping-rules}
\end{figure}

\footnote{
Discussion:
Do we need to include the $\triangleleft \ol N$ bounds?
The S-CLASS rule does not mention them.

When ignoring those rules this could lead to an error
class T<X extends List> {
}
class S<X>{}

Constraint: S<String> <. a
Unify: T<String> =. a // ERROR!

This is not a problem because no error is gonna result from this.
TYPEExpr only hast to implement all of the typing rules of FJ
and unify has to solely respect the subtyping rules.

}
\end{description}

\item[Step 1]
\begin{description}
\item[erase-rules] remove correct constraints from the constraint set.
A unifier $\sigma$ that is correct for the constraint set $Eq$
is also correct for $Eq \cup \set{\theta \doteq \theta}$
and $Eq \cup \set{\theta \lessdot \theta'}$, when $\theta \leq \theta'$.
\item[swap-rule] does not change the unifier for the constraint set.
$\doteq$ is a symmetric operator and parameters can be swapped freely.
\item[adapt] If there is a $\sigma$ which is a correct unifier for a set
$Eq \cup \set{ \exptype{C}{[\ol{A}/\ol{X}]\ol{Y}} \doteq \exptype{C}{\ol{B}}}$ then it is also
a correct unifier for the set $Eq \cup \set{ \exptype{D}{\ol{A}} \lessdot \exptype{C}{\ol{B}}}$,
if there is a subtype relation $\exptype{D}{\ol{X}} \leq^* \exptype{C}{\ol{Y}}$.
To make the set $Eq \cup \set{ [\ol{A}/\ol{X}]\exptype{C}{\ol{Y}} \doteq \exptype{C}{\ol{B}}}$ the unifier 
$\sigma$ must satisfy the condition $\sigma([\ol{A}/\ol{X}]\ol{Y}) = \sigma(\ol{B})$.
By substitution we get $Eq \cup \set{ \exptype{D}{\ol{A}} \lessdot \exptype{C}{[\ol{A}/\ol{X}]\ol{Y}}}$
which is correct under the \texttt{S-CLASS} rule.
\item[reduce] The \texttt{reduce1} and \texttt{reduce2} rules are obviously correct under the FJ typing rules.
\end{description}

\item[OrConstraints]
If $\sigma$ is a correct unifier for one of the constraint sets in $Eq_{set}$
then it is also a correct unifier for the input set $Cons_{in}$.
When building the cartesian product of the \textbf{OrConstraints} every possible
combination for $Cons_{in}$ is build.
No constraint is altered, deleted or modified during this step.
\end{description}
\hfill $\square$


%Completeness: If there is a Unifier (a solution), the algorithm will never alter the constraints in a way that this solution is removed
%\begin{theoremAndi}\label{theo:unifyCompleteness}
%  \textbf{(Completeness):} If there is a solution for the input constraints $Cons_{in}$, the \textbf{Unify} algorithm will not fail.
%  A solution is a non-empty set of unifiers $Uni = \set{\sigma_1, \ldots \sigma_n }$,
%  where each unifier is a injective function which maps every type variable in the input constraints $Cons_{in}$ to a
%  type in $S_\leq$.
%  \end{theoremAndi}
\begin{theoremAndi}\label{theo:unifyCompleteness}
  \textbf{(Completeness):} The \textbf{Unify} algorithm calculates the principal type solution for the input set of constraints ($Cons_{in}$).
  A unifier $\sigma$ is a principal type solution for $Cons_{in}$ if it unifies $Cons_{in}$
  and for every other unifier $\omega$ there is a unifier $\lambda$ so that $\omega(x) = \lambda(\sigma(x))$.
\end{theoremAndi}
\textit{Proof:}
%The \textbf{Unify} calculates multiple solutions.

%Our proof goes as follows:
We look at every step of the algorithm, which alters the set of constraints $Eq$,
while assuming that there is at least one possible principal type solution $\sigma$ for the input.
We will show that the principal type is among them by proofing for every step of the algorithm that the principal type is never excluded.

%Assume there is a unifier and the Unify algorithm finds it.
%Then no rule makes this unifier impossible / removes this unifier.

\begin{description}
\item[Step 1:]
The first step applies the three rules from figure \ref{fig:unifyrules}.
\textbf{erase-rules:} The erase2 rule from figure \ref{fig:unifyrules} removes a
$\{\theta \leq \theta\}$ constraint from the constraint set.
The erase1 rule removes a $\{\theta \leq \theta\}$ constraint,
but only if the two types $\theta$ and $\theta'$ satisfy the constraint.
Both rules do not change the set of possible solutions for the given constraint set.

\textbf{swap-rule:} $\doteq$ is a symmetric operator and parameters can be swapped freely.
This operation does not change the meaning of the constraint set.

\textbf{adapt-rule:} Every solution which is correct for the constraints
$Eq \cup \set{ \exptype{C}{[\ol{A}/\ol{X}]\ol{Y}} \doteq \exptype{C}{\ol{B}}}$ is also
a correct solution for the set $Eq \cup \set{ \exptype{D}{\ol{A}} \lessdot \exptype{C}{\ol{B}}}$.
According to the \texttt{S-CLASS} rule there can only be a possible solution for 
$\exptype{C}{[\ol{A}/\ol{X}]\ol{Y}} \doteq \exptype{C}{\ol{B}}$
if $\ol{B} = [\ol{A}/\ol{X}]\ol{Y}$.
Therefore this transformation does not remove any possible solution from the constraint set.

\textbf{reduce-rule:}
%The constraint is not altered
For a constraint $\exptype{D}{\ol{A}} \lessdot \exptype{D}{\ol{A}}$ the FJ subtyping rule \texttt{S-REFL} ($\triangle \vdash T <: T$) is the only one which applies.
According to this rule the transformation to $\ol{A} \doteq \ol{B}$ is correct.
Only $D$ gets removed, which is not a type variable.
Therefore this step does not remove a possible solution.
This applies for both reduce rules \textbf{reduce1} and \textbf{reduce2}.

\item[Step 2:]
%The second step builds multiple constraint sets of all possible type combinations for the $\lessdot$-constraints.
The second step of the algorithm eliminates $\lessdot$-constraints
by replacing them with $\doteq$-constraints.
%The algorithm considers every possible type from $S_\leq$ which does not violate the eliminated $\lessdot$ -constraint itself.
%This step does not remove a solution from the constraint set.
For each $(a \lessdot \exptype{C}{\ol{X}})$ constraint the algorithm builds a set with every
possible subtype of $\exptype{C}{\ol{X}}$ set in for $a$.
So if there is a correct unifier $\sigma$ for the constraints before this conversion there will be at least one set of
constraints for which $\sigma$ is a correct unifier.
%TODO: what does soundness mean. if there is a possible type solution (with types in S) then unify will find it

\item[Step 3:]
In the third step the \textbf{substitution}-rule is applied.
If there is a constraint $a \doteq \theta$ then there is no other way to fulfill the constraint set
than replacing $a$ with $\theta$.
This does not remove a possible solution.

\item[Step 4:]
None of the constraints get modified.

\item[Step 5 a):]
The removed sets do not have a possible unifier, therefore no possible solution is
omitted in this step.

\textbf{Proof}:
In step 5.a all constraint sets that have a unifier are in solved form.
All other possibilities are eliminated in steps 1-4.
There are 8 different variations of constraints:\\
$(a \doteq a), (a \doteq C), (C \doteq a), (C \doteq C), (a \lessdot a), (a \lessdot C), (C \lessdot a), (C \lessdot C)$

After step 1 there are no $(C \doteq C)$, $(C \lessdot C)$ and $(C \doteq a)$ constraints anymore,
as long as the constraint set has a correct unifier.
Because a constraint set that has a correct unifier cannot contain constraints of the form $\theta_1 \doteq \theta_2$ with $\theta_1 \neq \theta_2$ and
$(\theta_1 \lessdot \theta_2)$ with $(\theta_1 \leq \theta_2) \notin S_\leq$.
By removing $(\theta \doteq \theta)$ and $(\theta \lessdot \theta')$ with $(\theta \leq \theta') \notin S_\leq$ constraints
no constraints of the form $(C \doteq C)$ and $(C \lessdot C)$
remain in a constraint set that has a correct unifier after step 1.

After step 2 there are no more $(a \lessdot C)$ constraints.

After step 3 there are no $(a \doteq C)$ anymore.

We only reach step 5 if the constraint set is not changed by the substitution (step 3).

%If at this point a set $Eq_i$ is not in solved form it has no correct unifier.

If the constraint set has a correct unifier only $(a \lessdot a)$, $(a \doteq a)$ and $(a \doteq C)$ constraints are left at this point.
The type variables in the $(a \lessdot a)$ and $(a \doteq a)$ constraints have to be independent type variables.
If a type variable $c$ is inside a $(c \doteq C)$ constraint it is not an independent type variable.
But this variable $c$ cannot be inside a $(a \doteq a)$ or $(a \lessdot a)$ constraint, because otherwise step 3 would have replaced it in there.


\item[Step 5 b):]
If the algorithm advances to this step we further only work on constraint sets in solved form.
This means there are only two kinds of constraints left.
($A \doteq \texttt{Typ}$), ($A \doteq B$) and ($A \lessdot B$) with $A$ and $B$ as type variables.

%We can set all TVs equal, because we allow only same TVs when having circles in a method call.
%This still will lead to the principal type.

The GFJ language does not allow subtype constraints for generic types.
A constraint like $(A \lessdot B)$ in a solution could be inserted as the typing shown in the example below.
But this is not allowed by the syntax of GFJ.
That is why we can treat this constraint as $(A \doteq B)$.

%TODO: This does not alter the outcome because the solution set is not modified anymore. All other TVs alread have a type like A =. Typ

\textit{Example:}
This would be a valid Java program but is not allowed in GFJ:
\begin{lstlisting}
class Example {
  <A extends Object, B extends A> A id(B a){
    return a;
  }
}
\end{lstlisting}

By replacing all ($A \lessdot B$) constraints with ($A \doteq B$) we do not remove a principal type solution.

\item[Step 6:]
In the last step all the constraint sets, which are in solved form, are converted to unifiers.

We see that only a constraint set which has no unifier does not reach solved form.
We showed that in every step of the \textbf{Unify} algorithm we never exclude a possible unifier.
Also we showed that after we reach step 5 only constraint sets with a correct unifier are in solved form.
By removing all constraint sets which are not in solved form the algorithm does not
remove a possible correct unifier.

If we assume that there is a possible principal type solution $\sigma$ for the input set $Cons_{in}$
and the \textbf{Unify} algorithm does not exclude any of the possible unifiers,
then the result \textbf{Unify} contains the principal type solution.
\hfill $\square$
\end{description}

\section{Insert principal type}
After generating all possible unifiers in the \textbf{Unify} we can insert the principal types.

\begin{align*}
\ddfrac{
  A\ \texttt{m}(\ol{A}\ \ol{p}) \{ \ldots \} \in M \quad \quad \texttt{class}\ \exptype{C}{\ol{X}} \{ \ldots\ M,\ \ldots\}
}{
  \textit{mtype}(\texttt{m}, \exptype{C}{\ol{X}}) = \set{\sigma(\ol{A}) \to \sigma(A) \,|\, \sigma \in {Uni}}
}
\end{align*}

The \textbf{Unify} algorithm returns a set of unifiers ${Uni}$.
Each element of that set is a correct solution.
The unifiers $\sigma$ map type placeholders to types.
When generating the intersection types for the methods we have to make sure that the
type placeholders for the return type as well as for the parameter types get replaced by the same unifier $\sigma$.
It can happen that two unifiers $\sigma_1$ and $\sigma_2$ lead to the same method type ($\sigma_1(A) = \sigma_2(A), \sigma_1(\ol A) = \sigma_2(\ol A)$).
The set of all the distinct combinations then builds the intersection type for the method.

\textbf{Example:}
\begin{lstlisting}
class Global{
  method1(a){
    a.add(this);
    return a.get();
  }
}
class List<A> {
  add(A item){...}
  A get() ...
}
\end{lstlisting}

The method \texttt{method1} would get the type $\set{ \exptype{List}{Object} \to \texttt{Object}
\ || \ \exptype{List}{Global} \to \texttt{Global}}$.
If GFJ would support overloaded methods this could be written as:
\begin{lstlisting}
class Global{
  Object method1(List<Object> a){
    a.add(this);
    return a.get();
  }
  String method1(List<Global> a){
    a.add(this);
    return a.get();
  }
}
class List<A> {
  add(A item){...}
  A get() ...
}
\end{lstlisting}

\section{Complexity}
\input{complexity}

\section{Examples}

\textbf{Example 1}\\
The algorithm is able to infer the types of multiple classes under specific circumstances.
The individual classes must be given to him after one another.
This comes with the restriction, that the first class is correct on its own and does not use any other class.
The second class that gets compiled can use the first class and so on.

The following example shows how the algorithm infers and compiles multiple classes iteratively.
The class \texttt{Class1} is infered first.
It has only one method which is the identity function,
to which our algorithm allocates the type $\exptype{}{A}\ A \to A$.
The next class \texttt{Class2} is now able to use this generic method.
The blue colored types are inferred in the next iteration of our algorithm.

\begin{table}
\caption{Two classes as input. \texttt{Class1} is infered first (shown in {\color{red}red})}
\begin{tabular}{cc}
\begin{lstlisting}
class Class1 extends Object {
  Class1() { super(); }
  id(a){
    return a;
  }
}
class Class2 extends Class1 {
  Class2() { 
    super(); 
  }
  example(){
    return new Class1().id(this);
  }
}
\end{lstlisting}
&
\begin{lstlisting}
class Class1 extends Object {
  Class1() { super(); }
  (*@ \textcolor{red}{<A> A} @*) id((*@ \textcolor{red}{A} @*) a){
    return a;
  }
}
class Class2 extends Class1 {
  Class2() { 
    super(); 
  }
  (*@ \textcolor{blue}{Class1}@*) example(){
    return this.(*@\textcolor{blue}{<Class1>}@*)id(this);
  }
}
\end{lstlisting}
\end{tabular}
\end{table}

\textbf{Example 2}\\
When compiling a class like the following
we have to first split this class into two classes.
The \texttt{TwoMethods} class can be first split into the classes \texttt{Class1}
and \texttt{Class2} and after being processed by the type inference algorithm it can be assembled back together again.
This leads to a principal typing.
When using our type inference algorithm on the class \texttt{TwoMethods} alone
it would give the method \texttt{id} the type $\texttt{TwoMethods} \to \texttt{TwoMethods}$,
which is not the desired principal type.
\begin{lstlisting}
class TwoMethods extends Object {
  TwoMethods() { super(); }
  id(a){
    return a;
  }
  example(){
    return this.id(this);
  }
}
\end{lstlisting}

\textbf{Example 3}\\
%TODO: Ein Beispiel f端r die Unify-adapt Regel
GFJ allows subtype relations like the following:
\begin{lstlisting}
class Map<A,B> extends Object {
  Map<A,B>() { super(); }
}
class SpecialMap<A,B,C> extends Map<A,C> {
  SpecialMap<A,B,C>() { super(); }
}
\end{lstlisting}

If for example we have a method \texttt{method} like this:
\begin{lstlisting}
<X> void method(Map<X, String> map){
  ...
}
\end{lstlisting}
and call it:
\begin{lstlisting}
method(new SpecialMap<Object,Integer,String>());
\end{lstlisting}

Then the constraint $\exptype{SpecialMap}{Object,Integer,String} \lessdot \exptype{Map}{X,String}$
is generated by the \textbf{FJTYPE} algorithm.
This constraint will be processed by the \texttt{adapt} rule of the \textbf{Unify} algorithm.
Remember that $(\exptype{SpecialMap}{A,B,C} \olsub \exptype{Map}{A,C}) \in S_\leq$.
\begin{align*}
  Eq& \cup \exptype{SpecialMap}{Object,Integer,String} \lessdot \exptype{Map}{X,String} \\
  \cline{1-2} 
  Eq& \cup \set{\exptype{Map}{[ Object / A ][ Integer / B ][ String / C ](A,C)}
  \doteq \exptype{Map}{X,Integer}} \\
  \cline{1-2} 
  Eq& \cup \set{\exptype{Map}{Object,String}
  \doteq \exptype{C}{X, Integer}}
%Eq \cup \set{\theta_1 \doteq \lambda'_1 \ldo \theta_n \doteq \lambda'_n}
\end{align*}

After the \texttt{adapt} rule got applied we can already see that a correct unificator for this constraint would be
$\sigma(X) = \texttt{Object}$.

\section{Assessment}
\label{sec:assessment}

\begin{itemize}
\item NP-hard \todo[inline]{Show NP-completeness!}
\item cannot infer all possible generic methods
\item features that need to be addressed to make it practical (e.g.,
  what's necessary to move from FGJ to full Java: overloading,
  imperative, )
\end{itemize}

\section{Related Work}
\input{relatedWork}

\section{Conclusions}
\label{sec:conclusions}


\bibliographystyle{splncs04}
\bibliography{peter,martin}

\end{document}
\endinput
%%
%% End of file `TIforGFJ.tex'.
