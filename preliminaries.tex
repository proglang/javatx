\section{Preliminaries}
\label{sec:preliminaries}
\subsection{Syntax}
% \commentarymargin{Input assumptions}
% No overloaded methods
% No Or-Constraints
\begin{figure}[tp]
\begin{align*}
  \mv T &::= \mv X \mid \mv N \\
  \mv N &::= \exptype{C}{\ol{T}}\\
  \mv L &::= \mathtt{class} \ \exptype{C}{\ol{X} \triangleleft \ol{N}} \triangleleft \ \mv N\ \{ \ol{T} \ \ol{f}; \,\mv K \, \ol{M} \} \\
  \mv K &::= \mv C(\ol{f})\ \{\mathtt{super}(\ol{f}); \ \mathtt{this}.\ol{f}=\ol{f};\} \\
  %M &::= \exptype{}{\ol{X} \triangleleft \ol{X}}\ T \ \mathtt{m}(\overline{T} \, \overline{x})\{ \mathtt{ return }\ e; \} \\
  \mv M &::= \mathtt{m}(\ol{x})\ \{ \mathtt{ return}\ \mv e; \} \\
  \mv e &::= \mv x \mid \mv e.\mv f \mid
             \mv e.\mathtt{m}(\ol{e}) \mid \mathtt{new}\ \mathtt{C}(\ol{e})
             \mid (\mv N)\ \mv e
  %M ::=& T \ \mathtt{m}(\overline{T} \, \overline{x})\{ \mathtt{ return }\ e; \} \\
  %e ::=& \mathtt{this} \, | \, x \, | \, e.f \, | \, e.\exptype{\mathtt{m}}{\ol{T}}(\overline{e}) \, | \, \mathtt{new }\ C(\overline{e}) \, | \, (C) e \\
\end{align*}
  \caption{Syntax of \TFGJ}
  \label{fig:syntax-tfgj}
\end{figure}
The input of our global type inference algorithm is a modified version
of the language Featherweight Generic Java
(FGJ)~\cite{DBLP:journals/toplas/IgarashiPW01}, which we call \TFGJ
(with Global Type Inference).
Its syntax is shown in Figure~\ref{fig:syntax-tfgj}.
Compared to FGJ,
type annotations for method parameters and method return types are omitted.
Object creation via \texttt{new} as well as method calls come do not
require instantiation of their generic parameters.
We keep the class constraints ${\ol{X} \triangleleft \ol{N}}$ as well as the types
for fields $\ol{T} \ \ol{f}$ as we consider them as part of the
specification of a class.

% \textbf{Prechecks:}
We make the following assumptions for the input program:
\begin{itemize}
\item All types $\mv N$ and $\mv T$ are well formed according to the
  rules of FGJ, which carry over to \TFGJ (see Fig.~\ref{fig:well-formedness-and-subtyping}).
  % This can be checked easily, because no types annotations are omitted in the class header.
  % The generic variables of each class as well as their bounds are given in the input.
  % We assume that the each written type in the input in bounds of
  % classes, super class types, field types and casts is already
  % checked for well-formedness.
\item The methods of a class call each other mutually recursively.
\item The classes in the input are topologically sorted so that later
  classes only call methods in classes that come earlier in the
  sorting order.
  % to comply with the  rules
  % \rulename{GT-METHOD} and \rulename{GT-CLASS} (see
  % Section~\ref{chapter:type-rules}) of \TFGJ. 
\end{itemize}
Our requirements on the method calls do not impose serious
restrictions as any class, say \mv{C}, can be transformed to meet them as
follows. A preliminary dependency analysis determines an 
approximate call graph. We cluster the methods of \mv{C} according to
the $n$ strongly
connected components of the call graph. Then we split the class into a
class hierarchy 
$\mv{C}_1 \extends \dots \extends \mv{C}_n$ such that each class $\mv{C}_i$ contains
exactly the methods of one strongly connected component and assign a
method cluster to $\mv{C}_i$ if all calls to methods of  $\mv{C}$ now
target methods assigned to $\mv{C}_j$, for some $j\ge i$. The class
$\mv{C}_1$ replaces $\mv{C}$ everywhere in the program: in subtype
bounds, in \texttt{new} expressions, and in casts. More precisely, if
\mv{C} is defined by $\mathtt{class\ \exptype{C}{\ol X \extends \ol N}
\extends N \dots} $, then the class headers for the $\mv{C}_i$ are
defined as follows:
\begin{itemize}
\item  $\mathtt{class\ \exptype{C_i}{\ol X \extends \ol N}
\extends \exptype{C_{i+1}}{\ol X} \dots} $, for $1\le i < n$ and
\item  $\mathtt{class\ \exptype{C_n}{\ol X \extends \ol N}
\extends N \dots} $.
\end{itemize}
It follows from this discussion that the resulting classes have to be
processed backwards starting with $\mv{C}_n, \mv{C}_{n-1}, \dots, \mv{C}_1$.

\todo[inline]{PJT: may not treat mutual recursion across
  class boundaries satisfactorily.}

\subsection{Typing}
\label{chapter:type-rules}
\input{fjtyperules}

\subsection{Soundness of Typing}
\label{sec:soundness-typing}

We show that every typing derived by our \TFGJ rules gives rise to a
completion, that is, a well-typed FGJ program.
\begin{definition}[Erasure]
  Let $\mv{e}'$, $\mv{M}'$, $\mv{K}'$, $\mv{L}'$ be expression, method definition, constructor definition, class definition for FGJ. Define erasure functions 
  $\Erase{\mv{e}'}$, $\Erase{\mv{M}'}$, $\Erase{\mv{K}'}$, $\Erase{\mv{L}'}$ that map to the corresponding syntactic categories of \TFGJ by
  \begin{align*}
    \Erase{\mv x} &= \mv x \\
    \Erase{\mv e.\mv f} &= \Erase{\mv e}.\mv f \\
    \Erase{\exptype{e}{\ol T}.\mathtt{m}(\ol{e})} &= \Erase{\mv e}. \mathtt{m} (\Erase{\ol e}) \\
    \Erase{\mathtt{new}\ \exptype{C}{\ol T}(\ol{e})} & = \mathtt{new}\ \mv{C}(\Erase{\ol{e}}) \\
    \Erase{(\mv N)\ \mv e} & = (\mv N)\ \Erase{\mv e} \\
    \Erase{\exptype{}{\ol{X} \triangleleft \ol{N}}\ \mv{T}\ \mathtt{m}(\ol T\ \ol{x})\ \{ \mathtt{
    return}\ \mv e; \}} & = \mathtt{m}(\ol{x})\ \{ \mathtt{ return}\ \Erase{\mv e}; \} \\
    \Erase{\mv C(\ol{U}\ \ol{g}, \ol{T}\ \ol{f})\ \{\mathtt{super}(\ol{g}); \ \mathtt{this}.\ol{f}=\ol{f};\}} & = \mv C(\ol{g}, \ol{f})\ \{\mathtt{super}(\ol{g}); \ \mathtt{this}.\ol{f}=\ol{f};\} \\
    \Erase{\mathtt{class} \ \exptype{C}{\ol{X} \triangleleft \ol{N}} \triangleleft \ \mv N\ \{ \ol{T} \ \ol{f}; \,\mv K \, \ol{M} \}} & = 
    \mathtt{class} \ \exptype{C}{\ol{X} \triangleleft \ol{N}} \triangleleft \ \mv N\ \{ \ol{T} \ \ol{f}; \,\Erase{\mv K} \, \Erase{\ol{M}} \}
  \end{align*}
\end{definition}
\begin{definition}[Completion]
  An FGJ expression $\mv{e}'$ is a \emph{completion} of a \TFGJ expression $\mv{e}$ if $\mv{e} = \Erase{\mv{e}'}$. Completions for method definitions, constructor definitions, and class definitions
  are defined analogously.
\end{definition}
\begin{theorem}
  Suppose that $\mathtt{\vdash \ol L : \Pi}$ such that $|\mathtt{\Pi (\exptype{C}{\ol{X}}.m)}| = 1$, for all $\mv{C.m}$ defined in $\ol L$. Then there is a completion $\ol{L}'$ of $\ol L$ such that
  $\mv{L}'\ \mathtt{OK}$ is derivable in FGJ. 
\end{theorem}
\begin{proof}
  The proof is by induction on the length of $\ol L$.

  Consider the class typing $\mathtt{ \Pi \vdash \texttt{class}\ \exptype{C}{\ol{X} 
        \triangleleft \ol{N}} \triangleleft N\ \{ \ol{T} \
      \ol{f}; \ K \ \ol{M} \} \ \texttt{OK} : \Pi''}$ for an element of $\ol
    L$.

    We assume that all classes before $\mv{L}$ are completed according to the incoming $\mathtt{\Pi}$:
    If $\mathtt{\Pi (\exptype{D}{\ol{X}}.n)} = \mathtt{\exptype{}{\ol{Y} \triangleleft  \ol{P}}
      \ol{T} \to T}$, then $\mathtt{\exptype{}{\ol{Y} \triangleleft  \ol{P}}\ T\ \mv{n}(\ol{T}\
      \ol{x}) \dots}$ is in the completion of $\mv{D}$.

    Clearly, we can construct a completion for the class, if we can do so for each method. So we
    have to construct $\ol{M}'$ such that $\mathtt{\ol{M}'\ \mathtt{OK\ IN}\ \exptype{C}{\ol{X} 
        \triangleleft \ol{N}}}$. 

    Inversion of \rulename{GT-CLASS} yields
    \begin{gather}
      \label{eq:3}
      \mathtt{\Pi' = \Pi \cup \set{\exptype{C}{\ol{X}}.m \mapsto \exptype{}{} \ol{T_m} \to T_m \mid m \in \ol{M}} } \\
      \mathtt{\Pi'' = \Pi \cup \set{\exptype{C}{\ol{X}}.m \mapsto
          \exptype{}{\ol{Y} \triangleleft  \ol{P}} \ol{T_m} \to T_m \mid m \in \ol{M}} } \\
      \label{eq:5}
      \mathtt{\Pi', \Delta \vdash \ol{M} \ \texttt{OK IN}\
        \exptype{C}{\ol{X} \triangleleft \ol{N}} \extends N  \texttt{
          with } \exptype{}{\ol{Y} \triangleleft  \ol{P}}} \\
      \label{eq:7}
      \mathtt{\Delta = \ol{X} \subeq  \ol{N}, \ol{Y} \subeq  \ol{P}}
    \end{gather}
    Given some $\mv{M} = \texttt{m}(\ol{\mathtt{x}}) \{\texttt{return}\ \mathtt{e}_0;\} \in \ol{M}$,
    we show that
    \begin{gather}
      \label{eq:4}
      \exptype{}{\ol{Y} \triangleleft  \ol{P}}\ \mathtt{T_m}\ \texttt{m}(\ol{T_m}\ \ol{{x}})
      \{\texttt{return}\ \mathtt{e}'_0;\} \texttt{ OK IN }\exptype{C}{\ol{X} \triangleleft \ol{N}}
    \end{gather}
    is derivable for such completion $\mathtt{e_0'}$ of $\mathtt{e_0}$.

    By inversion of \eqref{eq:5} for $\mv{M}$, we obtain
    \begin{gather}
      \label{eq:6}
      \mathtt{\textit{override}(m, N, \exptype{}{\ol{Y} \triangleleft \ol{P}}\ol{T_m} \to T_m,
        \Pi) } \\
      \label{eq:9}
      \mathtt{\Pi; \Delta ; \ol{x}:\ol{T_m},\ this : \exptype{C}{\ol{X}} \vdash e_0 : S} \\
      \label{eq:8}
      \mathtt{\Delta \vdash S \subeq  T_m }
    \end{gather}
    As $\mathtt{\Delta}$ in~\eqref{eq:7} is defined as in \rulename{GT-METHOD'}, the well-formedness
    judgments are all given, the subtyping judgment \eqref{eq:8} is given as well as the override
    \eqref{eq:9}, the rule \rulename{GT-METHOD'} applies if we can establish
    \begin{gather}
      \label{eq:10}
      \mathtt{\Delta ; \ol{x}:\ol{T_m},\ this : \exptype{C}{\ol{X}} \vdash e_0' : S}
    \end{gather}
    for a completion of $\mathtt{e_0}$.

    To see that, we need to consider the rules \rulename{GT-NEW} and \rulename{GT-INVK}. The
    \rulename{GT-NEW} rule poses the existence of some $\ol{U}$ such that $\mv{N} =
    \exptype{C}{\ol{U}}$ for checking $\mv{e} = \mv{new}\ \mv{C} (\ol{e}) : \mv{N}$. In the completion, we
    define $\mv{e'} = \mv{new}\ \mv{N} (\ol{e}') : \mv{N}$ to apply rule \rulename{GT-NEW'} to the completions
    of the arguments.

    For the rule \rulename{GT-INVK}, we first consider calls to methods not defined in the current
    class. By our assumption on previously checked classes $\mv{D}$ and their methods $\mv{n}$,
    $\mathit{mtype} (\mv{n}, \mv{D}, \mv\Pi) = \{\mathit{mtype}' (\mv{n}, \mv{D}')\}$ where the right
    side lookup happens in the completion following the definitions for FGJ (i.e., $\mv{D'}$ is the
    completion for $\mv D$). The \rulename{GT-INVK} rule poses the existence of some $\ol{V}$ that
    satisfies the same conditions as in \rulename{GT-INVK'}. Hence, we define the completion of
    $\mathtt{e_0.\mv{n}(\ol{e}) : [\ol{V}/\ol{Y}]U }$ as
    $\mathtt{e_0'.\exptype{n}{\ol{V}}(\ol{e}') : [\ol{V}/\ol{Y}]U }$.

    Next we consider calls to methods $\mv{n}$ defined in the current class, say, $\mv{C}$. For those methods,
    $\mathit{mtype} (\mv{n}, \mv{C}, \mv\Pi) = \exptype{}{} \ol{U} \to \mv U$, a non-generic
    type. By the definition of $\mathtt{\Pi''}$, we know that the type of this method will be
    published in the completion as $\exptype{}{\ol{Y} \triangleleft  \ol{P}} \ol{U} \to \mv
    U$. Hence, $\mathit{mtype}' (\mv{n}, \mv{C}') = \exptype{}{\ol{Y} \triangleleft  \ol{P}} \ol{U}
    \to \mv U$. As methods in $\mv{C}$ are mutually recursive, the rule must pose that $\ol{V} = \ol{Y}$ (cf.\
    Proposition~\ref{prop:polymorphi-recursion}). This setting fulfills all assumptions:
    \begin{gather}
      \label{eq:11}
      \mathtt{\Delta \vdash \ol{Y} \ \texttt{ok} } \\
      \mathtt{\Delta \vdash \ol{Y} \subeq  [\ol{Y}/\ol{Y}]\ol{P} }       
    \end{gather}
    Hence, we define the completion of
    $\mathtt{e_0.\mv{n}(\ol{e}) : [\ol{Y}/\ol{Y}]U }$ as
    $\mathtt{e_0'.\exptype{n}{\ol{Y}}(\ol{e}') : [\ol{Y}/\ol{Y}]U }$, which is derivable in FGJ.

    All the remaining expression typing rules are shared between FGJ and \TFGJ, so they do not
    affect completions.
\end{proof}


\subsection{Principal Type}
\todo[inline]{PJT: is this subsumed by
  Section~\ref{sec:multiple-results}? Do we have principal types when
  we admit intersection types?}

\todo[inline]{MP: I think so. But have to define an partial ording
  $\triangleright$ of princpality:

  $ty_1 \& \ldots \& ty_n \triangleright ty'_i$, if $ty'_i$ is a subtype of any
  $ty_i$ and\\ $ty'_i \triangleright ty'_i[\ol{U}/\ol{X}]$
}
Featherweight Generic Java has no unique principal typing.
We can show this easily with an example.
We try to find the principal type for the method \texttt{method1}.
\begin{lstlisting}
class Global{
  method1(a){
    a.add(this);
    return a.get();
  }
}
class List<A> {
  add(A item){...}
  A get() ...
}
\end{lstlisting}
In \texttt{method1} neither the return type nor the type for the parameter \texttt{a} are specified.
The return type of the method depends on the type of \texttt{a}.
If we set in the type \texttt{List<Object>} here, then \texttt{method1} would return \texttt{Object}.
The type \texttt{List<Global>} would also be correct.
Then the return type of the method can also be the type \texttt{Global}.

The principal type would either be an intersection type or the method \texttt{method1} has to be overloaded.
FGJ neither supports intersection types nor overloading.
Therefore we cannot set in the principal type and have to stick with one of the possible solutions,
for example\\
\texttt{List<Global> method1(List<Global> a)}.

It is possible for a class to have multiple principal type solutions.
This can lead to a type error when compiling multiple classes.
\begin{lstlisting}
  class Global{
    method1(a){
      a.add(this);
      return a.get();
    }
  }
  class Class2{
    Object test(){
      return new Global().method1(new List<Object>());
    }
  }
\end{lstlisting}
Our type inference algorithm is able to infer all of the principal type solutions, but only one of them can be set in.
If we set in \texttt{List<Global>} as the parameter type for the \texttt{method1},
then the class \texttt{Class2} would lead to a type error.
In this case the type inference algorithm has to try another type solution for \texttt{method1}
to render the program type correct.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "TIforGFJ"
%%% End:
