\section{Preliminaries}
\label{sec:preliminaries}
\subsection{Syntax}
% \commentarymargin{Input assumptions}
% No overloaded methods
% No Or-Constraints
\begin{figure}[tp]
\begin{align*}
  \mv T &::= \mv X \mid \mv N \\
  \mv N &::= \exptype{C}{\ol{T}}\\
  \mv L &::= \mathtt{class} \ \exptype{C}{\ol{X} \triangleleft \ol{N}} \triangleleft \ \mv N\ \{ \ol{T} \ \ol{f}; \,\mv K \, \ol{M} \} \\
  \mv K &::= \mv C(\ol{f})\ \{\mathtt{super}(\ol{f}); \ \mathtt{this}.\ol{f}=\ol{f};\} \\
  %M &::= \exptype{}{\ol{X} \triangleleft \ol{X}}\ T \ \mathtt{m}(\overline{T} \, \overline{x})\{ \mathtt{ return }\ e; \} \\
  \mv M &::= \mathtt{m}(\ol{x})\ \{ \mathtt{ return}\ \mv e; \} \\
  \mv e &::= \mv x \mid \mv e.\mv f \mid
             \mv e.\mathtt{m}(\ol{e}) \mid \mathtt{new}\ \mathtt{C}(\ol{e})
             \mid (\mv N)\ \mv e
  %M ::=& T \ \mathtt{m}(\overline{T} \, \overline{x})\{ \mathtt{ return }\ e; \} \\
  %e ::=& \mathtt{this} \, | \, x \, | \, e.f \, | \, e.\exptype{\mathtt{m}}{\ol{T}}(\overline{e}) \, | \, \mathtt{new }\ C(\overline{e}) \, | \, (C) e \\
\end{align*}
  \caption{Syntax of \TFGJ}
  \label{fig:syntax-tfgj}
\end{figure}
The input of our global type inference algorithm is a modified version
of the language Featherweight Generic Java
(FGJ)~\cite{DBLP:journals/toplas/IgarashiPW01}, which we call \TFGJ
(with Global Type Inference).
Its syntax is shown in Figure~\ref{fig:syntax-tfgj}.
Compared to FGJ,
type annotations for method parameters and method return types are omitted.
Object creation via \texttt{new} as well as method calls come do not
require instantiation of their generic parameters.
We keep the class constraints ${\ol{X} \triangleleft \ol{N}}$ as well as the types
for fields $\ol{T} \ \ol{f}$ as we consider them as part of the
specification of a class.

% \textbf{Prechecks:}
We make the following assumptions for the input program:
\begin{itemize}
\item All types $\mv N$ and $\mv T$ are well formed according to the
  rules of FGJ, which carry over to \TFGJ (see Fig.~\ref{fig:well-formedness-and-subtyping}).
  % This can be checked easily, because no types annotations are omitted in the class header.
  % The generic variables of each class as well as their bounds are given in the input.
  % We assume that the each written type in the input in bounds of
  % classes, super class types, field types and casts is already
  % checked for well-formedness.
\item The methods of a class call each other mutually recursively.
\item The classes in the input are topologically sorted so that later
  classes only call methods in classes that come earlier in the
  sorting order.
  % to comply with the  rules
  % \rulename{GT-METHOD} and \rulename{GT-CLASS} (see
  % Section~\ref{chapter:type-rules}) of \TFGJ. 
\end{itemize}
Our requirements on the method calls do not impose serious
restrictions as any class, say \mv{C}, can be transformed to meet them as
follows. A preliminary dependency analysis determines an 
approximate call graph. We cluster the methods of \mv{C} according to
the $n$ strongly
connected components of the call graph. Then we split the class into a
class hierarchy 
$\mv{C}_1 \extends \dots \extends \mv{C}_n$ such that each class $\mv{C}_i$ contains
exactly the methods of one strongly connected component and assign a
method cluster to $\mv{C}_i$ if all calls to methods of  $\mv{C}$ now
target methods assigned to $\mv{C}_j$, for some $j\ge i$. The class
$\mv{C}_1$ replaces $\mv{C}$ everywhere in the program: in subtype
bounds, in \texttt{new} expressions, and in casts. More precisely, if
\mv{C} is defined by $\mathtt{class\ \exptype{C}{\ol X \extends \ol N}
\extends N \dots} $, then the class headers for the $\mv{C}_i$ are
defined as follows:
\begin{itemize}
\item  $\mathtt{class\ \exptype{C_i}{\ol X \extends \ol N}
\extends \exptype{C_{i+1}}{\ol X} \dots} $, for $1\le i < n$ and
\item  $\mathtt{class\ \exptype{C_n}{\ol X \extends \ol N}
\extends N \dots} $.
\end{itemize}
It follows from this discussion that the resulting classes have to be
processed backwards starting with $\mv{C}_n, \mv{C}_{n-1}, \dots, \mv{C}_1$.

\todo[inline]{PJT: may not treat mutual recursion across
  class boundaries satisfactorily.}

\subsection{Typing}
\label{chapter:type-rules}
\input{fjtyperules}

\subsection{Soundness of Typing}
\label{sec:soundness-typing}

We show that every typing derived by our \TFGJ rules gives rise to a
completion, that is, a well-typed FGJ program.
\begin{definition}[Erasure]
  Let $\mv{e}'$, $\mv{M}'$, $\mv{K}'$, $\mv{L}'$ be expression, method definition, constructor definition, class definition for FGJ. Define erasure functions 
  $\Erase{\mv{e}'}$, $\Erase{\mv{M}'}$, $\Erase{\mv{K}'}$, $\Erase{\mv{L}'}$ that map to the corresponding syntactic categories of \TFGJ by
  \begin{align*}
    \Erase{\mv x} &= \mv x \\
    \Erase{\mv e.\mv f} &= \Erase{\mv e}.\mv f \\
    \Erase{\exptype{e}{\ol T}.\mathtt{m}(\ol{e})} &= \Erase{\mv e}. \mathtt{m} (\Erase{\ol e}) \\
    \Erase{\mathtt{new}\ \exptype{C}{\ol T}(\ol{e})} & = \mathtt{new}\ \mv{C}(\Erase{\ol{e}}) \\
    \Erase{(\mv N)\ \mv e} & = (\mv N)\ \Erase{\mv e} \\
    \Erase{\exptype{}{\ol{X} \triangleleft \ol{N}}\ \mv{T}\ \mathtt{m}(\ol T\ \ol{x})\ \{ \mathtt{
    return}\ \mv e; \}} & = \mathtt{m}(\ol{x})\ \{ \mathtt{ return}\ \Erase{\mv e}; \} \\
    \Erase{\mv C(\ol{U}\ \ol{g}, \ol{T}\ \ol{f})\ \{\mathtt{super}(\ol{g}); \ \mathtt{this}.\ol{f}=\ol{f};\}} & = \mv C(\ol{g}, \ol{f})\ \{\mathtt{super}(\ol{g}); \ \mathtt{this}.\ol{f}=\ol{f};\} \\
    \Erase{\mathtt{class} \ \exptype{C}{\ol{X} \triangleleft \ol{N}} \triangleleft \ \mv N\ \{ \ol{T} \ \ol{f}; \,\mv K \, \ol{M} \}} & = 
    \mathtt{class} \ \exptype{C}{\ol{X} \triangleleft \ol{N}} \triangleleft \ \mv N\ \{ \ol{T} \ \ol{f}; \,\Erase{\mv K} \, \Erase{\ol{M}} \}
  \end{align*}
\end{definition}
\begin{definition}[Completion]
  An FGJ expression $\mv{e}'$ is a \emph{completion} of a \TFGJ expression $\mv{e}$ if $\mv{e} = \Erase{\mv{e}'}$. Completions for method definitions, constructor definitions, and class definitions
  are defined analogously.
\end{definition}
\begin{theorem}
  Suppose that $\mathtt{\vdash \ol L : \Pi}$. Then there is a completion $\ol{L}'$ of $\ol L$ such that $\mv{L}'\ \mathtt{OK}$ is derivable in FGJ.
\end{theorem}


\subsection{Principal Type}
\todo[inline]{PJT: is this subsumed by
  Section~\ref{sec:multiple-results}? Do we have principal types when
  we admit intersection types?}

\todo[inline]{MP: I think so. But have to define an partial ording
  $\triangleright$ of princpality:

  $ty_1 \& \ldots \& ty_n \triangleright ty'_i$, if $ty'_i$ is a subtype of any
  $ty_i$ and\\ $ty'_i \triangleright ty'_i[\ol{U}/\ol{X}]$
}
Featherweight Generic Java has no unique principal typing.
We can show this easily with an example.
We try to find the principal type for the method \texttt{method1}.
\begin{lstlisting}
class Global{
  method1(a){
    a.add(this);
    return a.get();
  }
}
class List<A> {
  add(A item){...}
  A get() ...
}
\end{lstlisting}
In \texttt{method1} neither the return type nor the type for the parameter \texttt{a} are specified.
The return type of the method depends on the type of \texttt{a}.
If we set in the type \texttt{List<Object>} here, then \texttt{method1} would return \texttt{Object}.
The type \texttt{List<Global>} would also be correct.
Then the return type of the method can also be the type \texttt{Global}.

The principal type would either be an intersection type or the method \texttt{method1} has to be overloaded.
FGJ neither supports intersection types nor overloading.
Therefore we cannot set in the principal type and have to stick with one of the possible solutions,
for example\\
\texttt{List<Global> method1(List<Global> a)}.

It is possible for a class to have multiple principal type solutions.
This can lead to a type error when compiling multiple classes.
\begin{lstlisting}
  class Global{
    method1(a){
      a.add(this);
      return a.get();
    }
  }
  class Class2{
    Object test(){
      return new Global().method1(new List<Object>());
    }
  }
\end{lstlisting}
Our type inference algorithm is able to infer all of the principal type solutions, but only one of them can be set in.
If we set in \texttt{List<Global>} as the parameter type for the \texttt{method1},
then the class \texttt{Class2} would lead to a type error.
In this case the type inference algorithm has to try another type solution for \texttt{method1}
to render the program type correct.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "TIforGFJ"
%%% End:
