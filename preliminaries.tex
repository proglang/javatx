\section{Preliminaries}
\label{sec:preliminaries}
\subsection{Syntax}
\commentarymargin{Input assumptions}
% No overloaded methods
% No Or-Constraints
\begin{figure}[tp]
\begin{align*}
  \mv T &::= \mv X \, | \, \mv N \\
  \mv N &::= \exptype{C}{\ol{T}}\\
  \mv L &::= \mathtt{class} \ \exptype{C}{\ol{X} \triangleleft \ol{N}}
             \triangleleft \ \mv N \{ \ol{T} \ \ol{f}; \,\mv K \, \ol{M} \} \\
  \mv K &::= \mv C(\ol{T} \ \ol{f})\{\mathtt{super}(\ol{f}); \ \mathtt{this}.\ol{f}=\ol{f};\} \\
  %M &::= \exptype{}{\ol{X} \triangleleft \ol{X}}\ T \ \mathtt{m}(\overline{T} \, \overline{x})\{ \mathtt{ return }\ e; \} \\
  \mv M &::= \mathtt{m}(\ol{x})\{ \mathtt{ return}\ \mv e; \} \\
  \mv e &::= \mv x \, | \, \mv e.\mv f \, | \,
             \mv e.\mathtt{m}(\ol{e}) \, | \, \mathtt{new}\ \mathtt{C}(\ol{e})
             \ |\ (N)\ e
  %M ::=& T \ \mathtt{m}(\overline{T} \, \overline{x})\{ \mathtt{ return }\ e; \} \\
  %e ::=& \mathtt{this} \, | \, x \, | \, e.f \, | \, e.\exptype{\mathtt{m}}{\ol{T}}(\overline{e}) \, | \, \mathtt{new }\ C(\overline{e}) \, | \, (C) e \\
\end{align*}
  \caption{Syntax of \TFGJ}
  \label{fig:syntax-tfgj}
\end{figure}
The input for our global type inference algorithm is a modified version of the Featherweight Generic Java language.
We call our language Featherweight Generic Java with global type inference (FGJ-GT).
Its syntax, shown in Figure~\ref{fig:syntax-tfgj}, is a modified version of the Featherweight Generic Java (FGJ) syntax. 
Type annotations for method parameters and method return types are omitted %, except the ones for casts and \texttt{new} calls. 
and the instantiation of a class via the \texttt{new} statement, as well as the method call, do now function without generic parameters.

\subsection{Featherweight Java Typing Rules}\label{chapter:type-rules}
\input{fjtyperules}

\subsection{Principal Type}
\todo[inline]{PJT: is this subsumed by
  Section~\ref{sec:multiple-results}? Do we have principal types when
  we admit intersection types?}
Featherweight Generic Java has no unique principal typing.
We can show this easily with an example.
We try to find the principal type for the method \texttt{method1}.
\begin{lstlisting}
class Global{
  method1(a){
    a.add(this);
    return a.get();
  }
}
class List<A> {
  add(A item){...}
  A get() ...
}
\end{lstlisting}
In \texttt{method1} neither the return type nor the type for the parameter \texttt{a} are specified.
The return type of the method depends on the type of \texttt{a}.
If we set in the type \texttt{List<Object>} here, then \texttt{method1} would return \texttt{Object}.
The type \texttt{List<Global>} would also be correct.
Then the return type of the method can also be the type \texttt{Global}.

The principal type would either be an intersection type or the method \texttt{method1} has to be overloaded.
FGJ neither supports intersection types nor overloading.
Therefore we cannot set in the principal type and have to stick with one of the possible solutions,
for example\\
\texttt{List<Global> method1(List<Global> a)}.

It is possible for a class to have multiple principal type solutions.
This can lead to a type error when compiling multiple classes.
\begin{lstlisting}
  class Global{
    method1(a){
      a.add(this);
      return a.get();
    }
  }
  class Class2{
    Object test(){
      return new Global().method1(new List<Object>());
    }
  }
\end{lstlisting}
Our type inference algorithm is able to infer all of the principal type solutions, but only one of them can be set in.
If we set in \texttt{List<Global>} as the parameter type for the \texttt{method1},
then the class \texttt{Class2} would lead to a type error.
In this case the type inference algorithm has to try another type solution for \texttt{method1}
to render the program type correct.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "TIforGFJ"
%%% End:
