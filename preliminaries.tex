\section{Preliminaries}
\label{sec:preliminaries}
\subsection{Syntax}
\commentarymargin{Input assumptions}
% No overloaded methods
% No Or-Constraints
\begin{figure}[tp]
\begin{align*}
  \mv T &::= \mv X \mid \mv N \\
  \mv N &::= \exptype{C}{\ol{T}}\\
  \mv L &::= \mathtt{class} \ \exptype{C}{\ol{X} \triangleleft \ol{N}}
             \triangleleft \ \mv N\ \{ \ol{T} \ \ol{f}; \,\mv K \, \ol{M} \} \\
  \mv K &::= \mv C(\ol{T} \ \ol{f})\ \{\mathtt{super}(\ol{f}); \ \mathtt{this}.\ol{f}=\ol{f};\} \\
  %M &::= \exptype{}{\ol{X} \triangleleft \ol{X}}\ T \ \mathtt{m}(\overline{T} \, \overline{x})\{ \mathtt{ return }\ e; \} \\
  \mv M &::= \mathtt{m}(\ol{x})\ \{ \mathtt{ return}\ \mv e; \} \\
  \mv e &::= \mv x \mid \mv e.\mv f \mid
             \mv e.\mathtt{m}(\ol{e}) \mid \mathtt{new}\ \mathtt{C}(\ol{e})
             \mid (\mv N)\ \mv e
  %M ::=& T \ \mathtt{m}(\overline{T} \, \overline{x})\{ \mathtt{ return }\ e; \} \\
  %e ::=& \mathtt{this} \, | \, x \, | \, e.f \, | \, e.\exptype{\mathtt{m}}{\ol{T}}(\overline{e}) \, | \, \mathtt{new }\ C(\overline{e}) \, | \, (C) e \\
\end{align*}
  \caption{Syntax of \TFGJ}
  \label{fig:syntax-tfgj}
\end{figure}
The input of our global type inference algorithm is a modified version
of the language Featherweight Generic Java
(FGJ)~\cite{DBLP:journals/toplas/IgarashiPW01}, which we call \TFGJ
(with Global Type Inference).
Its syntax is shown in Figure~\ref{fig:syntax-tfgj}.
Compared to FGJ,
type annotations for method parameters and method return types are omitted.
Object creation via \texttt{new} as well as method calls come do not
require instantiation of their generic parameters.
We keep the class constraints ${\ol{X} \triangleleft \ol{N}}$ as well as the types
for fields $\ol{T} \ \ol{f}$ as we consider them as part of the
specification of a class.

% \textbf{Prechecks:}
We make the following assumptions for the input program:
\begin{itemize}
\item All types $\mv N$ and $\mv T$ are well formed according to the
  rules of FGJ, which carry over to \TFGJ (see Fig.~\ref{fig:well-formedness-and-subtyping}).
  % This can be checked easily, because no types annotations are omitted in the class header.
  % The generic variables of each class as well as their bounds are given in the input.
  % We assume that the each written type in the input in bounds of
  % classes, super class types, field types and casts is already
  % checked for well-formedness. 
\item The classes in the input are sorted to comply with the  rules
  \rulename{GT-METHOD} and \rulename{GT-CLASS} (see
  Section~\ref{chapter:type-rules}) of \TFGJ. 
%TODO
\end{itemize}

\subsection{Featherweight Java Typing Rules}\label{chapter:type-rules}
\input{fjtyperules}

\subsection{Principal Type}
\todo[inline]{PJT: is this subsumed by
  Section~\ref{sec:multiple-results}? Do we have principal types when
  we admit intersection types?}
Featherweight Generic Java has no unique principal typing.
We can show this easily with an example.
We try to find the principal type for the method \texttt{method1}.
\begin{lstlisting}
class Global{
  method1(a){
    a.add(this);
    return a.get();
  }
}
class List<A> {
  add(A item){...}
  A get() ...
}
\end{lstlisting}
In \texttt{method1} neither the return type nor the type for the parameter \texttt{a} are specified.
The return type of the method depends on the type of \texttt{a}.
If we set in the type \texttt{List<Object>} here, then \texttt{method1} would return \texttt{Object}.
The type \texttt{List<Global>} would also be correct.
Then the return type of the method can also be the type \texttt{Global}.

The principal type would either be an intersection type or the method \texttt{method1} has to be overloaded.
FGJ neither supports intersection types nor overloading.
Therefore we cannot set in the principal type and have to stick with one of the possible solutions,
for example\\
\texttt{List<Global> method1(List<Global> a)}.

It is possible for a class to have multiple principal type solutions.
This can lead to a type error when compiling multiple classes.
\begin{lstlisting}
  class Global{
    method1(a){
      a.add(this);
      return a.get();
    }
  }
  class Class2{
    Object test(){
      return new Global().method1(new List<Object>());
    }
  }
\end{lstlisting}
Our type inference algorithm is able to infer all of the principal type solutions, but only one of them can be set in.
If we set in \texttt{List<Global>} as the parameter type for the \texttt{method1},
then the class \texttt{Class2} would lead to a type error.
In this case the type inference algorithm has to try another type solution for \texttt{method1}
to render the program type correct.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "TIforGFJ"
%%% End:
