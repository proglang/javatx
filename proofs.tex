\section{Unify Soundness Proof}\label{chapter:unifySoundnessProof}
\begin{proof}
    We show theorem \ref{theo:unifySoundness} by going backwards over every step of the algorithm.
    Let $\sigma = \set {a_1 \mapsto T_1, \ldots , a_n \mapsto T_n}$ and $\set{\ol{Y} <: \ol{P}}$ be the result of a $\unify{}(\consSet, \Delta)$ call.
    We show for every constraint in the input set $(a \lessdot b) \in \consSet_{in}$ and $(c \doteq d) \in \consSet_{in}$:
    $\Delta, \ol{Y} <: \ol{P} \vdash \sigma(a) \olsub \sigma(b)$ and $\sigma(c) = \sigma(d)$\\
    
    We now consider each step of the \unify{} algorithm
    which transforms the input set of constraints $C$ to a set $C'$
    If $\sigma$ is an unifier of $C'$, then $\sigma$ is an unifier of $C$, too.
    
    \begin{description}
    \item[Step 6] The last step does not change the constraint set.
    \item[Step 5]
    A unifier which is correct for $a \doteq b$ is also correct for $a \lessdot b$.
    The transformation $C' = [a/b]C$ does not change this.
    
    \item[Step 4]
    The constraint sets are not altered here.
    
    \item[Step 3]
    An unifier $\sigma$ that is correct for a constraint set
    $[\itype{T}/a]C \cup \set{a \doteq \itype{T}}$ is also correct for
    the set $C \cup \set{a \doteq \itype{T}}$.
    From the constraint $(a \doteq \itype{T})$ it follows that $\sigma(a) = \itype{T}$.
    This means that $\sigma(C) = \sigma([\itype{T}/a]C)$,
    because every occurence of $a$ in $C$ will be replaced by $\itype{T}$ anyways when using the unifier $\sigma$.
    
    \item[Step 2]
    This step transforms constraints of the form $\exptype{C}{\ol{X}} \lessdot a$ and
    $\set{a \lessdot \exptype{C}{\ol{X}}, a \lessdot^* b}$ jinto sets of or-constraints.
    We can show that if there is a resulting set of constraints which has $\sigma$ as its correct unifier
    then $\sigma$ also has to be a correct unifier for the constraints before this transformation.
    
    We look at each transformation done in step 2:
    \begin{description}
    \item[$\set{\exptype{C}{\ol{T}} \lessdot a} \in C \to \set{a \doteq [\ol{T}/\ol{X}]N} \in C'$:]
    If $\exptype{C}{\ol{X}} <: N$ and $\sigma$ is correct for $(a \doteq [\ol{T}/\ol{X}]N)$
    then $\sigma$ is also correct for $(\exptype{C}{\ol{T}} \lessdot a))$.
    When substituting $a$ for $[\ol{T}/\ol{X}]N$ we get 
    $(\exptype{C}{\ol{T}} \lessdot [\ol{T}/\ol{X}]N)$
    , which is correct because $\exptype{C}{\ol{X}} <: \exptype{C}{\ol{Y}}$
    (see \texttt{S-CLASS} rule).
    \item[$\set{a \lessdot \exptype{C}{\overline{T}},\ a \lessdot^* b} \in C \to \set{T \lessdot b, a \lessdot \exptype{C}{\overline{T}},\ a \lessdot^* b} \in C'$]
    obviously.
    \item[$\set{a \lessdot \exptype{C}{\overline{T}},\ a \lessdot^* b} \in C \to \set{a \doteq [\ol{T}/\ol{X}]N, a \lessdot \exptype{C}{\overline{T}},\ a \lessdot^* b} \in C'$]
    This is the same as in the first transformation.
    Here we can also show correctness via the \texttt{S-CLASS} rule.
    
    \end{description}
    
    \item[Step 1]
    \begin{description}
    \item[erase-rules] remove correct constraints from the constraint set.
    A unifier $\sigma$ that is correct for the constraint set $C$
    is also correct for $C \cup \set{\theta \doteq \theta}$
    and $C \cup \set{\theta \lessdot \theta'}$, when $\theta \leq \theta'$.
    \item[swap-rule] does not change the unifier for the constraint set.
    $\doteq$ is a symmetric operator and parameters can be swapped freely.
    \item[match] The subtype relation is transitive, so if there is a correct solution for
    $a \lessdot \exptype{C}{\ol{X}}, \exptype{C}{\ol{X}} \lessdot \exptype{D}{\ol{Y}}$
    then this solution would also apply for $a \lessdot \exptype{C}{\ol{X}} \lessdot \exptype{D}{\ol{Y}}$
    or $a \lessdot \exptype{D}{\ol{Y}}$.
    \item[adopt] An unifier which is correct for $C \cup \set{a \lessdot \exptype{C}{\ol{X}}, b \lessdot^* a, b \lessdot \exptype{D}{\ol{Y}}, b \lessdot \exptype{C}{\ol{X}}}$
    is also correct for $C \cup \set{a \lessdot \exptype{C}{\ol{X}}, b \lessdot^* a, b \lessdot \exptype{D}{\ol{Y}}}$.
    \item[adapt] If there is a $\sigma$ which is a correct unifier for a set
    $C \cup \set{ \exptype{C}{[\ol{A}/\ol{X}]\ol{Y}} \doteq \exptype{C}{\ol{B}}}$ then it is also
    a correct unifier for the set $C \cup \set{ \exptype{D}{\ol{A}} \lessdot \exptype{C}{\ol{B}}}$,
    if there is a subtype relation $\exptype{D}{\ol{X}} \leq^* \exptype{C}{\ol{Y}}$.
    To make the set $C \cup \set{ [\ol{A}/\ol{X}]\exptype{C}{\ol{Y}} \doteq \exptype{C}{\ol{B}}}$ the unifier 
    $\sigma$ must satisfy the condition $\sigma([\ol{A}/\ol{X}]\ol{Y}) = \sigma(\ol{B})$.
    By substitution we get $C \cup \set{ \exptype{D}{\ol{A}} \lessdot \exptype{C}{[\ol{A}/\ol{X}]\ol{Y}}}$
    which is correct under the \texttt{S-CLASS} rule.
    \item[reduce] The \texttt{reduce} rule is obviously correct under the FJ typing rules.
    \end{description}
    
    \item[OrConstraints]
    If $\sigma$ is a correct unifier for one of the constraint sets in $C_{set}$
    then it is also a correct unifier for the input set $\consSet_{in}$.
    When building the cartesian product of the \textbf{OrConstraints} every possible
    combination for $\consSet_{in}$ is build.
    No constraint is altered, deleted or modified during this step.
    \end{description}
    \end{proof}
    
    \hfill $\square$

\section{Unify Completeness Proof}\label{chapter:unifyCompletenessProof}
\begin{proof}

We proof theorem \ref{theo:unifyCompleteness} by assuming there exists a general unifier $\sigma = \set {a_1 \mapsto T_1, \ldots , a_n \mapsto T_n}$.
We then look at every step of the algorithm, which alters the set of constraints $C$.
We show that if $\sigma$ is general unifer for the input then $\sigma$ is a
general unifer for the altered set of constraints. This means that no solution
is excluded.


%Assume there is a unifier and the Unify algorithm finds it.
%Then no rule makes this unifier impossible / removes this unifier.

\begin{description}
\item[Step 1:]
The first step applies the seven rules from figure
\ref{fig:fgjreduce-rules} and \ref{fig:fgjerase-rules}.

\textbf{erase-rule:} The constraint $\tv{a} \doteq \tv{a}$ is true for every unifier and can be removed.

\textbf{swap-rule:} $\doteq$ is a symmetric operator and parameters can be swapped freely.
This operation does not change the meaning of the constraint set.

\textbf{match-rule:}
If there is a solution for $a \lessdot \exptype{C}{\ol{\itype{T}}}, a \lessdot \exptype{D}{\ol{\itype{U}}}$,
this is also a solution for $a \lessdot \exptype{C}{\ol{\itype{T}}}, \exptype{C}{\ol{\itype{T}}} \lessdot \exptype{D}{\ol{\itype{U}}}$.
A correct unifier $\sigma$ has to find a type for $a$, which complies with $a \lessdot \exptype{C}{\ol{\itype{T}}}$ and $a \lessdot \exptype{D}{\ol{\itype{U}}}$.
Due to the subtyping relation being transitive this means that $\sigma(a) \lessdot \exptype{C}{\ol{\itype{T}}} \lessdot \exptype{D}{\ol{\itype{U}}}$.

\textbf{adopt-rule:} Subtyping in FJ is transitive,
which allows us to apply the adopt rule without excluding any possible unifier.

\textbf{adapt-rule:} Every solution which is correct for the constraints
$Eq \cup \set{ \exptype{C}{[\ol{\itype{A}}/\ol{X}]\ol{\itype{T}}} \doteq \exptype{C}{\ol{\itype{U}}}}$ is also
a correct solution for the set $Eq \cup \set{ \exptype{D}{\ol{\itype{A}}} \lessdot \exptype{C}{\ol{\itype{U}}}}$.
According to the FGJ \texttt{S-CLASS} rule there can only be a possible solution for 
$\exptype{C}{[\ol{\itype{A}}/\ol{X}]\ol{\itype{T}}} \doteq \exptype{C}{\ol{\itype{U}}}$
if $\ol{\itype{U}} = [\ol{\itype{A}}/\ol{X}]\ol{\itype{T}}$.
Therefore this transformation does not remove any possible solution from the constraint set.

\textbf{reduce-rule:}
%The constraint is not altered

If $\sigma$ is a unifier of $\exptype{D}{\ol{\itype{T}}} \lessdot
\exptype{D}{\ol{\itype{U}}}$
then $\sigma$ is a unifier of $\ol{\itype{T}} = \ol{\itype{U}}$.
Therefore this step does not remove a possible solution.

\textbf{equals-rule:}
This rule removes a circle in the constraints.
This does not remove a solution.

\item[Step 2:]
%The second step builds multiple constraint sets of all possible type combinations for the $\lessdot$-constraints.
The second step of the algorithm eliminates $\lessdot$-constraints
by replacing them with $\doteq$-constraints.
For each $(\exptype{C}{\ol{\itype{T}}} \lessdot b), (b \lessdot \exptype{C}{\ol{\itype{U}}})$ constraint the algorithm builds a set with every
possible supertype of $\exptype{C}{\ol{\itype{T}}}$.
So if there is a correct unifier $\sigma$ for the constraints before this conversion there will be at least one set of
constraints for which $\sigma$ is a correct unifier.

Additionally this step resolves constraints of the form $\tv{a} \lessdot \exptype{C}{\ol{\itype{T}}}, \tv{a} \lessdot^* \tv{b}$.
We generate an or-constraint with every possible combination for $\tv{b}$.
This includes every possible solution for $\tv{b}$ and therefore does not remove a possible solution.
This is due to the fact that \TFGJ does not allow lower bounds for generic variables.
%Every type variable left of a $\lessdot$-constraint will get a type assigned by \

\item[Step 3:]
In the third step the \textbf{substitution}-rule is applied.
If there is a constraint $\tv{a} \doteq \type{N}$ then there is no other way to fulfill the constraint set
than replacing $\tv{a}$ with $\type{N}$.
This does not remove a possible solution.

\item[Step 4:]
None of the constraints get modified.

\item[Step 5:]
If the algorithm advances to this step we further only work on constraint sets in solved form.
This means there are only four kinds of constraints left:
($a \doteq \itype{T}$), ($a \lessdot \itype{T}$), ($a \doteq b$) and ($a \lessdot b$) with $a$ and $b$ as type variables.

%We can set all TVs equal, because we allow only same TVs when having circles in a method call.
%This still will lead to the principal type.

The FGJ language does not allow subtype constraints for generic types.
A constraint like $(a \lessdot b)$ in a solution could be inserted as the typing shown in the example below.
But this is not allowed by the syntax of FGJ.
That is why we can treat this constraint as $(a \doteq b)$.

%TODO: This does not alter the outcome because the solution set is not modified anymore. All other TVs alread have a type like A =. Typ

\textit{Example:}
This would be a valid Java program but is not allowed in FGJ:
\begin{lstlisting}
class Example {
    <A extends Object, B extends A> A id(B a){
    return a;
    }
}
\end{lstlisting}

By replacing all ($a \lessdot b$) constraints with ($a \doteq b$) we
    do not remove the general unifier $\sigma$ as $a$ and $b$ are not substituted
    in $\sigma$. 

\item[Step 6:]
In the last step all the constraint sets, which are in solved form, are converted to unifiers.

We see that only a constraint set which has no unifier does not reach solved form.
We showed that in none of the steps of the \unify{} algorithm we exclude a possible unifier.
Also we showed that after we reach step 5 only constraint sets with a correct unifier are in solved form.
By removing all constraint sets which are not in solved form the algorithm does not
remove a possible correct unifier.

If we assume that there is a possible general unifier $\sigma$ for the input set $\consSet_{in}$
and the \unify{} algorithm does not exclude any of the possible unifiers,
then the result \unify{} contains the general unifier.
\hfill $\square$
\end{description}
\end{proof}

\section{Unify Termination Proof}\label{chapter:unifyTerminationProof}

The \unify{} algorithm gets called with a set of input constraints.
After resolving the \textbf{OrConstraints} we end up with multiple $Eq$ sets.
Afterwards the algorithm iterates over each of those sets (see Chapter \ref{sec:unify}).
We will show that \unify{} terminates on each of those sets by showing,
that each step of the algorithm removes at least one type variable
until the finishing state is reached.
The finishing state for a constraint set is reached when step 3 is not able to substitute a type variable.
This is checked by step 4 of the algorithm.
Then the $Eq$ set is either in solved form or determined to be unsolvable.

\textit{Proof:}
The \unify{} algorithm reduces the amount of type variables with every iteration.
No step adds a new type variable to the constraint set.
Additionally we have to show that the first step of the algorithm also terminates on every finite input set.

\begin{description}
\item[Step 1] 
Step 1 of the algorithm always terminates. \textit{Proof:}
Every rule either removes a $\lessdot$ constraint or reduces a $\exptype{C}{\ol{X}}$ to $\ol{X}$ inside a constraint.
None of the rules add a new $\lessdot$ constraint or a $\exptype{C}{\ol{X}}$ type to the constraint set.
Step 1 has to come to a stop once there are no more $\lessdot$ constraints or $\exptype{C}{\ol{X}}$ types to reduce.

The rule \textbf{match} seems to generate a new $\exptype{C}{\ol{X}}$ constraint,
but the $\exptype{C}{\ol{X}} \lessdot \exptype{D}{\ol{Y}}$ constraint added by \texttt{match}
will be changed immidiatly into a $\doteq$ constraint by the \texttt{adapt} rule.
Afterwards the \texttt{reduce1} rule will remove this freshly added $\exptype{C}{\ol{X}}$ type.
So effectively a $\doteq$ constraint is removed by this rule in combination with \texttt{adapt} and \texttt{reduce1}.

The \textbf{adopt} rule seems to generate a new $\lessdot$ constraint.
But the \texttt{adopt} rule triggers two other rules. The \texttt{match} and the \texttt{adapt} rule.
\begin{enumerate}
  \item We start with the \texttt{adopt} rule: \\
   $
  \begin{array}[c]{ll}
      \begin{array}[c]{l}
          Eq \cup \, \set{a \lessdot
          \exptype{C}{\ol{X}},
          b \lessdot^* a, b \lessdot \exptype{D}{\ol{Y}}} \\ 
          \hline
          \vspace*{-0.4cm}\\
          Eq \cup \set{
          a \lessdot
          \exptype{C}{\ol{X}},
          b \lessdot^*
          a
          , b \lessdot \exptype{C}{\ol{X}}
          , b \lessdot \exptype{D}{\ol{Y}}
          }
      %Eq \cup \set{\theta_1 \doteq \lambda'_1 \ldo \theta_n \doteq \lambda'_n}
      \end{array}
      \end{array}
      $
  \item We can now apply the \texttt{match} rule to the two resulting $(b \lessdot \ldots)$-constraints.
  If this is not possible due to type \texttt{C} not being a subtype of \texttt{D} or vice versa,
  then the $Eq$ set has no possible solution and \unify{} would terminate as fail $Uni = \emptyset$: \\
  $
  \begin{array}[c]{ll}
  \begin{array}[c]{l}
      Eq \cup \, \set{b \lessdot
      \exptype{C}{\ol{X}},
      b \lessdot
      \exptype{D}{\ol{Y}}} \\ 
      \hline
      \vspace*{-0.4cm}\\
      Eq \cup \set{b \lessdot \exptype{C}{\ol{X}}
      , \exptype{C}{\ol{X}} \lessdot \exptype{D}{\ol{Y}}}
  %Eq \cup \set{\theta_1 \doteq \lambda'_1 \ldo \theta_n \doteq \lambda'_n}
  \end{array}
  & \exptype{C}{\ol{Z}} <: \exptype{D}{\ol{N}} 
  \end{array}
      $\\
  \item The constraint added by the \texttt{match} rule fits the \texttt{adapt} rule, which we apply in the next step: $
  \begin{array}[c]{ll}
  \begin{array}[c]{l}
     Eq \cup \, \set{\exptype{C}{\ol{X}} \lessdot
      \exptype{D}{\ol{Y}}} \\ 
    \hline
    \vspace*{-0.4cm}\\
    Eq \cup \set{\exptype{D}{[ \ol{X} / \ol{Z} ]\ol{N}}
    \doteq \exptype{D}{\ol{Y}}}
  %Eq \cup \set{\theta_1 \doteq \lambda'_1 \ldo \theta_n \doteq \lambda'_n}
  \end{array}
  & \exptype{C}{\ol{Z}} <:\ \exptype{D}{\ol{N}}
  \end{array}
  $
  \end{enumerate}
In the end we have the conversion:\\
\begin{align*}\ddfrac{
  Eq \cup \, \set{a \lessdot
  \exptype{C}{\ol{X}},
  b \lessdot^* a, b \lessdot \exptype{D}{\ol{Y}}}
}{
  Eq \cup \set{a \lessdot
  \exptype{C}{\ol{X}},
  b \lessdot^* a, b \lessdot \exptype{D}{\ol{Y}}, \exptype{D}{[ \ol{X} / \ol{Z} ]\ol{N}}
  \doteq \exptype{D}{\ol{Y}}}
}\end{align*}

We can see now, that only a $\doteq$ constraint is added.
The \texttt{adopt} alone adds a $\lessdot$ constraint,
but due to the fact that it is always used together with \texttt{match} and \texttt{adapt} it effectively just adds a $\doteq$ constraint.

\item[Step 2] This step does not add new type variables to the constraint set.
\item[Step 3] The third step of the \unify{} algorithm removes at least one type variable
from the constraint set or otherwise does not alter $Eq$ at all.
If $Eq$ is not altered the algorithm terminates in the next step.
The type variable is not completely removed but stays inside $Eq$ only in one $a \doteq N$ constraint.
All other occurences are replaced by $N$.
The \texttt{subst} step can therefore only be executed once per type variable.
\end{description}

We see that with each iteration over the steps 1-3 at least one type variable is removed from the constraint set.
Due to the fact that there is never added a fresh type variable during the \unify{} algorithm,
the algorithm will terminate for any given finite set of constraints. \hfill $\square$


\section{Soundness, Completeness and Complexity Proofs}\label{chapter:soundness-completenessProof}
We show soundness and completeness by a case analysis over the type rules given by \TFGJ{}.
We will show that the constraints generated by \fjtype{} mirror
the \TFGJ{} type rules.
The \unify{} algorithm fullfils the constraints generated by \fjtype{} and
the \unify{} algorithm is sound and complete (see theorem \ref{theo:unifySoundness} and \ref{theo:unifyCompleteness}).
Therefore the $\fjtypeinference$ algorithm is sound and
complete, if the constraints generated by \fjtype{} mirror
the \TFGJ{} type rules.

As the \unify{} algorithm determines the set of general unifers it
  holds true that the types of $\mv{\Pi}'$ are
  instances of $\mv{\Pi}''$.

Now we show that the constraints generated by {\fjtype{}}
represent the type rules given in chapter \ref{chapter:type-rules}.
%For most of the expression typing rules this is trivial.
%Such as \texttt{GT-VAR}, \texttt{GT-FIELD} and \texttt{GT-NEW}.

%The \unify{} algorithm is complete, so every correct type is included in the solution set.
%We only have to choose the right type out of those solutions.
%When compiling multiple classes the problem arises,
%that only one of the type solutions calculated by \unify{} is correct
%in respective to the other classes that will be compiled afterwards.

%All types that are possible under the FGJ typing rules, plus our additional assumptions,
%also comply with the generated constraints.

%We match every generated constraint with the respective type rule to show soundness and completeness of our \textbf{FJTYPE} algorithm.
%This shows that none of the generated constraints remove a type which otherwise would be possible under the \TFGJ typing rules.
%The constraints are generated on expression statements.

The constraint generation starts with generating the method assumptions for the current class $\overline{\methodAssumption}$.
The constraints in $\consSet_o$ ensure valid overriding.
The constraints in $\consSet_m$ ensure that every type parameter has a bound.

\if0
To ensure well-formedness of types we have to ensure that every type variable generated by \fjtype{} has a bound assigned.
%The biggest part of the type rules can be expressed with the constraints generated by the \fjtype{} function.
The \texttt{WF-CLASS} rule checks types for well-formedness in a recursive fashion.
The types $\ol{T}$ used to instantiate the class $\exptype{C}{\ol{X}}$ need to follow the bounds given by the class declaration $\ol{T} <: [\ol{T}/\ol{X}]\ol{N}$, but also have to be well-formed themselfes $\ol{N}\ \texttt{ok}$.
\begin{lemma}[Well-formedness]\label{lemma:well-formedness}
  Given method assumptions $\Pi$ and a class \normalfont{$\texttt{class}\ \exptype{C}{\ol{X} \triangleleft \ol{N}}$} with
  \normalfont{$\fjtypeinference(\mv{\Pi}, \texttt{class}\ \exptype{C}{\ol{X} \triangleleft \ol{N}}) = \mv{\Pi}'$},
  then the following statements holds:\\
  \normalfont $\forall (\exptype{C}{\ol{X} \triangleleft \ol{N}}.\texttt{m} : \exptype{}{\ol{Y} \triangleleft \ol{P}}\ \ol{\type{T}} \to \itype{T}) \in \mv{\Pi}': \quad \ol{X} <: \ol{N}, \ol{Y} <: \ol{P} \vdash \type{T}, \ol{T}, \ol{P}, \ol{N}\ \texttt{ok}$
\end{lemma}
\textbf{Well-formedness Proof:}
Well-formedness of types already declared in the input class can be easily checked before the start of the \fjtype{} algorithm.
We therefore assume all types and type variables given in the input to be well-formed and are not checking this during the type inference step.
%This applies to the bounds $\ol{N}$ of class definitions $\texttt{class}\ \exptype{C}{\ol{X} \triangleleft \ol{N}}$
%as well as field types and types given in cast expressions.
%This also means every generic variable used in the input to be correctly declared according to the \texttt{WF-VAR} rule.
So assuming $\ol{X} <: \ol{N}, \ol{Y} <: \ol{P} \vdash \ol{N}, \ol{P}\ \texttt{ok}$, we only have to show that every type inserted by our type inference algorithm is well-formed.

Using theorem \ref{theo:unifySoundness} we can show that $\ol{X} <: \ol{N}, \ol{Y} <: \ol{P} \vdash \type{T}, \ol{T}, \ol{P}, \ol{N}\ \texttt{ok}$.
There is only two ways our type inference algorithm is able to produce a type, which is not well-formed.
Either by violating a generic bound (see \texttt{WF-CLASS} rule)
or by using a generic variable, which is not in scope (see \texttt{WF-VAR} rule).
Every type variable generated by \fjtype{} is used in atleast one constraint ensuring compliance with the \texttt{WF-CLASS} rule.
The \texttt{WF-VAR} rule is satisfied, because the \unify{} function returns a type environment $\gamma$ under which the types are correct.
This type environment is used as generic type parameters in every method (see \fjtypeinference{}). 

%The \texttt{WF-CLASS} rule is always satisfied, because the \fjtype function generates $\lessdot$ constraints for every type used as a generic instantiation.
%%The exception to this is the type variable $\tv{a}$ generated by \typeExpr{} for method calls.
%%Here a $\doteq$-constraint is generated with $\tv{a}$ on the left side.
%%The \unify{} function will assign a well-formed type to $\tv{a}$, because all other types used are well-formed and the 
%Due to lemma \ref{lemma:unify-exhaustive} we can be sure that each type variable either gets a type assigned or a generic variable, which is correctly added to the method type by $\fjtypeInsert$.
\fi

We compare the constraints generated by the \typeExpr{} function with the appropriate type rule from \TFGJ:
\begin{description}
  \item [Local var]
  No constraints are generated.
  \item[Method invocation]
By direct comparison we show that each of the generated constraints applies the same restrictions than the \texttt{GT-INVK} rule.
The \texttt{GT-INVK} rule states the condition $\textit{mtype}(m, \textit{bound}_\triangle(T_0), \mtypeEnvironment) = \exptype{}{\ol{Y} \triangleleft \ol{P}}\ \ol{U} \to U$.
The constraint $\type{R} \lessdot \exptype{C}{\ol{\tv{a}}}$ assures that the type of the expression $e_0$ contains the method \texttt{m}.
The type variables $\ol{\tv{b}}$ represent instances of $\ol{Y}$.
When calling a local method the generic variables $\ol{Y} \triangleleft \ol{P}$ are not present and $\ol{\tv{b}}$ is empty.
This is correct, because the \TFGJ type rules prevent local method calls to be polymorphic.

We generate constraints according to the \texttt{GT-INVK} rule:\\
\begin{small}
\begin{tabularx}{\linewidth}{lX|Xl}
  \textbf{\TFGJ{} Type rule} &&& \textbf{Constraints} \\
  $\mathtt{\environmentvdash e_0 : T_0 }$ &&&
    $({R}, \consSet_R) = \typeExpr(({\mtypeEnvironment} ;\overline{\localVarAssumption}), \texttt{e})$\\ 
  $\mathtt{\mathit{bound}_\Delta (T_0)}$ &&& $\type{R} \lessdot \exptype{C}{\ol{\tv{a}}}$ \\
  $\mathtt{\mathit{mtype}(m, \mathit{bound}_\Delta (T_0), \Pi)}$ &&& Lookup in the assumptions \\
 %$\textit{mtype}(m, \textit{bound}_\triangle(T_0)) = \ol{U} \to U$ & $\type{R} \doteq cl$\\
 $\environmentvdash \ol{e} : \ol{S}$ &&& $\forall \texttt{e}_i \in \ol{e} : (R_i, \consSet_i) = \typeExpr(({\mtypeEnvironment} ;
 \overline{\localVarAssumption}), \texttt{e}_i)$\\
 $\Delta \vdash \ol{S} \subeq  [\ol{V}/\ol{Y}]\ol{U}$ &&& $ \overline{R} \lessdot [\ol{\tv{b}}/\ol{Y}][\ol{\tv{a}}/\ol{X}]\overline{T}$\\
 $\environmentvdash \mathtt{e_0.m(\overline{e}) : [\ol{V}/\ol{Y}]U }$ &&& $ \tv{a} \doteq [\ol{\tv{b}}/\ol{Y}][\ol{\tv{a}}/\ol{X}]{T}$ \\
 $\Delta \vdash \ol{V} \subeq  [\ol{V}/\ol{Y}]\ol{P}$ &&& $\ol{\tv{b}} \lessdot [\ol{\tv{b}}/\ol{Y}][\ol{\tv{a}}/\ol{X}]\ol{P}$ \\
\end{tabularx}
\end{small}

No constraint is needed to ensure $\ol{V}\ \texttt{ok}$.
% If we call a method, which comes with generic parameters $\ol{Y} \triangleleft \ol{P}$,
% the $\ol{\tv{b}} \lessdot [\ol{\tv{b}}/\ol{Y}][\ol{\tv{a}}/\ol{X}]\ol{P}$ ensure well-formedness, knowing that $\ol{P}\ \texttt{ok}$.
% When the method call is to a local method, $\ol{\tv{b}}$ stays empty.
% It is possible for the local method to get equipped with generic parameters after the \unify{} step.
% If this is the case, every local method will get the same generic types $\gamma$ given by the \unify{} function.
% Under this type environment every type is well-formed (see lemma \ref{lemma:well-formedness}).
% The $\ol{\tv{a}} \lessdot [\overline{\tv{a}}/\ol{X}]\ol{N}$ constraints guarantee the well-formedness of the fresh type variables $\ol{\tv{a}}$.

\item[Field access]
The constraint generation behaves mostly the same as method invocation.
We also generate or-constraints in the case of multiple classes containing a field with the same name.
The field types are already given in the input and need not to be inferred.
%We assume they are well-formed and set the type of the field access to the same type as the field $\tv{a} \doteq
%[\overline{\tv{a}}/\ol{X}]\type{T}$

\if0
 \begin{tabular}{l|l}
   \textbf{FGJ Type rule} & \textbf{Constraints} \\
   $\Gamma \vdash e_0:T_0$ & $(\type{R}, ConS) = \typeExpr(Ass, e_r)$\\ 
   $\quad \mathit{fields}(\mathit{bound}_\triangle(T_0)) = \overline{T} \ \overline{f}$ & $\type{R} \doteq \exptype{C}{\textbf{fresh}(\ol{X})}$ \\
  %$\textit{mtype}(m, \textit{bound}_\triangle(T_0)) = \ol{U} \to U$ & $\type{R} \doteq cl$\\
  $\triangle; \Gamma \vdash \ol{e} : \ol{S}$ & $\forall e_i \in \overline{e} : (pt_i, ConS_i) = \typeExpr(Ass, e_i)$\\
  $\triangle \vdash \ol{S} <: \ol{U}$ & $ \bigcup_{T_i \in \overline{T}} (pt_i \lessdot \textbf{fresh}(T_i))$\\
  $\triangle; \Gamma \vdash \mathtt{e_0.m(\overline{e}) : U }$ & $a \doteq \textbf{fresh}(T)$ \\
 \end{tabular}
 \fi
 \item[Constructor] We generate constraints according to the \texttt{GT-NEW} rule:\\
 \begin{tabularx}{\linewidth}{lX|Xl}
  \textbf{\TFGJ{} Type rule} &&& \textbf{Constraints} \\
  $\environmentvdash \ol{e} : \ol{S}$ &&& $\forall \texttt{e}_i \in \overline{\texttt{e}} : (R_i, \consSet_i) = \typeExpr(({\mtypeEnvironment} ;
  \overline{\localVarAssumption}), \texttt{e}_i)$\\
  $\environmentvdash \ol{S} <: \ol{T}$ &&& $\overline{R} \lessdot \overline{T}$\\
  $\type{N}\ \texttt{ok}$ &&& $\overline{\tv{a}} \lessdot
  [\overline{\tv{a}}/\ol{X}]\ol{N}$\\
  $\mathtt{\mathit{bound}_\Delta (T_0)}$ &&& ${R} \lessdot \exptype{C}{\ol{\tv{a}}}$ \\
  $\mathtt{\mathit{fields}(\mathit{bound}_\Delta (T_0))}$ &&& $\tv{a} \doteq [\overline{\tv{a}}/\ol{X}]\type{T}$
\end{tabularx}

\item[Cast]
A cast can either be an upcast or a downcast or a so called stupid cast.
See respective type rules \texttt{GT-UCAST}, \texttt{GT-DCAST}, \texttt{GT-SCAST} in chapter \ref{chapter:type-rules}.
%Every type of cast is allowed in \TFGJ, therefore no restrictions in form of constraints are needed.
%The check if the cast type $\mathtt{N}$ is well formed ($\mathtt{N}\ \text{ok}$) is done in advance to the \textbf{FJTYPE} algorithm.
We assume that each given type in our input set is well-formed.
Therefore the cast type $\mathtt{N}$ is well formed too.
So every possible type of cast is allowed in \TFGJ, therefore no restrictions in form of constraints are needed.

\end{description}

\hfill $\square$

\section{NP-Hard Complexity Proof}\label{section:np-hard}
This section will show this by reducing the boolean satisfiability problem (SAT) to the \fjtypeinference{} algorithm.

\begin{figure}
\begin{lstlisting}
  class True extends Object{
  }
  class False extends Object{
  }

  class Nand1 extends Object{
    False nand(True a, True b){ return new False(); }
  }
  class Nand2 extends Object{
    True nand(False a, True b){ return new True(); }
  }
  class Nand3 extends Object{
    True nand(True a, False b){ return new True(); }
  }
  class Nand4 extends Object{
    True nand(False a, False b){ return new True(); }
  }

  class SATExample extends Object{
    True f;

    sat(v1, v2, v3, o1, o2){
      return o1.nand(v1, o2.nand(v2, v3));
    }

    forceSATtoTrue(v1, v2, v3, o1, o2){
      return new SATExample(this.sat(v1, v2, v3, o1, o2));
    }
  }
\end{lstlisting}

\caption{Representation for a SAT problem in FJ code}
\label{fig:fjSATcode}
\end{figure}

Any given boolean expression $B$ can be transformed to a typeless FJ program.
A type inference algorithm finding a possible typisation of this FJ program also solves the boolean expression $B$.
Figure \ref{fig:fjSATcode} shows an example of this.
The classes \texttt{True}, \texttt{False} and \texttt{Operations} always stay the same.
Here we assume that the boolean expression only consists out of $\neg \land$ (NAND) operators.
Now any boolean expression $B_\text{in} = v_1 \land \neg (v_2 \land v_3) \land \ldots$ can be expressed as a Java method.
The example in figure \ref{fig:fjSATcode} represents the problem $B_\text{in} = \neg(v_1 \land \neg (v_2 \land v_3))$.
Additionally we force the return type of the \texttt{sat} method to have the type \texttt{True}
by instancing the \texttt{SATExample} class, which requires the type \texttt{True}.
When using the \fjtypeinference{} algorithm on the generated FJ code it will
assign each parameter of the \texttt{sat} method with either the type \texttt{True} or \texttt{False}.
This represents a valid assignment for the expression $B_\text{in}$.
If \fjtypeinference{} fails to compute a solution the $B_\text{in}$ has no possible solution.
A correct solution for the \texttt{sat} method in figure \ref{fig:fjSATcode} would be:\\
\texttt{True sat(False v1, True v2, True v3, Nand4 o1, Nand1 o2)}

Any SAT problem can be transferred in polynomial time to a typeless FJ program.
Every literal $v$ in the SAT problem becomes a method parameter of the \texttt{sat} method, as well as every instance of a NAND operator used.

This reduction of SAT to our type inference algorithm proofs that its
complexity is at least NP-Hard.
\hfill $\square$

\section{NP-Complete Complexity Proof}\label{section:np-complete}
We know the algorithm is NP-hard (see \ref{theo:np-completeness}).
To proof NP-Completeness we have to show that it is possible to verify a solution in polynomial time.
The verification of a type solution is the FJ typecheck.

It is easy to see that the expression typing rules can be checked in polynomial time as long as subtyping between two types is verifiable in polynomial time.

Subtyping is also solvable in polynomial time in \TFGJ{}.
Assume $\exptype{C}{\ol{X}} \leq \exptype{D}{\ol{Y}}$ with the number of generics $\ol{X}$ and $\ol{Y}$ less or equal $n$.
Also the number of classes in the subtyperelation is less or equal to $n$.
With $n$ classes the \texttt{S-TRANS} rule can be applied a maximum of $n$ times.
Each time the \texttt{S-CLASS} rules is applied which sets in the variables $\ol{X}$ into the supertype.
This operations also runs in polynomial time, so the subtyping relation is decidable in polynomial time.

This shows that the time complexity of the GFJ type check is at least
polynomial or better. 
\hfill $\square$